import {
  __privateAdd,
  __privateGet,
  __privateSet
} from "./chunk-DP4XHQAG.js";

// node_modules/atomico/src/ref.js
var _current, _listeners;
var Ref = class {
  /**
   * @param {T} current
   */
  constructor(current) {
    /**
     * @type {T}
     */
    __privateAdd(this, _current);
    __privateAdd(this, _listeners, /* @__PURE__ */ new Set());
    __privateSet(this, _current, current);
  }
  /**
   * @return {T}
   */
  get current() {
    return __privateGet(this, _current);
  }
  /**
   * @param {T} value
   */
  set current(value) {
    if (__privateGet(this, _current) != value) {
      __privateSet(this, _current, value);
      __privateGet(this, _listeners).forEach((fn) => fn(value));
    }
  }
  /**
   * @type {import("hooks").Ref["on"]}
   */
  on(fn) {
    __privateGet(this, _listeners).add(fn);
    return () => __privateGet(this, _listeners).delete(fn);
  }
};
_current = new WeakMap();
_listeners = new WeakMap();
var createRef = (value) => new Ref(value);

// node_modules/atomico/src/hooks/create-hooks.js
var ID = Symbol.for("atomico.hooks");
globalThis[ID] = globalThis[ID] || {};
var SCOPE = globalThis[ID];
var IdSuspense = Symbol.for("Atomico.suspense");
var IdEffect = Symbol.for("Atomico.effect");
var IdLayoutEffect = Symbol.for("Atomico.layoutEffect");
var IdInsertionEffect = Symbol.for("Atomico.insertionEffect");
var useHook = (render, effect, tag) => {
  const { i, hooks } = SCOPE.c;
  const hook = hooks[i] = hooks[i] || {};
  hook.value = render(hook.value);
  hook.effect = effect;
  hook.tag = tag;
  SCOPE.c.i++;
  return hooks[i].value;
};
var useRef = (current) => useHook((ref = createRef(current)) => ref);
var useHost = () => useHook((ref = createRef(SCOPE.c.host)) => ref);
var useUpdate = () => SCOPE.c.update;
var createHooks = (update, host, id = 0) => {
  let hooks = {};
  let suspense = false;
  const isSuspense = () => suspense;
  const cleanEffectsByType = (tag, unmounted) => {
    for (const index in hooks) {
      const hook = hooks[index];
      if (hook.effect && hook.tag === tag) {
        hook.value = hook.effect(hook.value, unmounted);
      }
    }
  };
  const load = (callback) => {
    SCOPE.c = { host, hooks, update, i: 0, id };
    let value;
    try {
      suspense = false;
      value = callback();
    } catch (e) {
      if (e !== IdSuspense) throw e;
      suspense = true;
    } finally {
      SCOPE.c = null;
    }
    return value;
  };
  const cleanEffects = (unmounted) => {
    cleanEffectsByType(IdInsertionEffect, unmounted);
    return () => {
      cleanEffectsByType(IdLayoutEffect, unmounted);
      return () => {
        cleanEffectsByType(IdEffect, unmounted);
      };
    };
  };
  return { load, cleanEffects, isSuspense };
};

// node_modules/atomico/src/utils.js
var SymbolFor = Symbol.for;
function isEqualArray(before, after) {
  const length = before.length;
  if (length !== after.length) return false;
  for (let i = 0; i < length; i++) {
    let beforeValue = before[i];
    let afterValue = after[i];
    if (beforeValue !== afterValue) return false;
  }
  return true;
}
var isFunction = (value) => typeof value == "function";
var isObject = (value) => typeof value == "object";
var { isArray } = Array;
var isHydrate = (node, styleOnly) => (styleOnly ? node instanceof HTMLStyleElement : true) && "hydrate" in ((node == null ? void 0 : node.dataset) || {});
function flat(list, callback) {
  let last;
  const reduce = (list2) => {
    let { length } = list2;
    for (let i = 0; i < length; i++) {
      const value = list2[i];
      if (value && Array.isArray(value)) {
        reduce(value);
      } else {
        const type = typeof value;
        if (value == null || type === "function" || type === "boolean") {
          continue;
        } else if (type === "string" || type === "number") {
          if (last == null) last = "";
          last += value;
        } else {
          if (last != null) {
            callback(last);
            last = null;
          }
          callback(value);
        }
      }
    }
  };
  reduce(list);
  if (last != null) callback(last);
}
var addListener = (target, type, handler) => {
  target.addEventListener(type, handler);
  return () => target.removeEventListener(type, handler);
};

// node_modules/atomico/src/element/errors.js
var Error = class {
  /**
   *
   * @param {HTMLElement} target
   * @param {string} message
   * @param {string} value
   */
  constructor(target, message, value) {
    this.message = message;
    this.target = target;
    this.value = value;
  }
};
var PropError = class extends Error {
};
var ParseError = class extends Error {
};

// node_modules/atomico/src/element/set-prototype.js
var CUSTOM_TYPE_NAME = "Custom";
var Any = null;
var TRUE_VALUES = { true: 1, "": 1, 1: 1 };
function setPrototype(prototype, prop, schema, attrs, values) {
  const {
    type,
    reflect,
    event,
    value: defaultValue,
    attr = getAttr(prop)
  } = (schema == null ? void 0 : schema.name) != CUSTOM_TYPE_NAME && isObject(schema) && schema != Any ? schema : { type: schema };
  const isCustomType = (type == null ? void 0 : type.name) === CUSTOM_TYPE_NAME && type.map;
  const withDefaultValue = defaultValue != null ? type == Function || !isFunction(defaultValue) ? () => defaultValue : defaultValue : null;
  Object.defineProperty(prototype, prop, {
    configurable: true,
    /**
     * @this {import("dom").AtomicoThisInternal}
     * @param {any} newValue
     */
    set(newValue) {
      const oldValue = this[prop];
      if (withDefaultValue && type != Boolean && newValue == null) {
        newValue = withDefaultValue();
      }
      const { error, value } = (isCustomType ? mapValue : filterValue)(
        type,
        newValue
      );
      if (error && value != null) {
        throw new PropError(
          this,
          `The value defined for prop '${prop}' must be of type '${type.name}'`,
          value
        );
      }
      if (oldValue == value) return;
      this._props[prop] = value == null ? void 0 : value;
      this.update();
      event && dispatchEvent(this, event);
      this.updated.then(() => {
        if (reflect) {
          this._ignoreAttr = attr;
          reflectValue(this, type, attr, this[prop]);
          this._ignoreAttr = null;
        }
      });
    },
    /**
     * @this {import("dom").AtomicoThisInternal}
     */
    get() {
      return this._props[prop];
    }
  });
  if (withDefaultValue) values[prop] = withDefaultValue();
  attrs[attr] = { prop, type };
}
var dispatchEvent = (node, { type, base = CustomEvent, ...eventInit }) => node.dispatchEvent(new base(type, eventInit));
var getAttr = (prop) => prop.replace(/([A-Z])/g, "-$1").toLowerCase();
var reflectValue = (host, type, attr, value) => value == null || type == Boolean && !value ? host.removeAttribute(attr) : host.setAttribute(
  attr,
  (type == null ? void 0 : type.name) === CUSTOM_TYPE_NAME && (type == null ? void 0 : type.serialize) ? type == null ? void 0 : type.serialize(value) : isObject(value) ? JSON.stringify(value) : type == Boolean ? "" : value
);
var transformValue = (type, value) => type == Boolean ? !!TRUE_VALUES[value] : type == Number ? Number(value) : type == String ? value : type == Array || type == Object ? JSON.parse(value) : type.name == CUSTOM_TYPE_NAME ? value : (
  // TODO: If when defining reflect the prop can also be of type string?
  new type(value)
);
var mapValue = ({ map }, value) => {
  try {
    return { value: map(value), error: false };
  } catch {
    return { value, error: true };
  }
};
var filterValue = (type, value) => type == null || value == null ? { value, error: false } : type != String && value === "" ? { value: void 0, error: false } : type == Object || type == Array || type == Symbol ? {
  value,
  error: {}.toString.call(value) !== `[object ${type.name}]`
} : value instanceof type ? {
  value,
  error: type == Number && Number.isNaN(value.valueOf())
} : type == String || type == Number || type == Boolean ? {
  value,
  error: type == Number ? typeof value != "number" ? true : Number.isNaN(value) : type == String ? typeof value != "string" : typeof value != "boolean"
} : { value, error: true };

// node_modules/atomico/src/element/custom-element.js
var ID2 = 0;
var getHydrateId = (node) => {
  var _a;
  const id = ((_a = (node == null ? void 0 : node.dataset) || {}) == null ? void 0 : _a.hydrate) || "";
  if (id) {
    return id;
  } else {
    return "c" + ID2++;
  }
};
var c = (component, options2 = HTMLElement) => {
  const attrs = {};
  const values = {};
  const withBase = "prototype" in options2 && options2.prototype instanceof Element;
  const base = withBase ? options2 : "base" in options2 ? options2.base : HTMLElement;
  const { props, styles } = withBase ? component : options2;
  class AtomicoElement extends base {
    constructor() {
      super();
      this._setup();
      this._render = () => component({ ...this._props });
      for (const prop in values) this[prop] = values[prop];
    }
    /**
     * @returns {import("core").Sheets[]}
     */
    static get styles() {
      return [super.styles, styles];
    }
    async _setup() {
      if (this._props) return;
      this._props = {};
      let mountParentNode;
      let unmountParentNode;
      this.mounted = new Promise(
        (resolve) => this.mount = () => {
          resolve();
          if (mountParentNode != this.parentNode) {
            if (unmountParentNode != mountParentNode) {
              this.unmounted.then(this.update);
            } else {
              this.update();
            }
          }
          mountParentNode = this.parentNode;
        }
      );
      this.unmounted = new Promise(
        (resolve) => this.unmount = () => {
          resolve();
          if (mountParentNode != this.parentNode || !this.isConnected) {
            hooks.cleanEffects(true)()();
            unmountParentNode = this.parentNode;
            mountParentNode = null;
          }
        }
      );
      this.symbolId = this.symbolId || Symbol();
      this.symbolIdParent = Symbol();
      const hooks = createHooks(
        () => this.update(),
        this,
        getHydrateId(this)
      );
      let prevent;
      let firstRender = true;
      const hydrate = isHydrate(this);
      this.update = () => {
        if (!prevent) {
          prevent = true;
          this.updated = (this.updated || this.mounted).then(() => {
            try {
              const result = hooks.load(this._render);
              const cleanUseLayoutEffects = hooks.cleanEffects();
              result && //@ts-ignore
              result.render(this, this.symbolId, hydrate);
              prevent = false;
              if (firstRender && !hooks.isSuspense()) {
                firstRender = false;
                !hydrate && applyStyles(this);
              }
              return cleanUseLayoutEffects();
            } finally {
              prevent = false;
            }
          }).then(
            /**
             * @param {import("internal/hooks.js").CleanUseEffects} [cleanUseEffect]
             */
            (cleanUseEffect) => {
              cleanUseEffect && cleanUseEffect();
            }
          );
        }
        return this.updated;
      };
      this.update();
    }
    connectedCallback() {
      this.mount();
      super.connectedCallback && super.connectedCallback();
    }
    disconnectedCallback() {
      super.disconnectedCallback && super.disconnectedCallback();
      this.unmount();
    }
    /**
     * @this {import("dom").AtomicoThisInternal}
     * @param {string} attr
     * @param {(string|null)} oldValue
     * @param {(string|null)} value
     */
    attributeChangedCallback(attr, oldValue, value) {
      if (attrs[attr]) {
        if (attr === this._ignoreAttr || oldValue === value) return;
        const { prop, type } = attrs[attr];
        try {
          this[prop] = transformValue(type, value);
        } catch (e) {
          throw new ParseError(
            this,
            `The value defined as attr '${attr}' cannot be parsed by type '${type.name}'`,
            value
          );
        }
      } else {
        super.attributeChangedCallback(attr, oldValue, value);
      }
    }
    static get props() {
      return { ...super.props, ...props };
    }
    static get observedAttributes() {
      const superAttrs = super.observedAttributes || [];
      for (const prop in props) {
        setPrototype(this.prototype, prop, props[prop], attrs, values);
      }
      return Object.keys(attrs).concat(superAttrs);
    }
  }
  return AtomicoElement;
};
function applyStyles(host) {
  const { styles } = host.constructor;
  const { shadowRoot } = host;
  if (shadowRoot && styles.length) {
    const sheets = [];
    flat(styles, (value) => {
      if (value) {
        if (value instanceof Element) {
          shadowRoot.appendChild(value.cloneNode(true));
        } else {
          sheets.push(value);
        }
      }
    });
    if (sheets.length) shadowRoot.adoptedStyleSheets = sheets;
  }
}

// node_modules/atomico/src/hooks/use-effect.js
var createEffect = (type) => (currentEffect, currentArgs) => {
  useHook(
    /**
     * Clean the effect hook
     * @type {import("internal/hooks.js").CollectorEffect}
     */
    ([collector, args] = []) => {
      if (args || !args) {
        if (args && isEqualArray(args, currentArgs)) {
          collector = collector || true;
        } else {
          isFunction(collector) && collector();
          collector = null;
        }
      }
      return [collector, currentArgs];
    },
    /**
     * @returns {any}
     */
    ([collector, args], unmounted) => {
      if (unmounted) {
        isFunction(collector) && collector();
        return [];
      } else {
        return [collector ? collector : currentEffect(), args];
      }
    },
    type
  );
};
var useLayoutEffect = createEffect(IdLayoutEffect);
var useEffect = createEffect(IdEffect);
var useInsertionEffect = createEffect(IdInsertionEffect);

// node_modules/atomico/src/hooks/state.js
var State = class extends Array {
  /**
   *
   * @param {any} initialState
   * @param {(nextState: any, state:any[], mount: boolean )=>void} mapState
   */
  constructor(initialState, mapState) {
    let mount = true;
    const setState = (nextState) => {
      try {
        mapState(nextState, this, mount);
      } finally {
        mount = false;
      }
    };
    super(void 0, setState, mapState);
    setState(initialState);
  }
  /**
   * The following code allows a mutable approach to useState
   * and useProp this with the idea of allowing an alternative
   * approach similar to Vue or Qwik of state management
   * @todo pending review with the community
   */
  // get value() {
  //     return this[0];
  // }
  // set value(nextState) {
  //     this[2](nextState, this);
  // }
};

// node_modules/atomico/src/hooks/hooks.js
var useState = (initialState) => {
  const update = useUpdate();
  return useHook(
    (state = new State(initialState, (nextState, state2, mount) => {
      nextState = isFunction(nextState) ? nextState(state2[0]) : nextState;
      if (nextState !== state2[0]) {
        state2[0] = nextState;
        if (!mount) update();
      }
    })) => state
  );
};
var useMemo = (currentMemo, currentArgs) => {
  const [state] = useHook(([state2, args, cycle = 0] = []) => {
    if (!args || args && !isEqualArray(args, currentArgs)) {
      state2 = currentMemo();
    }
    return [state2, currentArgs, cycle];
  });
  return state;
};

// node_modules/atomico/src/options.js
var ID3 = SymbolFor("atomico/options");
globalThis[ID3] = globalThis[ID3] || {
  sheet: !!document.adoptedStyleSheets
};
var options = globalThis[ID3];

// node_modules/atomico/src/loaded.js
var DOMLoaded = new Promise((resolve) => {
  if (!options.ssr) {
    if (document.readyState === "loading") {
      addListener(document, "DOMContentLoaded", resolve);
    } else {
      resolve();
    }
  }
});

// node_modules/atomico/src/render.js
var VAL_FROM_PROPS = {
  checked: 1,
  value: 1,
  selected: 1
};
var PROPS_AS_ATTRS = {
  list: 1,
  type: 1,
  size: 1,
  form: 1,
  width: 1,
  height: 1,
  src: 1,
  href: 1,
  slot: 1
};
var INTERNAL_PROPS = {
  shadowDom: 1,
  staticNode: 1,
  cloneNode: 1,
  children: 1,
  key: 1
};
var EMPTY_PROPS = {};
var EMPTY_CHILDREN = [];
var Mark = class extends Text {
};
var ID4 = SymbolFor("atomico/id");
var TYPE = SymbolFor("atomico/type");
var TYPE_NODE = SymbolFor("atomico/ref");
var TYPE_VNODE = SymbolFor("atomico/vnode");
var Fragment = () => {
};
function RENDER(node, id, hydrate) {
  return diff(this, node, id, hydrate);
}
var h = (type, p, ...args) => {
  const props = p || EMPTY_PROPS;
  let { children } = props;
  children = children != null ? children : args.length ? args : EMPTY_CHILDREN;
  if (type === Fragment) {
    return children;
  }
  const raw = type ? type instanceof Node ? 1 : (
    //@ts-ignore
    type.prototype instanceof HTMLElement && 2
  ) : 0;
  if (raw === false && type instanceof Function) {
    return type(
      children != EMPTY_CHILDREN ? { children, ...props } : props
    );
  }
  const render = options.render || RENDER;
  const vnode = {
    [TYPE]: TYPE_VNODE,
    type,
    props,
    children,
    key: props.key,
    // key for lists by keys
    // define if the node declares its shadowDom
    shadow: props.shadowDom,
    // allows renderings to run only once
    static: props.staticNode,
    // defines whether the type is a childNode `1` or a constructor `2`
    raw,
    // defines whether to use the second parameter for document.createElement
    is: props.is,
    // clone the node if it comes from a reference
    clone: props.cloneNode,
    render
  };
  return vnode;
};
function diff(newVnode, node, id = ID4, hydrate, isSvg) {
  let isNewNode;
  if (node && node[id] && node[id].vnode == newVnode || newVnode[TYPE] != TYPE_VNODE)
    return node;
  if (newVnode || !node) {
    isSvg = isSvg || newVnode.type == "svg";
    isNewNode = newVnode.type != "host" && (newVnode.raw == 1 ? (node && newVnode.clone ? node[TYPE_NODE] : node) != newVnode.type : newVnode.raw == 2 ? !(node instanceof newVnode.type) : node ? node[TYPE_NODE] || node.localName != newVnode.type : !node);
    if (isNewNode && newVnode.type != null) {
      if (newVnode.raw == 1 && newVnode.clone) {
        hydrate = true;
        node = newVnode.type.cloneNode(true);
        node[TYPE_NODE] = newVnode.type;
      } else {
        node = newVnode.raw == 1 ? newVnode.type : newVnode.raw == 2 ? new newVnode.type() : isSvg ? document.createElementNS(
          "http://www.w3.org/2000/svg",
          newVnode.type
        ) : document.createElement(
          newVnode.type,
          newVnode.is ? { is: newVnode.is } : void 0
        );
      }
    }
  }
  const oldVNodeStore = node[id] ? node[id] : EMPTY_PROPS;
  const { vnode = EMPTY_PROPS, cycle = 0 } = oldVNodeStore;
  let { fragment, handlers } = oldVNodeStore;
  const { children = EMPTY_CHILDREN, props = EMPTY_PROPS } = vnode;
  handlers = isNewNode ? {} : handlers || {};
  if (newVnode.static && !isNewNode) return node;
  newVnode.shadow && !node.shadowRoot && // @ts-ignore
  node.attachShadow({ mode: "open", ...newVnode.shadow });
  newVnode.props != props && diffProps(node, props, newVnode.props, handlers, isSvg);
  if (newVnode.children !== children) {
    const nextParent = newVnode.shadow ? node.shadowRoot : node;
    fragment = renderChildren(
      newVnode.children,
      /**
       * @todo for hydration use attribute and send childNodes
       */
      fragment,
      nextParent,
      id,
      // add support to foreignObject, children will escape from svg
      !cycle && hydrate,
      isSvg && newVnode.type == "foreignObject" ? false : isSvg
    );
  }
  node[id] = { vnode: newVnode, handlers, fragment, cycle: cycle + 1 };
  return node;
}
function createFragment(parent, hydrate) {
  const markStart = new Mark("");
  const markEnd = new Mark("");
  let node;
  parent[hydrate ? "prepend" : "append"](markStart);
  if (hydrate) {
    let { lastElementChild } = parent;
    while (lastElementChild) {
      const { previousElementSibling } = lastElementChild;
      if (isHydrate(lastElementChild, true) && !isHydrate(previousElementSibling, true)) {
        node = lastElementChild;
        break;
      }
      lastElementChild = previousElementSibling;
    }
  }
  if (node) {
    node.before(markEnd);
  } else {
    parent.append(markEnd);
  }
  return {
    markStart,
    markEnd
  };
}
function renderChildren(children, fragment, parent, id, hydrate, isSvg) {
  children = children == null ? null : isArray(children) ? children : [children];
  const nextFragment = fragment || createFragment(parent, hydrate);
  const { markStart, markEnd, keyes } = nextFragment;
  let nextKeyes;
  const removeNodes = keyes && /* @__PURE__ */ new Set();
  let currentNode = markStart;
  children && flat(children, (child) => {
    if (typeof child == "object" && !child[TYPE]) {
      return;
    }
    const key = child[TYPE] && child.key;
    const childKey = keyes && key != null && keyes.get(key);
    if (currentNode != markEnd && currentNode === childKey) {
      removeNodes.delete(currentNode);
    } else {
      currentNode = currentNode == markEnd ? markEnd : currentNode.nextSibling;
    }
    const childNode = keyes ? childKey : currentNode;
    let nextChildNode = childNode;
    if (!child[TYPE]) {
      const text = child + "";
      if (!(nextChildNode instanceof Text) || nextChildNode instanceof Mark) {
        nextChildNode = new Text(text);
      } else if (nextChildNode.data != text) {
        nextChildNode.data = text;
      }
    } else {
      nextChildNode = diff(child, childNode, id, hydrate, isSvg);
    }
    if (nextChildNode != currentNode) {
      keyes && removeNodes.delete(nextChildNode);
      if (!childNode || keyes) {
        parent.insertBefore(nextChildNode, currentNode);
        keyes && currentNode != markEnd && removeNodes.add(currentNode);
      } else if (childNode == markEnd) {
        parent.insertBefore(nextChildNode, markEnd);
      } else {
        parent.replaceChild(nextChildNode, childNode);
        currentNode = nextChildNode;
      }
    }
    if (key != null) {
      nextKeyes = nextKeyes || /* @__PURE__ */ new Map();
      nextKeyes.set(key, nextChildNode);
    }
  });
  currentNode = currentNode == markEnd ? markEnd : currentNode.nextSibling;
  if (fragment && currentNode != markEnd) {
    while (currentNode != markEnd) {
      const nodeToRemove = currentNode;
      currentNode = currentNode.nextSibling;
      nodeToRemove.remove();
    }
  }
  removeNodes && removeNodes.forEach((node) => node.remove());
  nextFragment.keyes = nextKeyes;
  return nextFragment;
}
function diffProps(node, props, nextProps, handlers, isSvg) {
  for (const key in props) {
    !(key in nextProps) && setProperty(node, key, props[key], null, isSvg, handlers);
  }
  for (const key in nextProps) {
    setProperty(node, key, props[key], nextProps[key], isSvg, handlers);
  }
}
function setProperty(node, key, prevValue, nextValue, isSvg, handlers) {
  key = key == "class" && !isSvg ? "className" : key;
  prevValue = prevValue == null ? null : prevValue;
  nextValue = nextValue == null ? null : nextValue;
  if (key in node && VAL_FROM_PROPS[key]) {
    prevValue = node[key];
  }
  if (nextValue === prevValue || INTERNAL_PROPS[key] || key[0] == "_") return;
  if (node.localName === "slot" && key === "assignNode" && "assign" in node) {
    node.assign(nextValue);
  } else if (key[0] == "o" && key[1] == "n" && (isFunction(nextValue) || isFunction(prevValue))) {
    setEvent(node, key.slice(2), nextValue, handlers);
  } else if (key == "ref") {
    if (nextValue) {
      if (isFunction(nextValue)) {
        nextValue(node);
      } else {
        nextValue.current = node;
      }
    }
  } else if (key == "style") {
    const { style } = node;
    prevValue = prevValue || "";
    nextValue = nextValue || "";
    const prevIsObject = isObject(prevValue);
    const nextIsObject = isObject(nextValue);
    if (prevIsObject) {
      for (const key2 in prevValue) {
        if (nextIsObject) {
          !(key2 in nextValue) && setPropertyStyle(style, key2, null);
        } else {
          break;
        }
      }
    }
    if (nextIsObject) {
      for (const key2 in nextValue) {
        const value = nextValue[key2];
        if (prevIsObject && prevValue[key2] === value) continue;
        setPropertyStyle(style, key2, value);
      }
    } else {
      style.cssText = nextValue;
    }
  } else {
    const attr = key[0] == "$" ? key.slice(1) : key;
    if (attr === key && (!isSvg && !PROPS_AS_ATTRS[key] && key in node || isFunction(nextValue) || isFunction(prevValue))) {
      node[key] = nextValue == null ? "" : nextValue;
    } else if (nextValue == null) {
      node.removeAttribute(attr);
    } else {
      node.setAttribute(
        attr,
        isObject(nextValue) ? JSON.stringify(nextValue) : nextValue
      );
    }
  }
}
function setEvent(node, type, nextHandler, handlers) {
  if (!handlers.handleEvent) {
    handlers.handleEvent = (event) => handlers[event.type].call(node, event);
  }
  if (nextHandler) {
    if (!handlers[type]) {
      const options2 = nextHandler.capture || nextHandler.once || nextHandler.passive ? Object.assign({}, nextHandler) : null;
      node.addEventListener(type, handlers, options2);
    }
    handlers[type] = nextHandler;
  } else {
    if (handlers[type]) {
      node.removeEventListener(type, handlers);
      delete handlers[type];
    }
  }
}
function setPropertyStyle(style, key, value) {
  let method = "setProperty";
  if (value == null) {
    method = "removeProperty";
    value = null;
  }
  if (~key.indexOf("-")) {
    style[method](key, value);
  } else {
    style[key] = value;
  }
}

// node_modules/atomico/src/context.js
var CONTEXT_TEMPLATE = h("host", { style: "display: contents" });
var CONTEXT_VALUE = "value";
var useProvider = (id, value) => {
  const host = useHost();
  const ref = useRef();
  useInsertionEffect(
    () => addListener(
      host.current,
      "ConnectContext",
      /**
       * @param {CustomEvent<import("context").DetailConnectContext>} event
       */
      (event) => {
        const target = event.composedPath().at(0);
        if (target !== event.currentTarget && id === event.detail.id) {
          event.stopPropagation();
          event.detail.connect(ref);
        }
      }
    ),
    [id]
  );
  ref.current = value;
};
var createContext = (value) => {
  const Context = c(
    ({ value: value2 }) => {
      useProvider(Context, value2);
      return CONTEXT_TEMPLATE;
    },
    {
      props: {
        value: {
          type: Object,
          value: () => value
        }
      }
    }
  );
  Context[CONTEXT_VALUE] = value;
  return Context;
};

// node_modules/atomico/src/hooks/custom-hooks/use-suspense.js
var SuspenseContext = createContext({
  /**
   *
   * @param {string} type
   * @param {string} id
   */
  dispatch(type, id) {
  }
});

// node_modules/atomico/html.js
var MODE_SLASH = 0;
var MODE_TEXT = 1;
var MODE_WHITESPACE = 2;
var MODE_TAGNAME = 3;
var MODE_COMMENT = 4;
var MODE_PROP_SET = 5;
var MODE_PROP_APPEND = 6;
var CHILD_APPEND = 0;
var CHILD_RECURSE = 2;
var TAG_SET = 3;
var PROPS_ASSIGN = 4;
var PROP_SET = MODE_PROP_SET;
var PROP_APPEND = MODE_PROP_APPEND;
var evaluate = (h2, built, fields, args) => {
  let tmp;
  built[0] = 0;
  for (let i = 1; i < built.length; i++) {
    const type = built[i++];
    const value = built[i] ? (built[0] |= type ? 1 : 2, fields[built[i++]]) : built[++i];
    if (type === TAG_SET) {
      args[0] = value;
    } else if (type === PROPS_ASSIGN) {
      args[1] = Object.assign(args[1] || {}, value);
    } else if (type === PROP_SET) {
      (args[1] = args[1] || {})[built[++i]] = value;
    } else if (type === PROP_APPEND) {
      args[1][built[++i]] += value + "";
    } else if (type) {
      tmp = h2.apply(value, evaluate(h2, value, fields, ["", null]));
      args.push(tmp);
      if (value[0]) {
        built[0] |= 2;
      } else {
        built[i - 2] = CHILD_APPEND;
        built[i] = tmp;
      }
    } else {
      args.push(value);
    }
  }
  return args;
};
var build = function(statics) {
  let mode = MODE_TEXT;
  let buffer = "";
  let quote = "";
  let current = [0];
  let char, propName;
  const commit = (field) => {
    if (mode === MODE_TEXT && (field || (buffer = buffer.replace(/^\s*\n\s*|\s*\n\s*$/g, "")))) {
      {
        current.push(CHILD_APPEND, field, buffer);
      }
    } else if (mode === MODE_TAGNAME && (field || buffer)) {
      {
        current.push(TAG_SET, field, buffer);
      }
      mode = MODE_WHITESPACE;
    } else if (mode === MODE_WHITESPACE && buffer === "..." && field) {
      {
        current.push(PROPS_ASSIGN, field, 0);
      }
    } else if (mode === MODE_WHITESPACE && buffer && !field) {
      {
        current.push(PROP_SET, 0, true, buffer);
      }
    } else if (mode >= MODE_PROP_SET) {
      {
        if (buffer || !field && mode === MODE_PROP_SET) {
          current.push(mode, 0, buffer, propName);
          mode = MODE_PROP_APPEND;
        }
        if (field) {
          current.push(mode, field, 0, propName);
          mode = MODE_PROP_APPEND;
        }
      }
    }
    buffer = "";
  };
  for (let i = 0; i < statics.length; i++) {
    if (i) {
      if (mode === MODE_TEXT) {
        commit();
      }
      commit(i);
    }
    for (let j = 0; j < statics[i].length; j++) {
      char = statics[i][j];
      if (mode === MODE_TEXT) {
        if (char === "<") {
          commit();
          {
            current = [current];
          }
          mode = MODE_TAGNAME;
        } else {
          buffer += char;
        }
      } else if (mode === MODE_COMMENT) {
        if (buffer === "--" && char === ">") {
          mode = MODE_TEXT;
          buffer = "";
        } else {
          buffer = char + buffer[0];
        }
      } else if (quote) {
        if (char === quote) {
          quote = "";
        } else {
          buffer += char;
        }
      } else if (char === '"' || char === "'") {
        quote = char;
      } else if (char === ">") {
        commit();
        mode = MODE_TEXT;
      } else if (!mode) ;
      else if (char === "=") {
        mode = MODE_PROP_SET;
        propName = buffer;
        buffer = "";
      } else if (char === "/" && (mode < MODE_PROP_SET || statics[i][j + 1] === ">")) {
        commit();
        if (mode === MODE_TAGNAME) {
          current = current[0];
        }
        mode = current;
        {
          (current = current[0]).push(CHILD_RECURSE, 0, mode);
        }
        mode = MODE_SLASH;
      } else if (char === " " || char === "	" || char === "\n" || char === "\r") {
        commit();
        mode = MODE_WHITESPACE;
      } else {
        buffer += char;
      }
      if (mode === MODE_TAGNAME && buffer === "!--") {
        mode = MODE_COMMENT;
        current = current[0];
      }
    }
  }
  commit();
  return current;
};
var CACHE = /* @__PURE__ */ new Map();
function html(statics) {
  let tmp = CACHE;
  tmp = evaluate(
    h,
    tmp.get(statics) || (tmp.set(statics, tmp = build(statics)), tmp),
    arguments,
    []
  );
  return tmp.length > 1 ? tmp : tmp[0];
}

export {
  useRef,
  useHost,
  c,
  useLayoutEffect,
  useEffect,
  useState,
  useMemo,
  h,
  html
};
//# sourceMappingURL=chunk-6V3WYRAC.js.map

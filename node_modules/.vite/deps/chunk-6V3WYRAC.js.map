{
  "version": 3,
  "sources": ["../../atomico/src/ref.js", "../../atomico/src/hooks/create-hooks.js", "../../atomico/src/utils.js", "../../atomico/src/element/errors.js", "../../atomico/src/element/set-prototype.js", "../../atomico/src/element/custom-element.js", "../../atomico/src/hooks/use-effect.js", "../../atomico/src/hooks/state.js", "../../atomico/src/hooks/hooks.js", "../../atomico/src/options.js", "../../atomico/src/loaded.js", "../../atomico/src/render.js", "../../atomico/src/context.js", "../../atomico/src/hooks/custom-hooks/use-suspense.js", "../../atomico/html.js"],
  "sourcesContent": ["/**\r\n * @template {any} T\r\n */\r\nexport class Ref {\r\n    /**\r\n     * @type {T}\r\n     */\r\n    #current;\r\n    #listeners = new Set();\r\n    /**\r\n     * @param {T} current\r\n     */\r\n    constructor(current) {\r\n        this.#current = current;\r\n    }\r\n    /**\r\n     * @return {T}\r\n     */\r\n    get current() {\r\n        return this.#current;\r\n    }\r\n    /**\r\n     * @param {T} value\r\n     */\r\n    set current(value) {\r\n        if (this.#current != value) {\r\n            this.#current = value;\r\n            this.#listeners.forEach((fn) => fn(value));\r\n        }\r\n    }\r\n    /**\r\n     * @type {import(\"hooks\").Ref[\"on\"]}\r\n     */\r\n    on(fn) {\r\n        this.#listeners.add(fn);\r\n        return () => this.#listeners.delete(fn);\r\n    }\r\n}\r\n\r\n/**\r\n * @template {any} Value\r\n * @param {Value} [value]\r\n * @returns {import(\"hooks\").Ref}\r\n */\r\nexport const createRef = (value) => new Ref(value);\r\n", "import { createRef } from \"../ref.js\";\r\n\r\nconst ID = Symbol.for(\"atomico.hooks\");\r\n\r\n// previene la perdida de hook concurrente al duplicar el modulo\r\n// This usually happens on Deno and Webpack\r\nglobalThis[ID] = globalThis[ID] || {};\r\n/**\r\n * @type {{c:import(\"internal/hooks.js\").SCOPE}}\r\n */\r\nlet SCOPE = globalThis[ID];\r\n\r\n/**\r\n * Error id to escape execution of hooks.load\r\n */\r\nexport const IdSuspense = Symbol.for(\"Atomico.suspense\");\r\n\r\n/**\r\n * tag to identify the useEffect\r\n */\r\nexport const IdEffect = Symbol.for(\"Atomico.effect\");\r\n\r\n/**\r\n * tag to identify the useLayoutEffect\r\n */\r\nexport const IdLayoutEffect = Symbol.for(\"Atomico.layoutEffect\");\r\n\r\n/**\r\n * tag to identify the useInsertionEffect\r\n */\r\nexport const IdInsertionEffect = Symbol.for(\"Atomico.insertionEffect\");\r\n\r\n/**\r\n * @type {import(\"core\").UseHook}\r\n */\r\nexport const useHook = (render, effect, tag) => {\r\n    const { i, hooks } = SCOPE.c;\r\n\r\n    const hook = (hooks[i] = hooks[i] || {});\r\n\r\n    hook.value = render(hook.value);\r\n    hook.effect = effect;\r\n    hook.tag = tag;\r\n\r\n    SCOPE.c.i++;\r\n\r\n    return hooks[i].value;\r\n};\r\n\r\n/**\r\n * @type {import(\"core\").UseRef}\r\n */\r\nexport const useRef = (current) => useHook((ref = createRef(current)) => ref);\r\n\r\n/**\r\n * return the global host of the scope\r\n * @type {import(\"core\").UseHost}\r\n */\r\nexport const useHost = () => useHook((ref = createRef(SCOPE.c.host)) => ref);\r\n\r\n/**\r\n * hook that retrieves the render to restart the loop\r\n * @type {import(\"core\").UseUpdate}\r\n */\r\nexport const useUpdate = () => SCOPE.c.update;\r\n\r\n/**\r\n * @type {import(\"core\").UseId}\r\n */\r\nexport const useId = () => useHook(() => SCOPE.c.id + \"-\" + SCOPE.c.i);\r\n\r\n/**\r\n * @type {import(\"internal/hooks.js\").CreateHooks}\r\n */\r\nexport const createHooks = (update, host, id = 0) => {\r\n    /**\r\n     * @type {import(\"internal/hooks.js\").Hooks}\r\n     **/\r\n    let hooks = {};\r\n    let suspense = false;\r\n\r\n    const isSuspense = () => suspense;\r\n    /**\r\n     * announces that the updates have finished allowing the\r\n     * execution of the collectors\r\n     * @param {import(\"internal/hooks.js\").Hook[\"tag\"]} tag\r\n     * @param {boolean} [unmounted]\r\n     */\r\n    const cleanEffectsByType = (tag, unmounted) => {\r\n        for (const index in hooks) {\r\n            const hook = hooks[index];\r\n            if (hook.effect && hook.tag === tag) {\r\n                hook.value = hook.effect(hook.value, unmounted);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * @type {import(\"internal/hooks.js\").Load}\r\n     */\r\n    const load = (callback) => {\r\n        SCOPE.c = { host, hooks, update, i: 0, id };\r\n        let value;\r\n        try {\r\n            suspense = false;\r\n            value = callback();\r\n        } catch (e) {\r\n            if (e !== IdSuspense) throw e;\r\n            suspense = true;\r\n        } finally {\r\n            SCOPE.c = null;\r\n        }\r\n        return value;\r\n    };\r\n    /**\r\n     * @type {import(\"internal/hooks.js\").CleanEffects}\r\n     */\r\n    const cleanEffects = (unmounted) => {\r\n        cleanEffectsByType(IdInsertionEffect, unmounted);\r\n        return () => {\r\n            cleanEffectsByType(IdLayoutEffect, unmounted);\r\n            return () => {\r\n                cleanEffectsByType(IdEffect, unmounted);\r\n                /**\r\n                 * currently the state of the props is preserved\r\n                 * at the node level, if the node is deleted the\r\n                 * state of the props persists so the state of\r\n                 *  the DOM must also persist\r\n                 */\r\n                // if (unmounted) hooks = {};\r\n            };\r\n        };\r\n    };\r\n\r\n    return { load, cleanEffects, isSuspense };\r\n};\r\n", "export const SymbolFor = Symbol.for;\r\n\r\n/**\r\n * compare 2 array\r\n * ```js\r\n * isEqualArray([1,2,3,4],[1,2,3,4]) // true\r\n * isEqualArray([1,2,3,4],[1,2,3])   // false\r\n * isEqualArray([5,1,2,3],[1,2,3,5]) // false\r\n * isEqualArray([],[]) // true\r\n * ```\r\n * @param {any[]} before\r\n * @param {any[]} after\r\n * @returns {boolean}\r\n */\r\nexport function isEqualArray(before, after) {\r\n    const length = before.length;\r\n    if (length !== after.length) return false;\r\n    for (let i = 0; i < length; i++) {\r\n        let beforeValue = before[i];\r\n        let afterValue = after[i];\r\n        if (beforeValue !== afterValue) return false;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Determine if the value is considered a function\r\n * @type {import(\"internal/utils.js\").IsFunction}\r\n */\r\nexport const isFunction = (value) => typeof value == \"function\";\r\n\r\n/**\r\n * Determines if the value is considered an object\r\n * @param {any} value\r\n */\r\nexport const isObject = (value) => typeof value == \"object\";\r\n\r\nexport const { isArray } = Array;\r\n\r\n/**\r\n *\r\n * @param {Element & {dataset?:object}} node\r\n * @param {boolean} [styleOnly] - limits the hydration of the lists only to the tagStyle\r\n * @returns\r\n */\r\nexport const isHydrate = (node, styleOnly) =>\r\n    (styleOnly ? node instanceof HTMLStyleElement : true) &&\r\n    \"hydrate\" in (node?.dataset || {});\r\n\r\n/**\r\n * @template {any[]} T\r\n * @param {T} list\r\n * @param {(value:T[0])=>void} callback\r\n */\r\nexport function flat(list, callback) {\r\n    let last;\r\n    /**\r\n     * @param {any[]} list\r\n     */\r\n    const reduce = (list) => {\r\n        let { length } = list;\r\n        for (let i = 0; i < length; i++) {\r\n            const value = list[i];\r\n            if (value && Array.isArray(value)) {\r\n                reduce(value);\r\n            } else {\r\n                const type = typeof value;\r\n                if (\r\n                    value == null ||\r\n                    type === \"function\" ||\r\n                    type === \"boolean\"\r\n                ) {\r\n                    continue;\r\n                } else if (type === \"string\" || type === \"number\") {\r\n                    if (last == null) last = \"\";\r\n                    last += value;\r\n                } else {\r\n                    if (last != null) {\r\n                        callback(last);\r\n                        last = null;\r\n                    }\r\n                    callback(value);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    reduce(list);\r\n\r\n    if (last != null) callback(last);\r\n}\r\n\r\n/**\r\n * @param {any} target\r\n * @param {string} type\r\n * @param {(event:Event)=>void} handler\r\n */\r\nexport const addListener = (target, type, handler) => {\r\n    target.addEventListener(type, handler);\r\n    return () => target.removeEventListener(type, handler);\r\n};\r\n", "export class Error {\r\n    /**\r\n     *\r\n     * @param {HTMLElement} target\r\n     * @param {string} message\r\n     * @param {string} value\r\n     */\r\n    constructor(target, message, value) {\r\n        this.message = message;\r\n        this.target = target;\r\n        this.value = value;\r\n    }\r\n}\r\n\r\nexport class PropError extends Error {}\r\n\r\nexport class ParseError extends Error {}\r\n", "import { isFunction, isObject } from \"../utils.js\";\r\nimport { PropError } from \"./errors.js\";\r\n\r\nexport const CUSTOM_TYPE_NAME = \"Custom\";\r\n/**\r\n * The Any type avoids the validation of prop types\r\n * @type {null}\r\n **/\r\nexport const Any = null;\r\n\r\n/**\r\n * Attributes considered as valid boleanos\r\n **/\r\nconst TRUE_VALUES = { true: 1, \"\": 1, 1: 1 };\r\n\r\n/**\r\n * Constructs the setter and getter of the associated property\r\n * only if it is not defined in the prototype\r\n * @param {Object} prototype - CustomElement prototype\r\n * @param {string} prop - Name of the reactive property to associate with the customElement\r\n * @param {any} schema - Structure to be evaluated for the definition of the property\r\n * @param {Attrs} attrs - Dictionary of attributes to properties\r\n * @param {Values} values - Values to initialize the customElements\r\n */\r\nexport function setPrototype(prototype, prop, schema, attrs, values) {\r\n    /**@type {Schema} */\r\n    const {\r\n        type,\r\n        reflect,\r\n        event,\r\n        value: defaultValue,\r\n        attr = getAttr(prop)\r\n    } = schema?.name != CUSTOM_TYPE_NAME && isObject(schema) && schema != Any\r\n        ? schema\r\n        : { type: schema };\r\n\r\n    const isCustomType = type?.name === CUSTOM_TYPE_NAME && type.map;\r\n\r\n    const withDefaultValue =\r\n        defaultValue != null\r\n            ? type == Function || !isFunction(defaultValue)\r\n                ? () => defaultValue\r\n                : defaultValue\r\n            : null;\r\n\r\n    Object.defineProperty(prototype, prop, {\r\n        configurable: true,\r\n        /**\r\n         * @this {import(\"dom\").AtomicoThisInternal}\r\n         * @param {any} newValue\r\n         */\r\n        set(newValue) {\r\n            const oldValue = this[prop];\r\n\r\n            if (withDefaultValue && type != Boolean && newValue == null) {\r\n                newValue = withDefaultValue();\r\n            }\r\n\r\n            const { error, value } = (isCustomType ? mapValue : filterValue)(\r\n                type,\r\n                newValue\r\n            );\r\n\r\n            if (error && value != null) {\r\n                throw new PropError(\r\n                    this,\r\n                    `The value defined for prop '${prop}' must be of type '${type.name}'`,\r\n                    value\r\n                );\r\n            }\r\n\r\n            if (oldValue == value) return;\r\n\r\n            this._props[prop] = value == null ? undefined : value;\r\n\r\n            this.update();\r\n            /**\r\n             * 1.7.0 >, this position reduces the amount of updates to the DOM and render\r\n             */\r\n            event && dispatchEvent(this, event);\r\n            /**\r\n             * attribute mirroring must occur if component is mounted\r\n             */\r\n            this.updated.then(() => {\r\n                if (reflect) {\r\n                    this._ignoreAttr = attr;\r\n                    reflectValue(this, type, attr, this[prop]);\r\n                    this._ignoreAttr = null;\r\n                }\r\n            });\r\n        },\r\n        /**\r\n         * @this {import(\"dom\").AtomicoThisInternal}\r\n         */\r\n        get() {\r\n            return this._props[prop];\r\n        }\r\n    });\r\n\r\n    if (withDefaultValue) values[prop] = withDefaultValue();\r\n\r\n    attrs[attr] = { prop, type };\r\n}\r\n\r\n/**\r\n * Dispatch an event\r\n * @param {Element} node - DOM node to dispatch the event\r\n * @param {InternalEvent & InternalEventInit} event - Event to dispatch on node\r\n */\r\nexport const dispatchEvent = (\r\n    node,\r\n    { type, base = CustomEvent, ...eventInit }\r\n) => node.dispatchEvent(new base(type, eventInit));\r\n\r\n/**\r\n * Transform a Camel Case string to a Kebab case\r\n * @param {string} prop - string to apply the format\r\n * @returns {string}\r\n */\r\nexport const getAttr = (prop) => prop.replace(/([A-Z])/g, \"-$1\").toLowerCase();\r\n\r\n/**\r\n * reflects an attribute value of the given element as context\r\n * @param {Element} host\r\n * @param {any} type\r\n * @param {string} attr\r\n * @param {any} value\r\n */\r\nexport const reflectValue = (host, type, attr, value) =>\r\n    value == null || (type == Boolean && !value)\r\n        ? host.removeAttribute(attr)\r\n        : host.setAttribute(\r\n              attr,\r\n              type?.name === CUSTOM_TYPE_NAME && type?.serialize\r\n                  ? type?.serialize(value)\r\n                  : isObject(value)\r\n                    ? JSON.stringify(value)\r\n                    : type == Boolean\r\n                      ? \"\"\r\n                      : value\r\n          );\r\n\r\n/**\r\n * transform a string to a value according to its type\r\n * @param {any} type\r\n * @param {string} value\r\n * @returns {any}\r\n */\r\nexport const transformValue = (type, value) =>\r\n    type == Boolean\r\n        ? !!TRUE_VALUES[value]\r\n        : type == Number\r\n          ? Number(value)\r\n          : type == String\r\n            ? value\r\n            : type == Array || type == Object\r\n              ? JSON.parse(value)\r\n              : type.name == CUSTOM_TYPE_NAME\r\n                ? value\r\n                : // TODO: If when defining reflect the prop can also be of type string?\r\n                  new type(value);\r\n\r\n/**\r\n *\r\n * @param {import(\"schema\").TypeCustom<(...args:any)=>any>} TypeCustom\r\n * @param {*} value\r\n * @returns\r\n */\r\nexport const mapValue = ({ map }, value) => {\r\n    try {\r\n        return { value: map(value), error: false };\r\n    } catch {\r\n        return { value, error: true };\r\n    }\r\n};\r\n/**\r\n * Filter the values based on their type\r\n * @param {any} type\r\n * @param {any} value\r\n * @returns {{error?:boolean,value:any}}\r\n */\r\nexport const filterValue = (type, value) =>\r\n    type == null || value == null\r\n        ? { value, error: false }\r\n        : type != String && value === \"\"\r\n          ? { value: undefined, error: false }\r\n          : type == Object || type == Array || type == Symbol\r\n            ? {\r\n                  value,\r\n                  error: {}.toString.call(value) !== `[object ${type.name}]`\r\n              }\r\n            : value instanceof type\r\n              ? {\r\n                    value,\r\n                    error: type == Number && Number.isNaN(value.valueOf())\r\n                }\r\n              : type == String || type == Number || type == Boolean\r\n                ? {\r\n                      value,\r\n                      error:\r\n                          type == Number\r\n                              ? typeof value != \"number\"\r\n                                  ? true\r\n                                  : Number.isNaN(value)\r\n                              : type == String\r\n                                ? typeof value != \"string\"\r\n                                : typeof value != \"boolean\"\r\n                  }\r\n                : { value, error: true };\r\n\r\n/**\r\n * @param {(...args:any[])=>any} map\r\n * @param {(...args:any[])=>any} [serialize]\r\n * @returns {import(\"schema\").TypeCustom<(...args:any)=>any>}\r\n */\r\nexport const createType = (map, serialize) => ({\r\n    name: CUSTOM_TYPE_NAME,\r\n    map,\r\n    serialize\r\n});\r\n/**\r\n * Type any, used to avoid type validation.\r\n * @typedef {null} Any\r\n */\r\n\r\n/**\r\n * @typedef {Object} InternalEventInit\r\n * @property {typeof CustomEvent|typeof Event} [base] - Optional constructor to initialize the event\r\n * @property {boolean} [bubbles] - indicating whether the event bubbles. The default is false.\r\n * @property {boolean} [cancelable] - indicating whether the event will trigger listeners outside of a shadow root.\r\n * @property {boolean} [composed] - indicating whether the event will trigger listeners outside of a shadow root.\r\n * @property {any} [detail] - indicating whether the event will trigger listeners outside of a shadow root.\r\n */\r\n\r\n/**\r\n * Interface used by dispatchEvent to automate event firing\r\n * @typedef {Object} InternalEvent\r\n * @property {string} type - type of event to dispatch.\r\n */\r\n\r\n/**\r\n * @typedef {Object<string, {prop:string,type:Function}>} Attrs\r\n */\r\n\r\n/**\r\n * @typedef {Object<string, any>} Values\r\n */\r\n\r\n/**\r\n * @typedef {Object} Schema\r\n * @property {any} [type] - data type to be worked as property and attribute\r\n * @property {string} [attr] - allows customizing the name as an attribute by skipping the camelCase format\r\n * @property {boolean} [reflect] - reflects property as attribute of node\r\n * @property {InternalEvent & InternalEventInit} [event] - Allows to emit an event every time the property changes\r\n * @property {any} [value] - defines a default value when instantiating the component\r\n */\r\n", "import { createHooks } from \"../hooks/create-hooks.js\";\r\nimport { flat, isHydrate } from \"../utils.js\";\r\nimport { ParseError } from \"./errors.js\";\r\nimport { setPrototype, transformValue } from \"./set-prototype.js\";\r\nexport { Any, createType } from \"./set-prototype.js\";\r\n\r\nlet ID = 0;\r\n/**\r\n *\r\n * @param {Element & {dataset?:object}} node\r\n * @returns {string|number}\r\n */\r\nconst getHydrateId = (node) => {\r\n    const id = (node?.dataset || {})?.hydrate || \"\";\r\n    if (id) {\r\n        return id;\r\n    } else {\r\n        return \"c\" + ID++;\r\n    }\r\n};\r\n\r\n/**\r\n * @param {import(\"component\").Component} component\r\n * @param {CustomElementConstructor| import(\"component\").ComponentOptions} [options]\r\n */\r\nexport const c = (component, options = HTMLElement) => {\r\n    /**\r\n     * @type {import(\"./set-prototype.js\").Attrs}\r\n     */\r\n    const attrs = {};\r\n    /**\r\n     * @type {import(\"./set-prototype.js\").Values}\r\n     */\r\n    const values = {};\r\n\r\n    const withBase =\r\n        \"prototype\" in options && options.prototype instanceof Element;\r\n\r\n    const base = withBase\r\n        ? options\r\n        : \"base\" in options\r\n          ? options.base\r\n          : HTMLElement;\r\n\r\n    //@ts-ignore\r\n    const { props, styles } = withBase ? component : options;\r\n\r\n    /**\r\n     * @todo Discover a more aesthetic solution at the type level\r\n     * TS tries to set local class rules, these should be ignored\r\n     */\r\n    class AtomicoElement extends base {\r\n        constructor() {\r\n            super();\r\n            this._setup();\r\n            this._render = () => component({ ...this._props });\r\n            for (const prop in values) this[prop] = values[prop];\r\n        }\r\n        /**\r\n         * @returns {import(\"core\").Sheets[]}\r\n         */\r\n        static get styles() {\r\n            //@ts-ignore\r\n            return [super.styles, styles];\r\n        }\r\n        async _setup() {\r\n            // _setup only continues if _props has not been defined\r\n            if (this._props) return;\r\n\r\n            this._props = {};\r\n\r\n            /**\r\n             * @type {Node}\r\n             */\r\n            let mountParentNode;\r\n            /**\r\n             * @type {Node}\r\n             */\r\n            let unmountParentNode;\r\n\r\n            this.mounted = new Promise(\r\n                (resolve) =>\r\n                    (this.mount = () => {\r\n                        resolve();\r\n                        /**\r\n                         * You should always wait if the node has previously been dismounted before mounting to avoid:\r\n                         * 1. Deleting the rendered content by mistake enerated a cleanup effect.\r\n                         * 2. allow a deletion and new inclusion recycling of the node\r\n                         */\r\n                        if (mountParentNode != this.parentNode) {\r\n                            if (unmountParentNode != mountParentNode) {\r\n                                this.unmounted.then(this.update);\r\n                            } else {\r\n                                this.update();\r\n                            }\r\n                        }\r\n                        mountParentNode = this.parentNode;\r\n                    })\r\n            );\r\n\r\n            this.unmounted = new Promise(\r\n                (resolve) =>\r\n                    (this.unmount = () => {\r\n                        resolve();\r\n                        if (\r\n                            mountParentNode != this.parentNode ||\r\n                            !this.isConnected\r\n                        ) {\r\n                            hooks.cleanEffects(true)()();\r\n                            unmountParentNode = this.parentNode;\r\n                            mountParentNode = null;\r\n                        }\r\n                    })\r\n            );\r\n\r\n            this.symbolId = this.symbolId || Symbol();\r\n            this.symbolIdParent = Symbol();\r\n\r\n            const hooks = createHooks(\r\n                () => this.update(),\r\n                this,\r\n                getHydrateId(this)\r\n            );\r\n\r\n            let prevent;\r\n\r\n            let firstRender = true;\r\n\r\n            // some DOM emulators don't define dataset\r\n            const hydrate = isHydrate(this);\r\n\r\n            this.update = () => {\r\n                if (!prevent) {\r\n                    prevent = true;\r\n\r\n                    /**\r\n                     * this.updated is defined at the runtime of the render,\r\n                     * if it fails it is caught by mistake to unlock prevent\r\n                     */\r\n                    this.updated = (this.updated || this.mounted)\r\n                        .then(() => {\r\n                            try {\r\n                                const result = hooks.load(this._render);\r\n\r\n                                const cleanUseLayoutEffects =\r\n                                    hooks.cleanEffects();\r\n                                result &&\r\n                                    //@ts-ignore\r\n                                    result.render(this, this.symbolId, hydrate);\r\n\r\n                                prevent = false;\r\n\r\n                                if (firstRender && !hooks.isSuspense()) {\r\n                                    firstRender = false;\r\n                                    // @ts-ignore\r\n                                    !hydrate && applyStyles(this);\r\n                                }\r\n\r\n                                return cleanUseLayoutEffects();\r\n                            } finally {\r\n                                // Remove lock in case of synchronous error\r\n                                prevent = false;\r\n                            }\r\n                        })\r\n                        .then(\r\n                            /**\r\n                             * @param {import(\"internal/hooks.js\").CleanUseEffects} [cleanUseEffect]\r\n                             */\r\n                            (cleanUseEffect) => {\r\n                                cleanUseEffect && cleanUseEffect();\r\n                            }\r\n                        );\r\n                }\r\n\r\n                return this.updated;\r\n            };\r\n\r\n            this.update();\r\n        }\r\n        connectedCallback() {\r\n            this.mount();\r\n            //@ts-ignore\r\n            super.connectedCallback && super.connectedCallback();\r\n        }\r\n        disconnectedCallback() {\r\n            //@ts-ignore\r\n            super.disconnectedCallback && super.disconnectedCallback();\r\n            // The webcomponent will only resolve disconnected if it is\r\n            // actually disconnected of the document, otherwise it will keep the record.\r\n            this.unmount();\r\n        }\r\n        /**\r\n         * @this {import(\"dom\").AtomicoThisInternal}\r\n         * @param {string} attr\r\n         * @param {(string|null)} oldValue\r\n         * @param {(string|null)} value\r\n         */\r\n        attributeChangedCallback(attr, oldValue, value) {\r\n            if (attrs[attr]) {\r\n                // _ignoreAttr exists temporarily\r\n                // @ts-ignore\r\n                if (attr === this._ignoreAttr || oldValue === value) return;\r\n                // Choose the property name to send the update\r\n                const { prop, type } = attrs[attr];\r\n                // The following error cannot be caught\r\n                try {\r\n                    this[prop] = transformValue(type, value);\r\n                } catch (e) {\r\n                    throw new ParseError(\r\n                        this,\r\n                        `The value defined as attr '${attr}' cannot be parsed by type '${type.name}'`,\r\n                        value\r\n                    );\r\n                }\r\n            } else {\r\n                // If the attribute does not exist in the scope attrs, the event is sent to super\r\n                // @ts-ignore\r\n                super.attributeChangedCallback(attr, oldValue, value);\r\n            }\r\n        }\r\n\r\n        static get props() {\r\n            //@ts-ignore\r\n            return { ...super.props, ...props };\r\n        }\r\n\r\n        static get observedAttributes() {\r\n            // See if there is an observedAttributes declaration to match with the current one\r\n            // @ts-ignore\r\n            const superAttrs = super.observedAttributes || [];\r\n            for (const prop in props) {\r\n                setPrototype(this.prototype, prop, props[prop], attrs, values);\r\n            }\r\n            return Object.keys(attrs).concat(superAttrs);\r\n        }\r\n    }\r\n\r\n    return AtomicoElement;\r\n};\r\n\r\n/**\r\n * Attach the css to the shadowDom\r\n * @param {import(\"dom\").AtomicoThisInternal} host\r\n */\r\nfunction applyStyles(host) {\r\n    const { styles } = host.constructor;\r\n    const { shadowRoot } = host;\r\n    if (shadowRoot && styles.length) {\r\n        /**\r\n         * @type {CSSStyleSheet[]}\r\n         */\r\n        const sheets = [];\r\n        flat(styles, (value) => {\r\n            if (value) {\r\n                if (value instanceof Element) {\r\n                    shadowRoot.appendChild(value.cloneNode(true));\r\n                } else {\r\n                    sheets.push(value);\r\n                }\r\n            }\r\n        });\r\n        if (sheets.length) shadowRoot.adoptedStyleSheets = sheets;\r\n    }\r\n}\r\n", "import {\r\n    useHook,\r\n    IdLayoutEffect,\r\n    IdEffect,\r\n    IdInsertionEffect\r\n} from \"./create-hooks.js\";\r\nimport { isEqualArray, isFunction } from \"../utils.js\";\r\n\r\n/**\r\n * useLayoutEffect and useEffect have a similar algorithm\r\n * in that the position of the callback varies.\r\n * @param {IdLayoutEffect|IdEffect|IdInsertionEffect} type\r\n * @return {import(\"internal/hooks.js\").UseAnyEffect}\r\n */\r\nconst createEffect = (type) => (currentEffect, currentArgs) => {\r\n    useHook(\r\n        /**\r\n         * Clean the effect hook\r\n         * @type {import(\"internal/hooks.js\").CollectorEffect}\r\n         */\r\n\r\n        ([collector, args] = []) => {\r\n            if (args || !args) {\r\n                if (args && isEqualArray(args, currentArgs)) {\r\n                    collector = collector || true;\r\n                } else {\r\n                    // TS does not infer the following conditional\r\n                    // @ts-ignore\r\n                    isFunction(collector) && collector();\r\n                    collector = null;\r\n                }\r\n            }\r\n            return [collector, currentArgs];\r\n        },\r\n        /**\r\n         * @returns {any}\r\n         */\r\n        ([collector, args], unmounted) => {\r\n            if (unmounted) {\r\n                // ts does not infer the following conditional\r\n                isFunction(collector) && collector();\r\n                return [];\r\n            } else {\r\n                return [collector ? collector : currentEffect(), args];\r\n            }\r\n        },\r\n        type\r\n    );\r\n};\r\n\r\nexport const useLayoutEffect = createEffect(IdLayoutEffect);\r\n\r\nexport const useEffect = createEffect(IdEffect);\r\n\r\nexport const useInsertionEffect = createEffect(IdInsertionEffect);\r\n", "export class State extends Array {\r\n    /**\r\n     *\r\n     * @param {any} initialState\r\n     * @param {(nextState: any, state:any[], mount: boolean )=>void} mapState\r\n     */\r\n    constructor(initialState, mapState) {\r\n        let mount = true;\r\n        /**\r\n         *\r\n         * @param {any} nextState\r\n         */\r\n        const setState = (nextState) => {\r\n            try {\r\n                mapState(nextState, this, mount);\r\n            } finally {\r\n                mount = false;\r\n            }\r\n        };\r\n        super(undefined, setState, mapState);\r\n        setState(initialState);\r\n    }\r\n    /**\r\n     * The following code allows a mutable approach to useState\r\n     * and useProp this with the idea of allowing an alternative\r\n     * approach similar to Vue or Qwik of state management\r\n     * @todo pending review with the community\r\n     */\r\n    // get value() {\r\n    //     return this[0];\r\n    // }\r\n    // set value(nextState) {\r\n    //     this[2](nextState, this);\r\n    // }\r\n}\r\n", "import { useHook, useUpdate } from \"./create-hooks.js\";\r\n\r\nimport { isEqualArray, isFunction } from \"../utils.js\";\r\n\r\nexport * from \"./use-effect.js\";\r\nimport { State } from \"./state.js\";\r\n\r\n/**\r\n * Create a persistent local state\r\n * @type {import(\"core\").UseState}\r\n */\r\nexport const useState = (initialState) => {\r\n    // retrieve the render to request an update\r\n    const update = useUpdate();\r\n    return useHook(\r\n        (\r\n            state = new State(initialState, (nextState, state, mount) => {\r\n                nextState = isFunction(nextState)\r\n                    ? nextState(state[0])\r\n                    : nextState;\r\n                if (nextState !== state[0]) {\r\n                    state[0] = nextState;\r\n                    // Escape from the first execution\r\n                    if (!mount) update();\r\n                }\r\n            })\r\n        ) => state\r\n    );\r\n};\r\n\r\n/**\r\n * Memorize the return of a callback\r\n * @type {import(\"core\").UseMemo}\r\n */\r\nexport const useMemo = (currentMemo, currentArgs) => {\r\n    const [state] = useHook(([state, args, cycle = 0] = []) => {\r\n        if (!args || (args && !isEqualArray(args, currentArgs))) {\r\n            state = currentMemo();\r\n        }\r\n        return [state, currentArgs, cycle];\r\n    });\r\n    return state;\r\n};\r\n\r\n/**\r\n * Apply the redux pattern as a hook\r\n * @type {import(\"core\").UseReducer}\r\n */\r\nexport const useReducer = (reducer, initialArg, init) => {\r\n    const update = useUpdate();\r\n    return useHook((state = []) => {\r\n        if (!state[1]) {\r\n            state[0] = init !== undefined ? init(initialArg) : initialArg;\r\n            state[1] = (action) => {\r\n                const nextState = reducer(state[0], action);\r\n                if (nextState != state[0]) {\r\n                    state[0] = nextState;\r\n                    update();\r\n                }\r\n            };\r\n        }\r\n        return state;\r\n    });\r\n};\r\n\r\n/**\r\n * Memorize a callback allowing it to remember the scope\r\n * variables regardless of the render\r\n * @type {import(\"core\").UseCallback}\r\n */\r\nexport const useCallback = (callback, args) => useMemo(() => callback, args);\r\n", "import { SymbolFor } from \"./utils.js\";\r\n\r\nconst ID = SymbolFor(\"atomico/options\");\r\n\r\nglobalThis[ID] = globalThis[ID] || {\r\n    sheet: !!document.adoptedStyleSheets\r\n};\r\n\r\n/**\r\n * @type {import(\"core\").Options}\r\n */\r\nexport const options = globalThis[ID];\r\n", "import { options } from \"./options.js\";\r\nimport { addListener } from \"./utils.js\";\r\n\r\nexport const DOMLoaded = new Promise((resolve) => {\r\n    if (!options.ssr) {\r\n        if (document.readyState === \"loading\") {\r\n            addListener(document, \"DOMContentLoaded\", resolve);\r\n        } else {\r\n            resolve();\r\n        }\r\n    }\r\n});\r\n", "import { options } from \"./options.js\";\r\nimport {\r\n    SymbolFor,\r\n    flat,\r\n    isArray,\r\n    isFunction,\r\n    isHydrate,\r\n    isObject\r\n} from \"./utils.js\";\r\n\r\n// Object used to know which properties are extracted directly\r\n// from the node to verify 2 if they have changed\r\nconst VAL_FROM_PROPS = {\r\n    checked: 1,\r\n    value: 1,\r\n    selected: 1\r\n};\r\n// Map of attributes that escape the property analysis\r\nconst PROPS_AS_ATTRS = {\r\n    list: 1,\r\n    type: 1,\r\n    size: 1,\r\n    form: 1,\r\n    width: 1,\r\n    height: 1,\r\n    src: 1,\r\n    href: 1,\r\n    slot: 1\r\n};\r\n// escapes from diffProps compare process\r\nconst INTERNAL_PROPS = {\r\n    shadowDom: 1,\r\n    staticNode: 1,\r\n    cloneNode: 1,\r\n    children: 1,\r\n    key: 1\r\n};\r\n\r\n// Immutable for comparison of empty properties\r\nconst EMPTY_PROPS = {};\r\n// Immutable for empty children comparison\r\nconst EMPTY_CHILDREN = [];\r\n// Fragment marker\r\nexport class Mark extends Text {}\r\n\r\n// Default ID used to store the Vnode state\r\nexport const ID = SymbolFor(\"atomico/id\");\r\n\r\nexport const TYPE = SymbolFor(\"atomico/type\");\r\n\r\nexport const TYPE_NODE = SymbolFor(\"atomico/ref\");\r\n\r\nexport const TYPE_VNODE = SymbolFor(\"atomico/vnode\");\r\n\r\nexport const Fragment = () => {};\r\n\r\n/**\r\n * @param {Element} node\r\n * @param {import(\"vnode\").RenderId} [id]\r\n * @param {boolean} [hydrate]\r\n * @return {ChildNode}\r\n */\r\nexport function RENDER(node, id, hydrate) {\r\n    return diff(this, node, id, hydrate);\r\n}\r\n/**\r\n * @type {import(\"vnode\").H}\r\n */\r\nexport const h = (type, p, ...args) => {\r\n    /**\r\n     * @type {any}\r\n     */\r\n    const props = p || EMPTY_PROPS;\r\n\r\n    let { children } = props;\r\n\r\n    children =\r\n        children != null ? children : args.length ? args : EMPTY_CHILDREN;\r\n\r\n    if (type === Fragment) {\r\n        //@ts-ignore\r\n        return children;\r\n    }\r\n\r\n    const raw = type\r\n        ? type instanceof Node\r\n            ? 1\r\n            : //@ts-ignore\r\n              type.prototype instanceof HTMLElement && 2\r\n        : 0;\r\n\r\n    //@ts-ignore\r\n    if (raw === false && type instanceof Function) {\r\n        return type(\r\n            children != EMPTY_CHILDREN ? { children, ...props } : props\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @todo look for a more elegant type, since you can't follow the type rules without capturing this\r\n     * @type {any}\r\n     */\r\n    const render = options.render || RENDER;\r\n\r\n    /**\r\n     * @type {import(\"vnode\").VNodeAny}\r\n     */\r\n    const vnode = {\r\n        [TYPE]: TYPE_VNODE,\r\n        type,\r\n        props,\r\n        children,\r\n        key: props.key,\r\n        // key for lists by keys\r\n        // define if the node declares its shadowDom\r\n        shadow: props.shadowDom,\r\n        // allows renderings to run only once\r\n        static: props.staticNode,\r\n        // defines whether the type is a childNode `1` or a constructor `2`\r\n        raw,\r\n        // defines whether to use the second parameter for document.createElement\r\n        is: props.is,\r\n        // clone the node if it comes from a reference\r\n        clone: props.cloneNode,\r\n        render\r\n    };\r\n\r\n    //@ts-ignore\r\n    return vnode;\r\n};\r\n\r\n/**\r\n * Create or update a node\r\n * Node: The declaration of types through JSDOC does not allow to compress\r\n * the exploration of the parameters\r\n * @param {ReturnType<h>} newVnode\r\n * @param {Element} node\r\n * @param {import(\"vnode\").RenderId} [id]\r\n * @param {boolean} [hydrate]\r\n * @param {boolean} [isSvg]\r\n * @returns {ChildNode}\r\n */\r\nfunction diff(newVnode, node, id = ID, hydrate, isSvg) {\r\n    let isNewNode;\r\n    // If the node maintains the source vnode it escapes from the update tree\r\n    if (\r\n        (node && node[id] && node[id].vnode == newVnode) ||\r\n        newVnode[TYPE] != TYPE_VNODE\r\n    )\r\n        return node;\r\n    // The process only continues when you may need to create a node\r\n    if (newVnode || !node) {\r\n        isSvg = isSvg || newVnode.type == \"svg\";\r\n        // determines if the node should be regenerated\r\n        isNewNode =\r\n            newVnode.type != \"host\" &&\r\n            (newVnode.raw == 1\r\n                ? (node && newVnode.clone ? node[TYPE_NODE] : node) !=\r\n                  newVnode.type\r\n                : newVnode.raw == 2\r\n                  ? !(node instanceof newVnode.type)\r\n                  : node\r\n                    ? node[TYPE_NODE] || node.localName != newVnode.type\r\n                    : !node);\r\n\r\n        if (isNewNode && newVnode.type != null) {\r\n            if (newVnode.raw == 1 && newVnode.clone) {\r\n                hydrate = true;\r\n                node = newVnode.type.cloneNode(true);\r\n                node[TYPE_NODE] = newVnode.type;\r\n            } else {\r\n                node =\r\n                    newVnode.raw == 1\r\n                        ? newVnode.type\r\n                        : newVnode.raw == 2\r\n                          ? new newVnode.type()\r\n                          : isSvg\r\n                            ? document.createElementNS(\r\n                                  \"http://www.w3.org/2000/svg\",\r\n                                  newVnode.type\r\n                              )\r\n                            : document.createElement(\r\n                                  newVnode.type,\r\n                                  newVnode.is ? { is: newVnode.is } : undefined\r\n                              );\r\n            }\r\n        }\r\n    }\r\n\r\n    const oldVNodeStore = node[id] ? node[id] : EMPTY_PROPS;\r\n\r\n    /**\r\n     * @type {import(\"vnode\").VNodeStore}\r\n     */\r\n    const { vnode = EMPTY_PROPS, cycle = 0 } = oldVNodeStore;\r\n\r\n    let { fragment, handlers } = oldVNodeStore;\r\n\r\n    /**\r\n     * @type {import(\"vnode\").VNodeGeneric}\r\n     */\r\n    const { children = EMPTY_CHILDREN, props = EMPTY_PROPS } = vnode;\r\n\r\n    /**\r\n     * @type {import(\"vnode\").Handlers}\r\n     */\r\n    handlers = isNewNode ? {} : handlers || {};\r\n    /**\r\n     * Escape a second render if the vnode.type is equal\r\n     */\r\n    if (newVnode.static && !isNewNode) return node;\r\n\r\n    newVnode.shadow &&\r\n        !node.shadowRoot &&\r\n        // @ts-ignore\r\n        node.attachShadow({ mode: \"open\", ...newVnode.shadow });\r\n\r\n    newVnode.props != props &&\r\n        diffProps(node, props, newVnode.props, handlers, isSvg);\r\n\r\n    if (newVnode.children !== children) {\r\n        const nextParent = newVnode.shadow ? node.shadowRoot : node;\r\n\r\n        fragment = renderChildren(\r\n            newVnode.children,\r\n            /**\r\n             * @todo for hydration use attribute and send childNodes\r\n             */\r\n            fragment,\r\n            nextParent,\r\n            id,\r\n            // add support to foreignObject, children will escape from svg\r\n            !cycle && hydrate,\r\n            isSvg && newVnode.type == \"foreignObject\" ? false : isSvg\r\n        );\r\n    }\r\n\r\n    node[id] = { vnode: newVnode, handlers, fragment, cycle: cycle + 1 };\r\n\r\n    return node;\r\n}\r\n/**\r\n *\r\n * @param {Element|ShadowRoot} parent\r\n * @param {boolean} [hydrate]\r\n * @return {import(\"vnode\").Fragment}\r\n */\r\nfunction createFragment(parent, hydrate) {\r\n    const markStart = new Mark(\"\");\r\n    const markEnd = new Mark(\"\");\r\n\r\n    /**\r\n     * @type {Element}\r\n     */\r\n    let node;\r\n\r\n    parent[hydrate ? \"prepend\" : \"append\"](markStart);\r\n\r\n    if (hydrate) {\r\n        let { lastElementChild } = parent;\r\n        while (lastElementChild) {\r\n            const { previousElementSibling } = lastElementChild;\r\n            if (\r\n                isHydrate(lastElementChild, true) &&\r\n                !isHydrate(previousElementSibling, true)\r\n            ) {\r\n                node = lastElementChild;\r\n                break;\r\n            }\r\n            lastElementChild = previousElementSibling;\r\n        }\r\n    }\r\n\r\n    if (node) {\r\n        node.before(markEnd);\r\n    } else {\r\n        parent.append(markEnd);\r\n    }\r\n\r\n    return {\r\n        markStart,\r\n        markEnd\r\n    };\r\n}\r\n\r\n/**\r\n * This method should only be executed from render,\r\n * it allows rendering the children of the virtual-dom\r\n * @param {any} children\r\n * @param {import(\"vnode\").Fragment} fragment\r\n * @param {Element|ShadowRoot} parent\r\n * @param {any} id\r\n * @param {boolean} [hydrate]\r\n * @param {boolean} [isSvg]\r\n */\r\nexport function renderChildren(children, fragment, parent, id, hydrate, isSvg) {\r\n    children =\r\n        children == null ? null : isArray(children) ? children : [children];\r\n\r\n    const nextFragment = fragment || createFragment(parent, hydrate);\r\n\r\n    const { markStart, markEnd, keyes } = nextFragment;\r\n    /**\r\n     * @type {import(\"vnode\").Keyes}\r\n     */\r\n    let nextKeyes;\r\n    /**\r\n     * Eliminate intermediate nodes that are not used in the process in keyed\r\n     * @type {Set<ChildNode>}\r\n     */\r\n    const removeNodes = keyes && new Set();\r\n\r\n    /**\r\n     * RULES: that you should never exceed \"c\"\r\n     * @type {ChildNode}\r\n     */\r\n    let currentNode = markStart;\r\n\r\n    children &&\r\n        flat(children, (child) => {\r\n            if (typeof child == \"object\" && !child[TYPE]) {\r\n                return;\r\n            }\r\n\r\n            const key = child[TYPE] && child.key;\r\n            const childKey = keyes && key != null && keyes.get(key);\r\n            // check if the displacement affected the index of the child with\r\n            // assignment of key, if so the use of nextSibling is prevented\r\n            if (currentNode != markEnd && currentNode === childKey) {\r\n                removeNodes.delete(currentNode);\r\n            } else {\r\n                currentNode =\r\n                    currentNode == markEnd ? markEnd : currentNode.nextSibling;\r\n            }\r\n\r\n            const childNode = keyes ? childKey : currentNode;\r\n\r\n            let nextChildNode = childNode;\r\n            // text node diff\r\n            if (!child[TYPE]) {\r\n                const text = child + \"\";\r\n                if (\r\n                    !(nextChildNode instanceof Text) ||\r\n                    nextChildNode instanceof Mark\r\n                ) {\r\n                    nextChildNode = new Text(text);\r\n                }\r\n                // Only one Text node falls in this block\r\n                // @ts-ignore\r\n                else if (nextChildNode.data != text) {\r\n                    // @ts-ignore\r\n                    nextChildNode.data = text;\r\n                }\r\n            } else {\r\n                // diff only resive Elements\r\n                // @ts-ignore\r\n                nextChildNode = diff(child, childNode, id, hydrate, isSvg);\r\n            }\r\n            if (nextChildNode != currentNode) {\r\n                keyes && removeNodes.delete(nextChildNode);\r\n                if (!childNode || keyes) {\r\n                    parent.insertBefore(nextChildNode, currentNode);\r\n\r\n                    keyes &&\r\n                        currentNode != markEnd &&\r\n                        removeNodes.add(currentNode);\r\n                } else if (childNode == markEnd) {\r\n                    parent.insertBefore(nextChildNode, markEnd);\r\n                } else {\r\n                    parent.replaceChild(nextChildNode, childNode);\r\n                    currentNode = nextChildNode;\r\n                }\r\n            }\r\n            // if there is a key, a map of keys is created\r\n            if (key != null) {\r\n                nextKeyes = nextKeyes || new Map();\r\n                nextKeyes.set(key, nextChildNode);\r\n            }\r\n        });\r\n\r\n    currentNode = currentNode == markEnd ? markEnd : currentNode.nextSibling;\r\n\r\n    if (fragment && currentNode != markEnd) {\r\n        // cleaning of remnants within the fragment\r\n        while (currentNode != markEnd) {\r\n            const nodeToRemove = currentNode;\r\n            currentNode = currentNode.nextSibling;\r\n            nodeToRemove.remove();\r\n        }\r\n    }\r\n\r\n    removeNodes && removeNodes.forEach((node) => node.remove());\r\n\r\n    nextFragment.keyes = nextKeyes;\r\n\r\n    return nextFragment;\r\n}\r\n\r\n/**\r\n *\r\n * @param {Element} node\r\n * @param {Object} props\r\n * @param {Object} nextProps\r\n * @param {boolean} isSvg\r\n * @param {import(\"vnode\").Handlers} handlers\r\n **/\r\nexport function diffProps(node, props, nextProps, handlers, isSvg) {\r\n    for (const key in props) {\r\n        !(key in nextProps) &&\r\n            setProperty(node, key, props[key], null, isSvg, handlers);\r\n    }\r\n    for (const key in nextProps) {\r\n        setProperty(node, key, props[key], nextProps[key], isSvg, handlers);\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @param {Element|HTMLSlotElement} node\r\n * @param {string} key\r\n * @param {any} prevValue\r\n * @param {any} nextValue\r\n * @param {boolean} isSvg\r\n * @param {import(\"vnode\").Handlers} handlers\r\n */\r\nexport function setProperty(node, key, prevValue, nextValue, isSvg, handlers) {\r\n    key = key == \"class\" && !isSvg ? \"className\" : key;\r\n    // define empty value\r\n    prevValue = prevValue == null ? null : prevValue;\r\n    nextValue = nextValue == null ? null : nextValue;\r\n\r\n    if (key in node && VAL_FROM_PROPS[key]) {\r\n        prevValue = node[key];\r\n    }\r\n\r\n    if (nextValue === prevValue || INTERNAL_PROPS[key] || key[0] == \"_\") return;\r\n\r\n    if (node.localName === \"slot\" && key === \"assignNode\" && \"assign\" in node) {\r\n        node.assign(nextValue);\r\n    } else if (\r\n        key[0] == \"o\" &&\r\n        key[1] == \"n\" &&\r\n        (isFunction(nextValue) || isFunction(prevValue))\r\n    ) {\r\n        setEvent(node, key.slice(2), nextValue, handlers);\r\n    } else if (key == \"ref\") {\r\n        if (nextValue) {\r\n            if (isFunction(nextValue)) {\r\n                nextValue(node);\r\n            } else {\r\n                nextValue.current = node;\r\n            }\r\n        }\r\n    } else if (key == \"style\") {\r\n        /**\r\n         * @todo Find out why Element defines style at the type level\r\n         * @type {any}\r\n         */\r\n        const { style } = node;\r\n\r\n        prevValue = prevValue || \"\";\r\n        nextValue = nextValue || \"\";\r\n\r\n        const prevIsObject = isObject(prevValue);\r\n        const nextIsObject = isObject(nextValue);\r\n\r\n        if (prevIsObject) {\r\n            for (const key in prevValue) {\r\n                if (nextIsObject) {\r\n                    !(key in nextValue) && setPropertyStyle(style, key, null);\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (nextIsObject) {\r\n            for (const key in nextValue) {\r\n                const value = nextValue[key];\r\n                if (prevIsObject && prevValue[key] === value) continue;\r\n                setPropertyStyle(style, key, value);\r\n            }\r\n        } else {\r\n            style.cssText = nextValue;\r\n        }\r\n    } else {\r\n        const attr = key[0] == \"$\" ? key.slice(1) : key;\r\n        if (\r\n            attr === key &&\r\n            ((!isSvg && !PROPS_AS_ATTRS[key] && key in node) ||\r\n                isFunction(nextValue) ||\r\n                isFunction(prevValue))\r\n        ) {\r\n            node[key] = nextValue == null ? \"\" : nextValue;\r\n        } else if (nextValue == null) {\r\n            node.removeAttribute(attr);\r\n        } else {\r\n            node.setAttribute(\r\n                attr,\r\n                isObject(nextValue) ? JSON.stringify(nextValue) : nextValue\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @param {Node} node\r\n * @param {string} type\r\n * @param {import(\"vnode\").VNodeListener} [nextHandler]\r\n * @param {import(\"vnode\").Handlers} [handlers]\r\n */\r\nexport function setEvent(node, type, nextHandler, handlers) {\r\n    // add handleEvent to handlers\r\n    if (!handlers.handleEvent) {\r\n        /**\r\n         * {@link https://developer.mozilla.org/es/docs/Web/API/EventTarget/addEventListener#The_value_of_this_within_the_handler}\r\n         **/\r\n        handlers.handleEvent = (event) =>\r\n            handlers[event.type].call(node, event);\r\n    }\r\n    if (nextHandler) {\r\n        // create the subscriber if it does not exist\r\n        if (!handlers[type]) {\r\n            //the event configuration is only subscribed at the time of association\r\n            const options =\r\n                nextHandler.capture || nextHandler.once || nextHandler.passive\r\n                    ? Object.assign({}, nextHandler)\r\n                    : null;\r\n            node.addEventListener(type, handlers, options);\r\n        }\r\n        // update the associated event\r\n        handlers[type] = nextHandler;\r\n    } else {\r\n        // \tdelete the associated event\r\n        if (handlers[type]) {\r\n            node.removeEventListener(type, handlers);\r\n            delete handlers[type];\r\n        }\r\n    }\r\n}\r\n/**\r\n *\r\n * @param {*} style\r\n * @param {string} key\r\n * @param {string} value\r\n */\r\nexport function setPropertyStyle(style, key, value) {\r\n    let method = \"setProperty\";\r\n    if (value == null) {\r\n        method = \"removeProperty\";\r\n        value = null;\r\n    }\r\n    if (~key.indexOf(\"-\")) {\r\n        style[method](key, value);\r\n    } else {\r\n        style[key] = value;\r\n    }\r\n}\r\n\r\nexport { diff as render };\r\n", "import { options } from \"./options.js\";\r\nimport { c } from \"./element/custom-element.js\";\r\nimport { useHost, useRef, useUpdate } from \"./hooks/create-hooks.js\";\r\nimport { useEvent } from \"./hooks/custom-hooks/use-event.js\";\r\nimport { useEffect, useInsertionEffect, useState } from \"./hooks/hooks.js\";\r\nimport { DOMLoaded } from \"./loaded.js\";\r\nimport { h } from \"./render.js\";\r\nimport { addListener } from \"./utils.js\";\r\n\r\nconst CONTEXT_TEMPLATE = h(\"host\", { style: \"display: contents\" });\r\n\r\nconst CONTEXT_VALUE = \"value\";\r\n\r\n/**\r\n * @type {import(\"context\").UseProvider}\r\n */\r\nexport const useProvider = (id, value) => {\r\n    const host = useHost();\r\n\r\n    const ref = useRef();\r\n\r\n    useInsertionEffect(\r\n        () =>\r\n            addListener(\r\n                host.current,\r\n                \"ConnectContext\",\r\n                /**\r\n                 * @param {CustomEvent<import(\"context\").DetailConnectContext>} event\r\n                 */\r\n                (event) => {\r\n                    const target = event.composedPath().at(0);\r\n                    if (\r\n                        target !== event.currentTarget &&\r\n                        id === event.detail.id\r\n                    ) {\r\n                        event.stopPropagation();\r\n                        event.detail.connect(ref);\r\n                    }\r\n                }\r\n            ),\r\n        [id]\r\n    );\r\n\r\n    ref.current = value;\r\n};\r\n\r\n/**\r\n *\r\n * @type {import(\"context\").UseContext}\r\n */\r\nexport const useContext = (id) => {\r\n    const dispatch = useEvent(\"ConnectContext\", {\r\n        bubbles: true,\r\n        composed: true\r\n    });\r\n\r\n    const [parentContext, setParentContext] = useState(() => {\r\n        if (options.ssr) return;\r\n        /**\r\n         * @type {import(\"core\").Ref}\r\n         */\r\n        let currentParentContext;\r\n        dispatch({\r\n            id,\r\n            /**\r\n             * @param {import(\"core\").Ref} parentContext\r\n             */\r\n            connect(parentContext) {\r\n                currentParentContext = parentContext;\r\n            }\r\n        });\r\n        return currentParentContext;\r\n    });\r\n\r\n    const update = useUpdate();\r\n\r\n    useEffect(() => {\r\n        DOMLoaded.then(() =>\r\n            dispatch({\r\n                id,\r\n                connect: setParentContext\r\n            })\r\n        );\r\n    }, [id]);\r\n\r\n    useEffect(() => {\r\n        if (!parentContext) return;\r\n        return parentContext.on(update);\r\n    }, [parentContext]);\r\n\r\n    return parentContext?.current || id[CONTEXT_VALUE];\r\n};\r\n\r\n/**\r\n * @type {import(\"context\").CreateContext}\r\n */\r\nexport const createContext = (value) => {\r\n    /**\r\n     * @todo Discover a more aesthetic solution at the type level\r\n     * TS tries to set local class rules, these should be ignored\r\n     * @type {any}\r\n     */\r\n    const Context = c(\r\n        ({ value }) => {\r\n            useProvider(Context, value);\r\n            return CONTEXT_TEMPLATE;\r\n        },\r\n        {\r\n            props: {\r\n                value: {\r\n                    type: Object,\r\n                    value: () => value\r\n                }\r\n            }\r\n        }\r\n    );\r\n\r\n    Context[CONTEXT_VALUE] = value;\r\n\r\n    return Context;\r\n};\r\n", "import { useMemo, useState } from \"../hooks.js\";\r\nimport { createContext, useProvider } from \"../../context.js\";\r\n\r\nexport const SuspenseEvent = {\r\n    pending: \"PendingSuspense\",\r\n    fulfilled: \"FulfilledSuspense\",\r\n    rejected: \"RejectedSuspense\",\r\n    aborted: \"AbortedSuspense\"\r\n};\r\n\r\nexport const SuspenseContext = createContext({\r\n    /**\r\n     *\r\n     * @param {string} type\r\n     * @param {string} id\r\n     */\r\n    dispatch(type, id) {}\r\n});\r\n\r\n/**\r\n *\r\n * @type {import(\"core\").UseSuspense}\r\n */\r\n\r\nexport const useSuspense = (fps = 8) => {\r\n    /**\r\n     * @type {import(\"internal/hooks.js\").ReturnSetStateUseSuspense}\r\n     */\r\n    const [status, setStatus] = useState({ pending: true });\r\n\r\n    /**\r\n     *\r\n     * @param {()=>any} callback\r\n     * @param {number} deep\r\n     */\r\n    const delay = (callback, deep) =>\r\n        requestAnimationFrame(() =>\r\n            deep ? delay(callback, --deep) : callback()\r\n        );\r\n\r\n    const context = useMemo(() => {\r\n        const values = new Set();\r\n        let prevent = false;\r\n        let rejected = false;\r\n        let aborted = false;\r\n\r\n        /**\r\n         * Check if tasks are pending at the DOM tree level.\r\n         */\r\n        const progress = () => {\r\n            if (!prevent) {\r\n                prevent = true;\r\n                delay(() => {\r\n                    prevent = false;\r\n                    setStatus((state) =>\r\n                        values.size\r\n                            ? state.pending\r\n                                ? state\r\n                                : { pending: true }\r\n                            : aborted\r\n                              ? state.aborted\r\n                                  ? state\r\n                                  : { aborted }\r\n                              : rejected\r\n                                ? state.rejected\r\n                                    ? state\r\n                                    : { rejected }\r\n                                : state.fulfilled\r\n                                  ? state\r\n                                  : { fulfilled: true }\r\n                    );\r\n                }, fps);\r\n            }\r\n        };\r\n        /**\r\n         *\r\n         * @param {string} type\r\n         * @param {string} id\r\n         */\r\n        const dispatch = (type, id) => {\r\n            if (type === SuspenseEvent.pending) {\r\n                values.add(id);\r\n                progress();\r\n            } else if (values.has(id)) {\r\n                values.delete(id);\r\n                if (type === SuspenseEvent.fulfilled) {\r\n                } else if (type === SuspenseEvent.aborted) {\r\n                    aborted = true;\r\n                } else {\r\n                    rejected = true;\r\n                }\r\n                progress();\r\n            }\r\n        };\r\n\r\n        return { dispatch };\r\n    }, []);\r\n\r\n    useProvider(SuspenseContext, context);\r\n\r\n    return status;\r\n};\r\n", "import { createElement } from './src/core.js';\r\n\r\nconst MODE_SLASH = 0;\r\nconst MODE_TEXT = 1;\r\nconst MODE_WHITESPACE = 2;\r\nconst MODE_TAGNAME = 3;\r\nconst MODE_COMMENT = 4;\r\nconst MODE_PROP_SET = 5;\r\nconst MODE_PROP_APPEND = 6;\r\n\r\nconst CHILD_APPEND = 0;\r\nconst CHILD_RECURSE = 2;\r\nconst TAG_SET = 3;\r\nconst PROPS_ASSIGN = 4;\r\nconst PROP_SET = MODE_PROP_SET;\r\nconst PROP_APPEND = MODE_PROP_APPEND;\r\n\r\nconst evaluate = (h, built, fields, args) => {\r\n\tlet tmp;\r\n\r\n\t// `build()` used the first element of the operation list as\r\n\t// temporary workspace. Now that `build()` is done we can use\r\n\t// that space to track whether the current element is \"dynamic\"\r\n\t// (i.e. it or any of its descendants depend on dynamic values).\r\n\tbuilt[0] = 0;\r\n\r\n\tfor (let i = 1; i < built.length; i++) {\r\n\t\tconst type = built[i++];\r\n\r\n\t\t// Set `built[0]`'s appropriate bits if this element depends on a dynamic value.\r\n\t\tconst value = built[i] ? ((built[0] |= type ? 1 : 2), fields[built[i++]]) : built[++i];\r\n\r\n\t\tif (type === TAG_SET) {\r\n\t\t\targs[0] = value;\r\n\t\t}\r\n\t\telse if (type === PROPS_ASSIGN) {\r\n\t\t\targs[1] = Object.assign(args[1] || {}, value);\r\n\t\t}\r\n\t\telse if (type === PROP_SET) {\r\n\t\t\t(args[1] = args[1] || {})[built[++i]] = value;\r\n\t\t}\r\n\t\telse if (type === PROP_APPEND) {\r\n\t\t\targs[1][built[++i]] += (value + '');\r\n\t\t}\r\n\t\telse if (type) { // type === CHILD_RECURSE\r\n\t\t\t// Set the operation list (including the staticness bits) as\r\n\t\t\t// `this` for the `h` call.\r\n\t\t\ttmp = h.apply(value, evaluate(h, value, fields, ['', null]));\r\n\t\t\targs.push(tmp);\r\n\r\n\t\t\tif (value[0]) {\r\n\t\t\t\t// Set the 2nd lowest bit it the child element is dynamic.\r\n\t\t\t\tbuilt[0] |= 2;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Rewrite the operation list in-place if the child element is static.\r\n\t\t\t\t// The currently evaluated piece `CHILD_RECURSE, 0, [...]` becomes\r\n\t\t\t\t// `CHILD_APPEND, 0, tmp`.\r\n\t\t\t\t// Essentially the operation list gets optimized for potential future\r\n\t\t\t\t// re-evaluations.\r\n\t\t\t\tbuilt[i-2] = CHILD_APPEND;\r\n\t\t\t\tbuilt[i] = tmp;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse { // type === CHILD_APPEND\r\n\t\t\targs.push(value);\r\n\t\t}\r\n\t}\r\n\r\n\treturn args;\r\n};\r\n\r\nconst build = function(statics) {\r\n\r\n\tlet mode = MODE_TEXT;\r\n\tlet buffer = '';\r\n\tlet quote = '';\r\n\tlet current = [0];\r\n\tlet char, propName;\r\n\r\n\tconst commit = field => {\r\n\t\tif (mode === MODE_TEXT && (field || (buffer = buffer.replace(/^\\s*\\n\\s*|\\s*\\n\\s*$/g,'')))) {\r\n\t\t\t{\r\n\t\t\t\tcurrent.push(CHILD_APPEND, field, buffer);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (mode === MODE_TAGNAME && (field || buffer)) {\r\n\t\t\t{\r\n\t\t\t\tcurrent.push(TAG_SET, field, buffer);\r\n\t\t\t}\r\n\t\t\tmode = MODE_WHITESPACE;\r\n\t\t}\r\n\t\telse if (mode === MODE_WHITESPACE && buffer === '...' && field) {\r\n\t\t\t{\r\n\t\t\t\tcurrent.push(PROPS_ASSIGN, field, 0);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (mode === MODE_WHITESPACE && buffer && !field) {\r\n\t\t\t{\r\n\t\t\t\tcurrent.push(PROP_SET, 0, true, buffer);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (mode >= MODE_PROP_SET) {\r\n\t\t\t{\r\n\t\t\t\tif (buffer || (!field && mode === MODE_PROP_SET)) {\r\n\t\t\t\t\tcurrent.push(mode, 0, buffer, propName);\r\n\t\t\t\t\tmode = MODE_PROP_APPEND;\r\n\t\t\t\t}\r\n\t\t\t\tif (field) {\r\n\t\t\t\t\tcurrent.push(mode, field, 0, propName);\r\n\t\t\t\t\tmode = MODE_PROP_APPEND;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tbuffer = '';\r\n\t};\r\n\r\n\tfor (let i=0; i<statics.length; i++) {\r\n\t\tif (i) {\r\n\t\t\tif (mode === MODE_TEXT) {\r\n\t\t\t\tcommit();\r\n\t\t\t}\r\n\t\t\tcommit(i);\r\n\t\t}\r\n\r\n\t\tfor (let j=0; j<statics[i].length;j++) {\r\n\t\t\tchar = statics[i][j];\r\n\r\n\t\t\tif (mode === MODE_TEXT) {\r\n\t\t\t\tif (char === '<') {\r\n\t\t\t\t\t// commit buffer\r\n\t\t\t\t\tcommit();\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcurrent = [current];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmode = MODE_TAGNAME;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tbuffer += char;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (mode === MODE_COMMENT) {\r\n\t\t\t\t// Ignore everything until the last three characters are '-', '-' and '>'\r\n\t\t\t\tif (buffer === '--' && char === '>') {\r\n\t\t\t\t\tmode = MODE_TEXT;\r\n\t\t\t\t\tbuffer = '';\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tbuffer = char + buffer[0];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (quote) {\r\n\t\t\t\tif (char === quote) {\r\n\t\t\t\t\tquote = '';\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tbuffer += char;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (char === '\"' || char === \"'\") {\r\n\t\t\t\tquote = char;\r\n\t\t\t}\r\n\t\t\telse if (char === '>') {\r\n\t\t\t\tcommit();\r\n\t\t\t\tmode = MODE_TEXT;\r\n\t\t\t}\r\n\t\t\telse if (!mode) ;\r\n\t\t\telse if (char === '=') {\r\n\t\t\t\tmode = MODE_PROP_SET;\r\n\t\t\t\tpropName = buffer;\r\n\t\t\t\tbuffer = '';\r\n\t\t\t}\r\n\t\t\telse if (char === '/' && (mode < MODE_PROP_SET || statics[i][j+1] === '>')) {\r\n\t\t\t\tcommit();\r\n\t\t\t\tif (mode === MODE_TAGNAME) {\r\n\t\t\t\t\tcurrent = current[0];\r\n\t\t\t\t}\r\n\t\t\t\tmode = current;\r\n\t\t\t\t{\r\n\t\t\t\t\t(current = current[0]).push(CHILD_RECURSE, 0, mode);\r\n\t\t\t\t}\r\n\t\t\t\tmode = MODE_SLASH;\r\n\t\t\t}\r\n\t\t\telse if (char === ' ' || char === '\\t' || char === '\\n' || char === '\\r') {\r\n\t\t\t\t// <a disabled>\r\n\t\t\t\tcommit();\r\n\t\t\t\tmode = MODE_WHITESPACE;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tbuffer += char;\r\n\t\t\t}\r\n\r\n\t\t\tif (mode === MODE_TAGNAME && buffer === '!--') {\r\n\t\t\t\tmode = MODE_COMMENT;\r\n\t\t\t\tcurrent = current[0];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tcommit();\r\n\treturn current;\r\n};\r\n\r\nconst CACHE = new Map();\r\n\r\nfunction html(statics) {\r\n    let tmp = CACHE;\r\n\r\n    tmp = evaluate(\r\n        createElement,\r\n        tmp.get(statics) || (tmp.set(statics, (tmp = build(statics))), tmp),\r\n        arguments,\r\n        []\r\n    );\r\n\r\n    return tmp.length > 1 ? tmp : tmp[0];\r\n}\r\n\r\nexport { html };\r\n"],
  "mappings": "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",
  "names": ["list", "ID", "options", "state", "ID", "ID", "key", "options", "value", "h"]
}

{
  "version": 3,
  "sources": ["../../atomico/src/ref.js", "../../atomico/src/hooks/create-hooks.js", "../../atomico/src/utils.js", "../../atomico/src/element/errors.js", "../../atomico/src/element/set-prototype.js", "../../atomico/src/element/custom-element.js", "../../atomico/src/hooks/use-effect.js", "../../atomico/src/hooks/state.js", "../../atomico/src/hooks/hooks.js", "../../atomico/src/options.js", "../../atomico/src/loaded.js", "../../atomico/src/render.js", "../../atomico/src/context.js", "../../atomico/src/hooks/custom-hooks/use-suspense.js", "../../atomico/html.js"],
  "sourcesContent": ["/**\n * @template {any} T\n */\nexport class Ref {\n    /**\n     * @type {T}\n     */\n    #current;\n    #listeners = new Set();\n    /**\n     * @param {T} current\n     */\n    constructor(current) {\n        this.#current = current;\n    }\n    /**\n     * @return {T}\n     */\n    get current() {\n        return this.#current;\n    }\n    /**\n     * @param {T} value\n     */\n    set current(value) {\n        if (this.#current != value) {\n            this.#current = value;\n            this.#listeners.forEach((fn) => fn(value));\n        }\n    }\n    /**\n     * @type {import(\"hooks\").Ref[\"on\"]}\n     */\n    on(fn) {\n        this.#listeners.add(fn);\n        return () => this.#listeners.delete(fn);\n    }\n}\n\n/**\n * @template {any} Value\n * @param {Value} [value]\n * @returns {import(\"hooks\").Ref}\n */\nexport const createRef = (value) => new Ref(value);\n", "import { createRef } from \"../ref.js\";\n\nconst ID = Symbol.for(\"atomico.hooks\");\n\n// previene la perdida de hook concurrente al duplicar el modulo\n// This usually happens on Deno and Webpack\nglobalThis[ID] = globalThis[ID] || {};\n/**\n * @type {{c:import(\"internal/hooks.js\").SCOPE}}\n */\nlet SCOPE = globalThis[ID];\n\n/**\n * Error id to escape execution of hooks.load\n */\nexport const IdSuspense = Symbol.for(\"Atomico.suspense\");\n\n/**\n * tag to identify the useEffect\n */\nexport const IdEffect = Symbol.for(\"Atomico.effect\");\n\n/**\n * tag to identify the useLayoutEffect\n */\nexport const IdLayoutEffect = Symbol.for(\"Atomico.layoutEffect\");\n\n/**\n * tag to identify the useInsertionEffect\n */\nexport const IdInsertionEffect = Symbol.for(\"Atomico.insertionEffect\");\n\n/**\n * @type {import(\"core\").UseHook}\n */\nexport const useHook = (render, effect, tag) => {\n    const { i, hooks } = SCOPE.c;\n\n    const hook = (hooks[i] = hooks[i] || {});\n\n    hook.value = render(hook.value);\n    hook.effect = effect;\n    hook.tag = tag;\n\n    SCOPE.c.i++;\n\n    return hooks[i].value;\n};\n\n/**\n * @type {import(\"core\").UseRef}\n */\nexport const useRef = (current) => useHook((ref = createRef(current)) => ref);\n\n/**\n * return the global host of the scope\n * @type {import(\"core\").UseHost}\n */\nexport const useHost = () => useHook((ref = createRef(SCOPE.c.host)) => ref);\n\n/**\n * hook that retrieves the render to restart the loop\n * @type {import(\"core\").UseUpdate}\n */\nexport const useUpdate = () => SCOPE.c.update;\n\n/**\n * @type {import(\"core\").UseId}\n */\nexport const useId = () => useHook(() => SCOPE.c.id + \"-\" + SCOPE.c.i);\n\n/**\n * @type {import(\"internal/hooks.js\").CreateHooks}\n */\nexport const createHooks = (update, host, id = 0) => {\n    /**\n     * @type {import(\"internal/hooks.js\").Hooks}\n     **/\n    let hooks = {};\n    let suspense = false;\n\n    const isSuspense = () => suspense;\n    /**\n     * announces that the updates have finished allowing the\n     * execution of the collectors\n     * @param {import(\"internal/hooks.js\").Hook[\"tag\"]} tag\n     * @param {boolean} [unmounted]\n     */\n    const cleanEffectsByType = (tag, unmounted) => {\n        for (const index in hooks) {\n            const hook = hooks[index];\n            if (hook.effect && hook.tag === tag) {\n                hook.value = hook.effect(hook.value, unmounted);\n            }\n        }\n    };\n    /**\n     * @type {import(\"internal/hooks.js\").Load}\n     */\n    const load = (callback) => {\n        SCOPE.c = { host, hooks, update, i: 0, id };\n        let value;\n        try {\n            suspense = false;\n            value = callback();\n        } catch (e) {\n            if (e !== IdSuspense) throw e;\n            suspense = true;\n        } finally {\n            SCOPE.c = null;\n        }\n        return value;\n    };\n    /**\n     * @type {import(\"internal/hooks.js\").CleanEffects}\n     */\n    const cleanEffects = (unmounted) => {\n        cleanEffectsByType(IdInsertionEffect, unmounted);\n        return () => {\n            cleanEffectsByType(IdLayoutEffect, unmounted);\n            return () => {\n                cleanEffectsByType(IdEffect, unmounted);\n                /**\n                 * currently the state of the props is preserved\n                 * at the node level, if the node is deleted the\n                 * state of the props persists so the state of\n                 *  the DOM must also persist\n                 */\n                // if (unmounted) hooks = {};\n            };\n        };\n    };\n\n    return { load, cleanEffects, isSuspense };\n};\n", "export const SymbolFor = Symbol.for;\n\n/**\n * compare 2 array\n * ```js\n * isEqualArray([1,2,3,4],[1,2,3,4]) // true\n * isEqualArray([1,2,3,4],[1,2,3])   // false\n * isEqualArray([5,1,2,3],[1,2,3,5]) // false\n * isEqualArray([],[]) // true\n * ```\n * @param {any[]} before\n * @param {any[]} after\n * @returns {boolean}\n */\nexport function isEqualArray(before, after) {\n    const length = before.length;\n    if (length !== after.length) return false;\n    for (let i = 0; i < length; i++) {\n        let beforeValue = before[i];\n        let afterValue = after[i];\n        if (beforeValue !== afterValue) return false;\n    }\n    return true;\n}\n/**\n * Determine if the value is considered a function\n * @type {import(\"internal/utils.js\").IsFunction}\n */\nexport const isFunction = (value) => typeof value == \"function\";\n\n/**\n * Determines if the value is considered an object\n * @param {any} value\n */\nexport const isObject = (value) => typeof value == \"object\";\n\nexport const { isArray } = Array;\n\n/**\n *\n * @param {Element & {dataset?:object}} node\n * @param {boolean} [styleOnly] - limits the hydration of the lists only to the tagStyle\n * @returns\n */\nexport const isHydrate = (node, styleOnly) =>\n    (styleOnly ? node instanceof HTMLStyleElement : true) &&\n    \"hydrate\" in (node?.dataset || {});\n\n/**\n * @template {any[]} T\n * @param {T} list\n * @param {(value:T[0])=>void} callback\n */\nexport function flat(list, callback) {\n    let last;\n    /**\n     * @param {any[]} list\n     */\n    const reduce = (list) => {\n        let { length } = list;\n        for (let i = 0; i < length; i++) {\n            const value = list[i];\n            if (value && Array.isArray(value)) {\n                reduce(value);\n            } else {\n                const type = typeof value;\n                if (\n                    value == null ||\n                    type === \"function\" ||\n                    type === \"boolean\"\n                ) {\n                    continue;\n                } else if (type === \"string\" || type === \"number\") {\n                    if (last == null) last = \"\";\n                    last += value;\n                } else {\n                    if (last != null) {\n                        callback(last);\n                        last = null;\n                    }\n                    callback(value);\n                }\n            }\n        }\n    };\n\n    reduce(list);\n\n    if (last != null) callback(last);\n}\n\n/**\n * @param {any} target\n * @param {string} type\n * @param {(event:Event)=>void} handler\n */\nexport const addListener = (target, type, handler) => {\n    target.addEventListener(type, handler);\n    return () => target.removeEventListener(type, handler);\n};\n", "export class Error {\n    /**\n     *\n     * @param {HTMLElement} target\n     * @param {string} message\n     * @param {string} value\n     */\n    constructor(target, message, value) {\n        this.message = message;\n        this.target = target;\n        this.value = value;\n    }\n}\n\nexport class PropError extends Error {}\n\nexport class ParseError extends Error {}\n", "import { isFunction, isObject } from \"../utils.js\";\nimport { PropError } from \"./errors.js\";\n\nexport const CUSTOM_TYPE_NAME = \"Custom\";\n/**\n * The Any type avoids the validation of prop types\n * @type {null}\n **/\nexport const Any = null;\n\n/**\n * Attributes considered as valid boleanos\n **/\nconst TRUE_VALUES = { true: 1, \"\": 1, 1: 1 };\n\n/**\n * Constructs the setter and getter of the associated property\n * only if it is not defined in the prototype\n * @param {Object} prototype - CustomElement prototype\n * @param {string} prop - Name of the reactive property to associate with the customElement\n * @param {any} schema - Structure to be evaluated for the definition of the property\n * @param {Attrs} attrs - Dictionary of attributes to properties\n * @param {Values} values - Values to initialize the customElements\n */\nexport function setPrototype(prototype, prop, schema, attrs, values) {\n    /**@type {Schema} */\n    const {\n        type,\n        reflect,\n        event,\n        value: defaultValue,\n        attr = getAttr(prop)\n    } = schema?.name != CUSTOM_TYPE_NAME && isObject(schema) && schema != Any\n        ? schema\n        : { type: schema };\n\n    const isCustomType = type?.name === CUSTOM_TYPE_NAME && type.map;\n\n    const withDefaultValue =\n        defaultValue != null\n            ? type == Function || !isFunction(defaultValue)\n                ? () => defaultValue\n                : defaultValue\n            : null;\n\n    Object.defineProperty(prototype, prop, {\n        configurable: true,\n        /**\n         * @this {import(\"dom\").AtomicoThisInternal}\n         * @param {any} newValue\n         */\n        set(newValue) {\n            const oldValue = this[prop];\n\n            if (withDefaultValue && type != Boolean && newValue == null) {\n                newValue = withDefaultValue();\n            }\n\n            const { error, value } = (isCustomType ? mapValue : filterValue)(\n                type,\n                newValue\n            );\n\n            if (error && value != null) {\n                throw new PropError(\n                    this,\n                    `The value defined for prop '${prop}' must be of type '${type.name}'`,\n                    value\n                );\n            }\n\n            if (oldValue == value) return;\n\n            this._props[prop] = value == null ? undefined : value;\n\n            this.update();\n            /**\n             * 1.7.0 >, this position reduces the amount of updates to the DOM and render\n             */\n            event && dispatchEvent(this, event);\n            /**\n             * attribute mirroring must occur if component is mounted\n             */\n            this.updated.then(() => {\n                if (reflect) {\n                    this._ignoreAttr = attr;\n                    reflectValue(this, type, attr, this[prop]);\n                    this._ignoreAttr = null;\n                }\n            });\n        },\n        /**\n         * @this {import(\"dom\").AtomicoThisInternal}\n         */\n        get() {\n            return this._props[prop];\n        }\n    });\n\n    if (withDefaultValue) values[prop] = withDefaultValue();\n\n    attrs[attr] = { prop, type };\n}\n\n/**\n * Dispatch an event\n * @param {Element} node - DOM node to dispatch the event\n * @param {InternalEvent & InternalEventInit} event - Event to dispatch on node\n */\nexport const dispatchEvent = (\n    node,\n    { type, base = CustomEvent, ...eventInit }\n) => node.dispatchEvent(new base(type, eventInit));\n\n/**\n * Transform a Camel Case string to a Kebab case\n * @param {string} prop - string to apply the format\n * @returns {string}\n */\nexport const getAttr = (prop) => prop.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n\n/**\n * reflects an attribute value of the given element as context\n * @param {Element} host\n * @param {any} type\n * @param {string} attr\n * @param {any} value\n */\nexport const reflectValue = (host, type, attr, value) =>\n    value == null || (type == Boolean && !value)\n        ? host.removeAttribute(attr)\n        : host.setAttribute(\n              attr,\n              type?.name === CUSTOM_TYPE_NAME && type?.serialize\n                  ? type?.serialize(value)\n                  : isObject(value)\n                    ? JSON.stringify(value)\n                    : type == Boolean\n                      ? \"\"\n                      : value\n          );\n\n/**\n * transform a string to a value according to its type\n * @param {any} type\n * @param {string} value\n * @returns {any}\n */\nexport const transformValue = (type, value) =>\n    type == Boolean\n        ? !!TRUE_VALUES[value]\n        : type == Number\n          ? Number(value)\n          : type == String\n            ? value\n            : type == Array || type == Object\n              ? JSON.parse(value)\n              : type.name == CUSTOM_TYPE_NAME\n                ? value\n                : // TODO: If when defining reflect the prop can also be of type string?\n                  new type(value);\n\n/**\n *\n * @param {import(\"schema\").TypeCustom<(...args:any)=>any>} TypeCustom\n * @param {*} value\n * @returns\n */\nexport const mapValue = ({ map }, value) => {\n    try {\n        return { value: map(value), error: false };\n    } catch {\n        return { value, error: true };\n    }\n};\n/**\n * Filter the values based on their type\n * @param {any} type\n * @param {any} value\n * @returns {{error?:boolean,value:any}}\n */\nexport const filterValue = (type, value) =>\n    type == null || value == null\n        ? { value, error: false }\n        : type != String && value === \"\"\n          ? { value: undefined, error: false }\n          : type == Object || type == Array || type == Symbol\n            ? {\n                  value,\n                  error: {}.toString.call(value) !== `[object ${type.name}]`\n              }\n            : value instanceof type\n              ? {\n                    value,\n                    error: type == Number && Number.isNaN(value.valueOf())\n                }\n              : type == String || type == Number || type == Boolean\n                ? {\n                      value,\n                      error:\n                          type == Number\n                              ? typeof value != \"number\"\n                                  ? true\n                                  : Number.isNaN(value)\n                              : type == String\n                                ? typeof value != \"string\"\n                                : typeof value != \"boolean\"\n                  }\n                : { value, error: true };\n\n/**\n * @param {(...args:any[])=>any} map\n * @param {(...args:any[])=>any} [serialize]\n * @returns {import(\"schema\").TypeCustom<(...args:any)=>any>}\n */\nexport const createType = (map, serialize) => ({\n    name: CUSTOM_TYPE_NAME,\n    map,\n    serialize\n});\n/**\n * Type any, used to avoid type validation.\n * @typedef {null} Any\n */\n\n/**\n * @typedef {Object} InternalEventInit\n * @property {typeof CustomEvent|typeof Event} [base] - Optional constructor to initialize the event\n * @property {boolean} [bubbles] - indicating whether the event bubbles. The default is false.\n * @property {boolean} [cancelable] - indicating whether the event will trigger listeners outside of a shadow root.\n * @property {boolean} [composed] - indicating whether the event will trigger listeners outside of a shadow root.\n * @property {any} [detail] - indicating whether the event will trigger listeners outside of a shadow root.\n */\n\n/**\n * Interface used by dispatchEvent to automate event firing\n * @typedef {Object} InternalEvent\n * @property {string} type - type of event to dispatch.\n */\n\n/**\n * @typedef {Object<string, {prop:string,type:Function}>} Attrs\n */\n\n/**\n * @typedef {Object<string, any>} Values\n */\n\n/**\n * @typedef {Object} Schema\n * @property {any} [type] - data type to be worked as property and attribute\n * @property {string} [attr] - allows customizing the name as an attribute by skipping the camelCase format\n * @property {boolean} [reflect] - reflects property as attribute of node\n * @property {InternalEvent & InternalEventInit} [event] - Allows to emit an event every time the property changes\n * @property {any} [value] - defines a default value when instantiating the component\n */\n", "import { createHooks } from \"../hooks/create-hooks.js\";\nimport { flat, isHydrate } from \"../utils.js\";\nimport { ParseError } from \"./errors.js\";\nimport { setPrototype, transformValue } from \"./set-prototype.js\";\nexport { Any, createType } from \"./set-prototype.js\";\n\nlet ID = 0;\n/**\n *\n * @param {Element & {dataset?:object}} node\n * @returns {string|number}\n */\nconst getHydrateId = (node) => {\n    const id = (node?.dataset || {})?.hydrate || \"\";\n    if (id) {\n        return id;\n    } else {\n        return \"c\" + ID++;\n    }\n};\n\n/**\n * @param {import(\"component\").Component} component\n * @param {CustomElementConstructor| import(\"component\").ComponentOptions} [options]\n */\nexport const c = (component, options = HTMLElement) => {\n    /**\n     * @type {import(\"./set-prototype.js\").Attrs}\n     */\n    const attrs = {};\n    /**\n     * @type {import(\"./set-prototype.js\").Values}\n     */\n    const values = {};\n\n    const withBase =\n        \"prototype\" in options && options.prototype instanceof Element;\n\n    const base = withBase\n        ? options\n        : \"base\" in options\n          ? options.base\n          : HTMLElement;\n\n    //@ts-ignore\n    const { props, styles } = withBase ? component : options;\n\n    /**\n     * @todo Discover a more aesthetic solution at the type level\n     * TS tries to set local class rules, these should be ignored\n     */\n    class AtomicoElement extends base {\n        constructor() {\n            super();\n            this._setup();\n            this._render = () => component({ ...this._props });\n            for (const prop in values) this[prop] = values[prop];\n        }\n        /**\n         * @returns {import(\"core\").Sheets[]}\n         */\n        static get styles() {\n            //@ts-ignore\n            return [super.styles, styles];\n        }\n        async _setup() {\n            // _setup only continues if _props has not been defined\n            if (this._props) return;\n\n            this._props = {};\n\n            /**\n             * @type {Node}\n             */\n            let mountParentNode;\n            /**\n             * @type {Node}\n             */\n            let unmountParentNode;\n\n            this.mounted = new Promise(\n                (resolve) =>\n                    (this.mount = () => {\n                        resolve();\n                        /**\n                         * You should always wait if the node has previously been dismounted before mounting to avoid:\n                         * 1. Deleting the rendered content by mistake enerated a cleanup effect.\n                         * 2. allow a deletion and new inclusion recycling of the node\n                         */\n                        if (mountParentNode != this.parentNode) {\n                            if (unmountParentNode != mountParentNode) {\n                                this.unmounted.then(this.update);\n                            } else {\n                                this.update();\n                            }\n                        }\n                        mountParentNode = this.parentNode;\n                    })\n            );\n\n            this.unmounted = new Promise(\n                (resolve) =>\n                    (this.unmount = () => {\n                        resolve();\n                        if (\n                            mountParentNode != this.parentNode ||\n                            !this.isConnected\n                        ) {\n                            hooks.cleanEffects(true)()();\n                            unmountParentNode = this.parentNode;\n                            mountParentNode = null;\n                        }\n                    })\n            );\n\n            this.symbolId = this.symbolId || Symbol();\n            this.symbolIdParent = Symbol();\n\n            const hooks = createHooks(\n                () => this.update(),\n                this,\n                getHydrateId(this)\n            );\n\n            let prevent;\n\n            let firstRender = true;\n\n            // some DOM emulators don't define dataset\n            const hydrate = isHydrate(this);\n\n            this.update = () => {\n                if (!prevent) {\n                    prevent = true;\n\n                    /**\n                     * this.updated is defined at the runtime of the render,\n                     * if it fails it is caught by mistake to unlock prevent\n                     */\n                    this.updated = (this.updated || this.mounted)\n                        .then(() => {\n                            try {\n                                const result = hooks.load(this._render);\n\n                                const cleanUseLayoutEffects =\n                                    hooks.cleanEffects();\n                                result &&\n                                    //@ts-ignore\n                                    result.render(this, this.symbolId, hydrate);\n\n                                prevent = false;\n\n                                if (firstRender && !hooks.isSuspense()) {\n                                    firstRender = false;\n                                    // @ts-ignore\n                                    !hydrate && applyStyles(this);\n                                }\n\n                                return cleanUseLayoutEffects();\n                            } finally {\n                                // Remove lock in case of synchronous error\n                                prevent = false;\n                            }\n                        })\n                        .then(\n                            /**\n                             * @param {import(\"internal/hooks.js\").CleanUseEffects} [cleanUseEffect]\n                             */\n                            (cleanUseEffect) => {\n                                cleanUseEffect && cleanUseEffect();\n                            }\n                        );\n                }\n\n                return this.updated;\n            };\n\n            this.update();\n        }\n        connectedCallback() {\n            this.mount();\n            //@ts-ignore\n            super.connectedCallback && super.connectedCallback();\n        }\n        disconnectedCallback() {\n            //@ts-ignore\n            super.disconnectedCallback && super.disconnectedCallback();\n            // The webcomponent will only resolve disconnected if it is\n            // actually disconnected of the document, otherwise it will keep the record.\n            this.unmount();\n        }\n        /**\n         * @this {import(\"dom\").AtomicoThisInternal}\n         * @param {string} attr\n         * @param {(string|null)} oldValue\n         * @param {(string|null)} value\n         */\n        attributeChangedCallback(attr, oldValue, value) {\n            if (attrs[attr]) {\n                // _ignoreAttr exists temporarily\n                // @ts-ignore\n                if (attr === this._ignoreAttr || oldValue === value) return;\n                // Choose the property name to send the update\n                const { prop, type } = attrs[attr];\n                // The following error cannot be caught\n                try {\n                    this[prop] = transformValue(type, value);\n                } catch (e) {\n                    throw new ParseError(\n                        this,\n                        `The value defined as attr '${attr}' cannot be parsed by type '${type.name}'`,\n                        value\n                    );\n                }\n            } else {\n                // If the attribute does not exist in the scope attrs, the event is sent to super\n                // @ts-ignore\n                super.attributeChangedCallback(attr, oldValue, value);\n            }\n        }\n\n        static get props() {\n            //@ts-ignore\n            return { ...super.props, ...props };\n        }\n\n        static get observedAttributes() {\n            // See if there is an observedAttributes declaration to match with the current one\n            // @ts-ignore\n            const superAttrs = super.observedAttributes || [];\n            for (const prop in props) {\n                setPrototype(this.prototype, prop, props[prop], attrs, values);\n            }\n            return Object.keys(attrs).concat(superAttrs);\n        }\n    }\n\n    return AtomicoElement;\n};\n\n/**\n * Attach the css to the shadowDom\n * @param {import(\"dom\").AtomicoThisInternal} host\n */\nfunction applyStyles(host) {\n    const { styles } = host.constructor;\n    const { shadowRoot } = host;\n    if (shadowRoot && styles.length) {\n        /**\n         * @type {CSSStyleSheet[]}\n         */\n        const sheets = [];\n        flat(styles, (value) => {\n            if (value) {\n                if (value instanceof Element) {\n                    shadowRoot.appendChild(value.cloneNode(true));\n                } else {\n                    sheets.push(value);\n                }\n            }\n        });\n        if (sheets.length) shadowRoot.adoptedStyleSheets = sheets;\n    }\n}\n", "import {\n    useHook,\n    IdLayoutEffect,\n    IdEffect,\n    IdInsertionEffect\n} from \"./create-hooks.js\";\nimport { isEqualArray, isFunction } from \"../utils.js\";\n\n/**\n * useLayoutEffect and useEffect have a similar algorithm\n * in that the position of the callback varies.\n * @param {IdLayoutEffect|IdEffect|IdInsertionEffect} type\n * @return {import(\"internal/hooks.js\").UseAnyEffect}\n */\nconst createEffect = (type) => (currentEffect, currentArgs) => {\n    useHook(\n        /**\n         * Clean the effect hook\n         * @type {import(\"internal/hooks.js\").CollectorEffect}\n         */\n\n        ([collector, args] = []) => {\n            if (args || !args) {\n                if (args && isEqualArray(args, currentArgs)) {\n                    collector = collector || true;\n                } else {\n                    // TS does not infer the following conditional\n                    // @ts-ignore\n                    isFunction(collector) && collector();\n                    collector = null;\n                }\n            }\n            return [collector, currentArgs];\n        },\n        /**\n         * @returns {any}\n         */\n        ([collector, args], unmounted) => {\n            if (unmounted) {\n                // ts does not infer the following conditional\n                isFunction(collector) && collector();\n                return [];\n            } else {\n                return [collector ? collector : currentEffect(), args];\n            }\n        },\n        type\n    );\n};\n\nexport const useLayoutEffect = createEffect(IdLayoutEffect);\n\nexport const useEffect = createEffect(IdEffect);\n\nexport const useInsertionEffect = createEffect(IdInsertionEffect);\n", "export class State extends Array {\n    /**\n     *\n     * @param {any} initialState\n     * @param {(nextState: any, state:any[], mount: boolean )=>void} mapState\n     */\n    constructor(initialState, mapState) {\n        let mount = true;\n        /**\n         *\n         * @param {any} nextState\n         */\n        const setState = (nextState) => {\n            try {\n                mapState(nextState, this, mount);\n            } finally {\n                mount = false;\n            }\n        };\n        super(undefined, setState, mapState);\n        setState(initialState);\n    }\n    /**\n     * The following code allows a mutable approach to useState\n     * and useProp this with the idea of allowing an alternative\n     * approach similar to Vue or Qwik of state management\n     * @todo pending review with the community\n     */\n    // get value() {\n    //     return this[0];\n    // }\n    // set value(nextState) {\n    //     this[2](nextState, this);\n    // }\n}\n", "import { useHook, useUpdate } from \"./create-hooks.js\";\n\nimport { isEqualArray, isFunction } from \"../utils.js\";\n\nexport * from \"./use-effect.js\";\nimport { State } from \"./state.js\";\n\n/**\n * Create a persistent local state\n * @type {import(\"core\").UseState}\n */\nexport const useState = (initialState) => {\n    // retrieve the render to request an update\n    const update = useUpdate();\n    return useHook(\n        (\n            state = new State(initialState, (nextState, state, mount) => {\n                nextState = isFunction(nextState)\n                    ? nextState(state[0])\n                    : nextState;\n                if (nextState !== state[0]) {\n                    state[0] = nextState;\n                    // Escape from the first execution\n                    if (!mount) update();\n                }\n            })\n        ) => state\n    );\n};\n\n/**\n * Memorize the return of a callback\n * @type {import(\"core\").UseMemo}\n */\nexport const useMemo = (currentMemo, currentArgs) => {\n    const [state] = useHook(([state, args, cycle = 0] = []) => {\n        if (!args || (args && !isEqualArray(args, currentArgs))) {\n            state = currentMemo();\n        }\n        return [state, currentArgs, cycle];\n    });\n    return state;\n};\n\n/**\n * Apply the redux pattern as a hook\n * @type {import(\"core\").UseReducer}\n */\nexport const useReducer = (reducer, initialArg, init) => {\n    const update = useUpdate();\n    return useHook((state = []) => {\n        if (!state[1]) {\n            state[0] = init !== undefined ? init(initialArg) : initialArg;\n            state[1] = (action) => {\n                const nextState = reducer(state[0], action);\n                if (nextState != state[0]) {\n                    state[0] = nextState;\n                    update();\n                }\n            };\n        }\n        return state;\n    });\n};\n\n/**\n * Memorize a callback allowing it to remember the scope\n * variables regardless of the render\n * @type {import(\"core\").UseCallback}\n */\nexport const useCallback = (callback, args) => useMemo(() => callback, args);\n", "import { SymbolFor } from \"./utils.js\";\n\nconst ID = SymbolFor(\"atomico/options\");\n\nglobalThis[ID] = globalThis[ID] || {\n    sheet: !!document.adoptedStyleSheets\n};\n\n/**\n * @type {import(\"core\").Options}\n */\nexport const options = globalThis[ID];\n", "import { options } from \"./options.js\";\nimport { addListener } from \"./utils.js\";\n\nexport const DOMLoaded = new Promise((resolve) => {\n    if (!options.ssr) {\n        if (document.readyState === \"loading\") {\n            addListener(document, \"DOMContentLoaded\", resolve);\n        } else {\n            resolve();\n        }\n    }\n});\n", "import { options } from \"./options.js\";\nimport {\n    SymbolFor,\n    flat,\n    isArray,\n    isFunction,\n    isHydrate,\n    isObject\n} from \"./utils.js\";\n\n// Object used to know which properties are extracted directly\n// from the node to verify 2 if they have changed\nconst VAL_FROM_PROPS = {\n    checked: 1,\n    value: 1,\n    selected: 1\n};\n// Map of attributes that escape the property analysis\nconst PROPS_AS_ATTRS = {\n    list: 1,\n    type: 1,\n    size: 1,\n    form: 1,\n    width: 1,\n    height: 1,\n    src: 1,\n    href: 1,\n    slot: 1\n};\n// escapes from diffProps compare process\nconst INTERNAL_PROPS = {\n    shadowDom: 1,\n    staticNode: 1,\n    cloneNode: 1,\n    children: 1,\n    key: 1\n};\n\n// Immutable for comparison of empty properties\nconst EMPTY_PROPS = {};\n// Immutable for empty children comparison\nconst EMPTY_CHILDREN = [];\n// Fragment marker\nexport class Mark extends Text {}\n\n// Default ID used to store the Vnode state\nexport const ID = SymbolFor(\"atomico/id\");\n\nexport const TYPE = SymbolFor(\"atomico/type\");\n\nexport const TYPE_NODE = SymbolFor(\"atomico/ref\");\n\nexport const TYPE_VNODE = SymbolFor(\"atomico/vnode\");\n\nexport const Fragment = () => {};\n\n/**\n * @param {Element} node\n * @param {import(\"vnode\").RenderId} [id]\n * @param {boolean} [hydrate]\n * @return {ChildNode}\n */\nexport function RENDER(node, id, hydrate) {\n    return diff(this, node, id, hydrate);\n}\n/**\n * @type {import(\"vnode\").H}\n */\nexport const h = (type, p, ...args) => {\n    /**\n     * @type {any}\n     */\n    const props = p || EMPTY_PROPS;\n\n    let { children } = props;\n\n    children =\n        children != null ? children : args.length ? args : EMPTY_CHILDREN;\n\n    if (type === Fragment) {\n        //@ts-ignore\n        return children;\n    }\n\n    const raw = type\n        ? type instanceof Node\n            ? 1\n            : //@ts-ignore\n              type.prototype instanceof HTMLElement && 2\n        : 0;\n\n    //@ts-ignore\n    if (raw === false && type instanceof Function) {\n        return type(\n            children != EMPTY_CHILDREN ? { children, ...props } : props\n        );\n    }\n\n    /**\n     * @todo look for a more elegant type, since you can't follow the type rules without capturing this\n     * @type {any}\n     */\n    const render = options.render || RENDER;\n\n    /**\n     * @type {import(\"vnode\").VNodeAny}\n     */\n    const vnode = {\n        [TYPE]: TYPE_VNODE,\n        type,\n        props,\n        children,\n        key: props.key,\n        // key for lists by keys\n        // define if the node declares its shadowDom\n        shadow: props.shadowDom,\n        // allows renderings to run only once\n        static: props.staticNode,\n        // defines whether the type is a childNode `1` or a constructor `2`\n        raw,\n        // defines whether to use the second parameter for document.createElement\n        is: props.is,\n        // clone the node if it comes from a reference\n        clone: props.cloneNode,\n        render\n    };\n\n    //@ts-ignore\n    return vnode;\n};\n\n/**\n * Create or update a node\n * Node: The declaration of types through JSDOC does not allow to compress\n * the exploration of the parameters\n * @param {ReturnType<h>} newVnode\n * @param {Element} node\n * @param {import(\"vnode\").RenderId} [id]\n * @param {boolean} [hydrate]\n * @param {boolean} [isSvg]\n * @returns {ChildNode}\n */\nfunction diff(newVnode, node, id = ID, hydrate, isSvg) {\n    let isNewNode;\n    // If the node maintains the source vnode it escapes from the update tree\n    if (\n        (node && node[id] && node[id].vnode == newVnode) ||\n        newVnode[TYPE] != TYPE_VNODE\n    )\n        return node;\n    // The process only continues when you may need to create a node\n    if (newVnode || !node) {\n        isSvg = isSvg || newVnode.type == \"svg\";\n        // determines if the node should be regenerated\n        isNewNode =\n            newVnode.type != \"host\" &&\n            (newVnode.raw == 1\n                ? (node && newVnode.clone ? node[TYPE_NODE] : node) !=\n                  newVnode.type\n                : newVnode.raw == 2\n                  ? !(node instanceof newVnode.type)\n                  : node\n                    ? node[TYPE_NODE] || node.localName != newVnode.type\n                    : !node);\n\n        if (isNewNode && newVnode.type != null) {\n            if (newVnode.raw == 1 && newVnode.clone) {\n                hydrate = true;\n                node = newVnode.type.cloneNode(true);\n                node[TYPE_NODE] = newVnode.type;\n            } else {\n                node =\n                    newVnode.raw == 1\n                        ? newVnode.type\n                        : newVnode.raw == 2\n                          ? new newVnode.type()\n                          : isSvg\n                            ? document.createElementNS(\n                                  \"http://www.w3.org/2000/svg\",\n                                  newVnode.type\n                              )\n                            : document.createElement(\n                                  newVnode.type,\n                                  newVnode.is ? { is: newVnode.is } : undefined\n                              );\n            }\n        }\n    }\n\n    const oldVNodeStore = node[id] ? node[id] : EMPTY_PROPS;\n\n    /**\n     * @type {import(\"vnode\").VNodeStore}\n     */\n    const { vnode = EMPTY_PROPS, cycle = 0 } = oldVNodeStore;\n\n    let { fragment, handlers } = oldVNodeStore;\n\n    /**\n     * @type {import(\"vnode\").VNodeGeneric}\n     */\n    const { children = EMPTY_CHILDREN, props = EMPTY_PROPS } = vnode;\n\n    /**\n     * @type {import(\"vnode\").Handlers}\n     */\n    handlers = isNewNode ? {} : handlers || {};\n    /**\n     * Escape a second render if the vnode.type is equal\n     */\n    if (newVnode.static && !isNewNode) return node;\n\n    newVnode.shadow &&\n        !node.shadowRoot &&\n        // @ts-ignore\n        node.attachShadow({ mode: \"open\", ...newVnode.shadow });\n\n    newVnode.props != props &&\n        diffProps(node, props, newVnode.props, handlers, isSvg);\n\n    if (newVnode.children !== children) {\n        const nextParent = newVnode.shadow ? node.shadowRoot : node;\n\n        fragment = renderChildren(\n            newVnode.children,\n            /**\n             * @todo for hydration use attribute and send childNodes\n             */\n            fragment,\n            nextParent,\n            id,\n            // add support to foreignObject, children will escape from svg\n            !cycle && hydrate,\n            isSvg && newVnode.type == \"foreignObject\" ? false : isSvg\n        );\n    }\n\n    node[id] = { vnode: newVnode, handlers, fragment, cycle: cycle + 1 };\n\n    return node;\n}\n/**\n *\n * @param {Element|ShadowRoot} parent\n * @param {boolean} [hydrate]\n * @return {import(\"vnode\").Fragment}\n */\nfunction createFragment(parent, hydrate) {\n    const markStart = new Mark(\"\");\n    const markEnd = new Mark(\"\");\n\n    /**\n     * @type {Element}\n     */\n    let node;\n\n    parent[hydrate ? \"prepend\" : \"append\"](markStart);\n\n    if (hydrate) {\n        let { lastElementChild } = parent;\n        while (lastElementChild) {\n            const { previousElementSibling } = lastElementChild;\n            if (\n                isHydrate(lastElementChild, true) &&\n                !isHydrate(previousElementSibling, true)\n            ) {\n                node = lastElementChild;\n                break;\n            }\n            lastElementChild = previousElementSibling;\n        }\n    }\n\n    if (node) {\n        node.before(markEnd);\n    } else {\n        parent.append(markEnd);\n    }\n\n    return {\n        markStart,\n        markEnd\n    };\n}\n\n/**\n * This method should only be executed from render,\n * it allows rendering the children of the virtual-dom\n * @param {any} children\n * @param {import(\"vnode\").Fragment} fragment\n * @param {Element|ShadowRoot} parent\n * @param {any} id\n * @param {boolean} [hydrate]\n * @param {boolean} [isSvg]\n */\nexport function renderChildren(children, fragment, parent, id, hydrate, isSvg) {\n    children =\n        children == null ? null : isArray(children) ? children : [children];\n\n    const nextFragment = fragment || createFragment(parent, hydrate);\n\n    const { markStart, markEnd, keyes } = nextFragment;\n    /**\n     * @type {import(\"vnode\").Keyes}\n     */\n    let nextKeyes;\n    /**\n     * Eliminate intermediate nodes that are not used in the process in keyed\n     * @type {Set<ChildNode>}\n     */\n    const removeNodes = keyes && new Set();\n\n    /**\n     * RULES: that you should never exceed \"c\"\n     * @type {ChildNode}\n     */\n    let currentNode = markStart;\n\n    children &&\n        flat(children, (child) => {\n            if (typeof child == \"object\" && !child[TYPE]) {\n                return;\n            }\n\n            const key = child[TYPE] && child.key;\n            const childKey = keyes && key != null && keyes.get(key);\n            // check if the displacement affected the index of the child with\n            // assignment of key, if so the use of nextSibling is prevented\n            if (currentNode != markEnd && currentNode === childKey) {\n                removeNodes.delete(currentNode);\n            } else {\n                currentNode =\n                    currentNode == markEnd ? markEnd : currentNode.nextSibling;\n            }\n\n            const childNode = keyes ? childKey : currentNode;\n\n            let nextChildNode = childNode;\n            // text node diff\n            if (!child[TYPE]) {\n                const text = child + \"\";\n                if (\n                    !(nextChildNode instanceof Text) ||\n                    nextChildNode instanceof Mark\n                ) {\n                    nextChildNode = new Text(text);\n                }\n                // Only one Text node falls in this block\n                // @ts-ignore\n                else if (nextChildNode.data != text) {\n                    // @ts-ignore\n                    nextChildNode.data = text;\n                }\n            } else {\n                // diff only resive Elements\n                // @ts-ignore\n                nextChildNode = diff(child, childNode, id, hydrate, isSvg);\n            }\n            if (nextChildNode != currentNode) {\n                keyes && removeNodes.delete(nextChildNode);\n                if (!childNode || keyes) {\n                    parent.insertBefore(nextChildNode, currentNode);\n\n                    keyes &&\n                        currentNode != markEnd &&\n                        removeNodes.add(currentNode);\n                } else if (childNode == markEnd) {\n                    parent.insertBefore(nextChildNode, markEnd);\n                } else {\n                    parent.replaceChild(nextChildNode, childNode);\n                    currentNode = nextChildNode;\n                }\n            }\n            // if there is a key, a map of keys is created\n            if (key != null) {\n                nextKeyes = nextKeyes || new Map();\n                nextKeyes.set(key, nextChildNode);\n            }\n        });\n\n    currentNode = currentNode == markEnd ? markEnd : currentNode.nextSibling;\n\n    if (fragment && currentNode != markEnd) {\n        // cleaning of remnants within the fragment\n        while (currentNode != markEnd) {\n            const nodeToRemove = currentNode;\n            currentNode = currentNode.nextSibling;\n            nodeToRemove.remove();\n        }\n    }\n\n    removeNodes && removeNodes.forEach((node) => node.remove());\n\n    nextFragment.keyes = nextKeyes;\n\n    return nextFragment;\n}\n\n/**\n *\n * @param {Element} node\n * @param {Object} props\n * @param {Object} nextProps\n * @param {boolean} isSvg\n * @param {import(\"vnode\").Handlers} handlers\n **/\nexport function diffProps(node, props, nextProps, handlers, isSvg) {\n    for (const key in props) {\n        !(key in nextProps) &&\n            setProperty(node, key, props[key], null, isSvg, handlers);\n    }\n    for (const key in nextProps) {\n        setProperty(node, key, props[key], nextProps[key], isSvg, handlers);\n    }\n}\n\n/**\n *\n * @param {Element|HTMLSlotElement} node\n * @param {string} key\n * @param {any} prevValue\n * @param {any} nextValue\n * @param {boolean} isSvg\n * @param {import(\"vnode\").Handlers} handlers\n */\nexport function setProperty(node, key, prevValue, nextValue, isSvg, handlers) {\n    key = key == \"class\" && !isSvg ? \"className\" : key;\n    // define empty value\n    prevValue = prevValue == null ? null : prevValue;\n    nextValue = nextValue == null ? null : nextValue;\n\n    if (key in node && VAL_FROM_PROPS[key]) {\n        prevValue = node[key];\n    }\n\n    if (nextValue === prevValue || INTERNAL_PROPS[key] || key[0] == \"_\") return;\n\n    if (node.localName === \"slot\" && key === \"assignNode\" && \"assign\" in node) {\n        node.assign(nextValue);\n    } else if (\n        key[0] == \"o\" &&\n        key[1] == \"n\" &&\n        (isFunction(nextValue) || isFunction(prevValue))\n    ) {\n        setEvent(node, key.slice(2), nextValue, handlers);\n    } else if (key == \"ref\") {\n        if (nextValue) {\n            if (isFunction(nextValue)) {\n                nextValue(node);\n            } else {\n                nextValue.current = node;\n            }\n        }\n    } else if (key == \"style\") {\n        /**\n         * @todo Find out why Element defines style at the type level\n         * @type {any}\n         */\n        const { style } = node;\n\n        prevValue = prevValue || \"\";\n        nextValue = nextValue || \"\";\n\n        const prevIsObject = isObject(prevValue);\n        const nextIsObject = isObject(nextValue);\n\n        if (prevIsObject) {\n            for (const key in prevValue) {\n                if (nextIsObject) {\n                    !(key in nextValue) && setPropertyStyle(style, key, null);\n                } else {\n                    break;\n                }\n            }\n        }\n\n        if (nextIsObject) {\n            for (const key in nextValue) {\n                const value = nextValue[key];\n                if (prevIsObject && prevValue[key] === value) continue;\n                setPropertyStyle(style, key, value);\n            }\n        } else {\n            style.cssText = nextValue;\n        }\n    } else {\n        const attr = key[0] == \"$\" ? key.slice(1) : key;\n        if (\n            attr === key &&\n            ((!isSvg && !PROPS_AS_ATTRS[key] && key in node) ||\n                isFunction(nextValue) ||\n                isFunction(prevValue))\n        ) {\n            node[key] = nextValue == null ? \"\" : nextValue;\n        } else if (nextValue == null) {\n            node.removeAttribute(attr);\n        } else {\n            node.setAttribute(\n                attr,\n                isObject(nextValue) ? JSON.stringify(nextValue) : nextValue\n            );\n        }\n    }\n}\n\n/**\n *\n * @param {Node} node\n * @param {string} type\n * @param {import(\"vnode\").VNodeListener} [nextHandler]\n * @param {import(\"vnode\").Handlers} [handlers]\n */\nexport function setEvent(node, type, nextHandler, handlers) {\n    // add handleEvent to handlers\n    if (!handlers.handleEvent) {\n        /**\n         * {@link https://developer.mozilla.org/es/docs/Web/API/EventTarget/addEventListener#The_value_of_this_within_the_handler}\n         **/\n        handlers.handleEvent = (event) =>\n            handlers[event.type].call(node, event);\n    }\n    if (nextHandler) {\n        // create the subscriber if it does not exist\n        if (!handlers[type]) {\n            //the event configuration is only subscribed at the time of association\n            const options =\n                nextHandler.capture || nextHandler.once || nextHandler.passive\n                    ? Object.assign({}, nextHandler)\n                    : null;\n            node.addEventListener(type, handlers, options);\n        }\n        // update the associated event\n        handlers[type] = nextHandler;\n    } else {\n        // \tdelete the associated event\n        if (handlers[type]) {\n            node.removeEventListener(type, handlers);\n            delete handlers[type];\n        }\n    }\n}\n/**\n *\n * @param {*} style\n * @param {string} key\n * @param {string} value\n */\nexport function setPropertyStyle(style, key, value) {\n    let method = \"setProperty\";\n    if (value == null) {\n        method = \"removeProperty\";\n        value = null;\n    }\n    if (~key.indexOf(\"-\")) {\n        style[method](key, value);\n    } else {\n        style[key] = value;\n    }\n}\n\nexport { diff as render };\n", "import { options } from \"./options.js\";\nimport { c } from \"./element/custom-element.js\";\nimport { useHost, useRef, useUpdate } from \"./hooks/create-hooks.js\";\nimport { useEvent } from \"./hooks/custom-hooks/use-event.js\";\nimport { useEffect, useInsertionEffect, useState } from \"./hooks/hooks.js\";\nimport { DOMLoaded } from \"./loaded.js\";\nimport { h } from \"./render.js\";\nimport { addListener } from \"./utils.js\";\n\nconst CONTEXT_TEMPLATE = h(\"host\", { style: \"display: contents\" });\n\nconst CONTEXT_VALUE = \"value\";\n\n/**\n * @type {import(\"context\").UseProvider}\n */\nexport const useProvider = (id, value) => {\n    const host = useHost();\n\n    const ref = useRef();\n\n    useInsertionEffect(\n        () =>\n            addListener(\n                host.current,\n                \"ConnectContext\",\n                /**\n                 * @param {CustomEvent<import(\"context\").DetailConnectContext>} event\n                 */\n                (event) => {\n                    const target = event.composedPath().at(0);\n                    if (\n                        target !== event.currentTarget &&\n                        id === event.detail.id\n                    ) {\n                        event.stopPropagation();\n                        event.detail.connect(ref);\n                    }\n                }\n            ),\n        [id]\n    );\n\n    ref.current = value;\n};\n\n/**\n *\n * @type {import(\"context\").UseContext}\n */\nexport const useContext = (id) => {\n    const dispatch = useEvent(\"ConnectContext\", {\n        bubbles: true,\n        composed: true\n    });\n\n    const [parentContext, setParentContext] = useState(() => {\n        if (options.ssr) return;\n        /**\n         * @type {import(\"core\").Ref}\n         */\n        let currentParentContext;\n        dispatch({\n            id,\n            /**\n             * @param {import(\"core\").Ref} parentContext\n             */\n            connect(parentContext) {\n                currentParentContext = parentContext;\n            }\n        });\n        return currentParentContext;\n    });\n\n    const update = useUpdate();\n\n    useEffect(() => {\n        DOMLoaded.then(() =>\n            dispatch({\n                id,\n                connect: setParentContext\n            })\n        );\n    }, [id]);\n\n    useEffect(() => {\n        if (!parentContext) return;\n        return parentContext.on(update);\n    }, [parentContext]);\n\n    return parentContext?.current || id[CONTEXT_VALUE];\n};\n\n/**\n * @type {import(\"context\").CreateContext}\n */\nexport const createContext = (value) => {\n    /**\n     * @todo Discover a more aesthetic solution at the type level\n     * TS tries to set local class rules, these should be ignored\n     * @type {any}\n     */\n    const Context = c(\n        ({ value }) => {\n            useProvider(Context, value);\n            return CONTEXT_TEMPLATE;\n        },\n        {\n            props: {\n                value: {\n                    type: Object,\n                    value: () => value\n                }\n            }\n        }\n    );\n\n    Context[CONTEXT_VALUE] = value;\n\n    return Context;\n};\n", "import { useMemo, useState } from \"../hooks.js\";\nimport { createContext, useProvider } from \"../../context.js\";\n\nexport const SuspenseEvent = {\n    pending: \"PendingSuspense\",\n    fulfilled: \"FulfilledSuspense\",\n    rejected: \"RejectedSuspense\",\n    aborted: \"AbortedSuspense\"\n};\n\nexport const SuspenseContext = createContext({\n    /**\n     *\n     * @param {string} type\n     * @param {string} id\n     */\n    dispatch(type, id) {}\n});\n\n/**\n *\n * @type {import(\"core\").UseSuspense}\n */\n\nexport const useSuspense = (fps = 8) => {\n    /**\n     * @type {import(\"internal/hooks.js\").ReturnSetStateUseSuspense}\n     */\n    const [status, setStatus] = useState({ pending: true });\n\n    /**\n     *\n     * @param {()=>any} callback\n     * @param {number} deep\n     */\n    const delay = (callback, deep) =>\n        requestAnimationFrame(() =>\n            deep ? delay(callback, --deep) : callback()\n        );\n\n    const context = useMemo(() => {\n        const values = new Set();\n        let prevent = false;\n        let rejected = false;\n        let aborted = false;\n\n        /**\n         * Check if tasks are pending at the DOM tree level.\n         */\n        const progress = () => {\n            if (!prevent) {\n                prevent = true;\n                delay(() => {\n                    prevent = false;\n                    setStatus((state) =>\n                        values.size\n                            ? state.pending\n                                ? state\n                                : { pending: true }\n                            : aborted\n                              ? state.aborted\n                                  ? state\n                                  : { aborted }\n                              : rejected\n                                ? state.rejected\n                                    ? state\n                                    : { rejected }\n                                : state.fulfilled\n                                  ? state\n                                  : { fulfilled: true }\n                    );\n                }, fps);\n            }\n        };\n        /**\n         *\n         * @param {string} type\n         * @param {string} id\n         */\n        const dispatch = (type, id) => {\n            if (type === SuspenseEvent.pending) {\n                values.add(id);\n                progress();\n            } else if (values.has(id)) {\n                values.delete(id);\n                if (type === SuspenseEvent.fulfilled) {\n                } else if (type === SuspenseEvent.aborted) {\n                    aborted = true;\n                } else {\n                    rejected = true;\n                }\n                progress();\n            }\n        };\n\n        return { dispatch };\n    }, []);\n\n    useProvider(SuspenseContext, context);\n\n    return status;\n};\n", "import { createElement } from './src/core.js';\n\nconst MODE_SLASH = 0;\nconst MODE_TEXT = 1;\nconst MODE_WHITESPACE = 2;\nconst MODE_TAGNAME = 3;\nconst MODE_COMMENT = 4;\nconst MODE_PROP_SET = 5;\nconst MODE_PROP_APPEND = 6;\n\nconst CHILD_APPEND = 0;\nconst CHILD_RECURSE = 2;\nconst TAG_SET = 3;\nconst PROPS_ASSIGN = 4;\nconst PROP_SET = MODE_PROP_SET;\nconst PROP_APPEND = MODE_PROP_APPEND;\n\nconst evaluate = (h, built, fields, args) => {\n\tlet tmp;\n\n\t// `build()` used the first element of the operation list as\n\t// temporary workspace. Now that `build()` is done we can use\n\t// that space to track whether the current element is \"dynamic\"\n\t// (i.e. it or any of its descendants depend on dynamic values).\n\tbuilt[0] = 0;\n\n\tfor (let i = 1; i < built.length; i++) {\n\t\tconst type = built[i++];\n\n\t\t// Set `built[0]`'s appropriate bits if this element depends on a dynamic value.\n\t\tconst value = built[i] ? ((built[0] |= type ? 1 : 2), fields[built[i++]]) : built[++i];\n\n\t\tif (type === TAG_SET) {\n\t\t\targs[0] = value;\n\t\t}\n\t\telse if (type === PROPS_ASSIGN) {\n\t\t\targs[1] = Object.assign(args[1] || {}, value);\n\t\t}\n\t\telse if (type === PROP_SET) {\n\t\t\t(args[1] = args[1] || {})[built[++i]] = value;\n\t\t}\n\t\telse if (type === PROP_APPEND) {\n\t\t\targs[1][built[++i]] += (value + '');\n\t\t}\n\t\telse if (type) { // type === CHILD_RECURSE\n\t\t\t// Set the operation list (including the staticness bits) as\n\t\t\t// `this` for the `h` call.\n\t\t\ttmp = h.apply(value, evaluate(h, value, fields, ['', null]));\n\t\t\targs.push(tmp);\n\n\t\t\tif (value[0]) {\n\t\t\t\t// Set the 2nd lowest bit it the child element is dynamic.\n\t\t\t\tbuilt[0] |= 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Rewrite the operation list in-place if the child element is static.\n\t\t\t\t// The currently evaluated piece `CHILD_RECURSE, 0, [...]` becomes\n\t\t\t\t// `CHILD_APPEND, 0, tmp`.\n\t\t\t\t// Essentially the operation list gets optimized for potential future\n\t\t\t\t// re-evaluations.\n\t\t\t\tbuilt[i-2] = CHILD_APPEND;\n\t\t\t\tbuilt[i] = tmp;\n\t\t\t}\n\t\t}\n\t\telse { // type === CHILD_APPEND\n\t\t\targs.push(value);\n\t\t}\n\t}\n\n\treturn args;\n};\n\nconst build = function(statics) {\n\n\tlet mode = MODE_TEXT;\n\tlet buffer = '';\n\tlet quote = '';\n\tlet current = [0];\n\tlet char, propName;\n\n\tconst commit = field => {\n\t\tif (mode === MODE_TEXT && (field || (buffer = buffer.replace(/^\\s*\\n\\s*|\\s*\\n\\s*$/g,'')))) {\n\t\t\t{\n\t\t\t\tcurrent.push(CHILD_APPEND, field, buffer);\n\t\t\t}\n\t\t}\n\t\telse if (mode === MODE_TAGNAME && (field || buffer)) {\n\t\t\t{\n\t\t\t\tcurrent.push(TAG_SET, field, buffer);\n\t\t\t}\n\t\t\tmode = MODE_WHITESPACE;\n\t\t}\n\t\telse if (mode === MODE_WHITESPACE && buffer === '...' && field) {\n\t\t\t{\n\t\t\t\tcurrent.push(PROPS_ASSIGN, field, 0);\n\t\t\t}\n\t\t}\n\t\telse if (mode === MODE_WHITESPACE && buffer && !field) {\n\t\t\t{\n\t\t\t\tcurrent.push(PROP_SET, 0, true, buffer);\n\t\t\t}\n\t\t}\n\t\telse if (mode >= MODE_PROP_SET) {\n\t\t\t{\n\t\t\t\tif (buffer || (!field && mode === MODE_PROP_SET)) {\n\t\t\t\t\tcurrent.push(mode, 0, buffer, propName);\n\t\t\t\t\tmode = MODE_PROP_APPEND;\n\t\t\t\t}\n\t\t\t\tif (field) {\n\t\t\t\t\tcurrent.push(mode, field, 0, propName);\n\t\t\t\t\tmode = MODE_PROP_APPEND;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbuffer = '';\n\t};\n\n\tfor (let i=0; i<statics.length; i++) {\n\t\tif (i) {\n\t\t\tif (mode === MODE_TEXT) {\n\t\t\t\tcommit();\n\t\t\t}\n\t\t\tcommit(i);\n\t\t}\n\n\t\tfor (let j=0; j<statics[i].length;j++) {\n\t\t\tchar = statics[i][j];\n\n\t\t\tif (mode === MODE_TEXT) {\n\t\t\t\tif (char === '<') {\n\t\t\t\t\t// commit buffer\n\t\t\t\t\tcommit();\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrent = [current];\n\t\t\t\t\t}\n\t\t\t\t\tmode = MODE_TAGNAME;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer += char;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mode === MODE_COMMENT) {\n\t\t\t\t// Ignore everything until the last three characters are '-', '-' and '>'\n\t\t\t\tif (buffer === '--' && char === '>') {\n\t\t\t\t\tmode = MODE_TEXT;\n\t\t\t\t\tbuffer = '';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer = char + buffer[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (quote) {\n\t\t\t\tif (char === quote) {\n\t\t\t\t\tquote = '';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer += char;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (char === '\"' || char === \"'\") {\n\t\t\t\tquote = char;\n\t\t\t}\n\t\t\telse if (char === '>') {\n\t\t\t\tcommit();\n\t\t\t\tmode = MODE_TEXT;\n\t\t\t}\n\t\t\telse if (!mode) ;\n\t\t\telse if (char === '=') {\n\t\t\t\tmode = MODE_PROP_SET;\n\t\t\t\tpropName = buffer;\n\t\t\t\tbuffer = '';\n\t\t\t}\n\t\t\telse if (char === '/' && (mode < MODE_PROP_SET || statics[i][j+1] === '>')) {\n\t\t\t\tcommit();\n\t\t\t\tif (mode === MODE_TAGNAME) {\n\t\t\t\t\tcurrent = current[0];\n\t\t\t\t}\n\t\t\t\tmode = current;\n\t\t\t\t{\n\t\t\t\t\t(current = current[0]).push(CHILD_RECURSE, 0, mode);\n\t\t\t\t}\n\t\t\t\tmode = MODE_SLASH;\n\t\t\t}\n\t\t\telse if (char === ' ' || char === '\\t' || char === '\\n' || char === '\\r') {\n\t\t\t\t// <a disabled>\n\t\t\t\tcommit();\n\t\t\t\tmode = MODE_WHITESPACE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuffer += char;\n\t\t\t}\n\n\t\t\tif (mode === MODE_TAGNAME && buffer === '!--') {\n\t\t\t\tmode = MODE_COMMENT;\n\t\t\t\tcurrent = current[0];\n\t\t\t}\n\t\t}\n\t}\n\tcommit();\n\treturn current;\n};\n\nconst CACHE = new Map();\n\nfunction html(statics) {\n    let tmp = CACHE;\n\n    tmp = evaluate(\n        createElement,\n        tmp.get(statics) || (tmp.set(statics, (tmp = build(statics))), tmp),\n        arguments,\n        []\n    );\n\n    return tmp.length > 1 ? tmp : tmp[0];\n}\n\nexport { html };\n"],
  "mappings": "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",
  "names": ["list", "ID", "options", "state", "ID", "ID", "key", "options", "value", "h"]
}

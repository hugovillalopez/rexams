{
  "version": 3,
  "sources": ["../../prosemirror-inputrules/dist/index.js"],
  "sourcesContent": ["import { Plugin } from 'prosemirror-state';\r\nimport { findWrapping, canJoin } from 'prosemirror-transform';\r\n\r\n/**\r\nInput rules are regular expressions describing a piece of text\r\nthat, when typed, causes something to happen. This might be\r\nchanging two dashes into an emdash, wrapping a paragraph starting\r\nwith `\"> \"` into a blockquote, or something entirely different.\r\n*/\r\nclass InputRule {\r\n    // :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number) → ?Transaction>)\r\n    /**\r\n    Create an input rule. The rule applies when the user typed\r\n    something and the text directly in front of the cursor matches\r\n    `match`, which should end with `$`.\r\n    \r\n    The `handler` can be a string, in which case the matched text, or\r\n    the first matched group in the regexp, is replaced by that\r\n    string.\r\n    \r\n    Or a it can be a function, which will be called with the match\r\n    array produced by\r\n    [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),\r\n    as well as the start and end of the matched range, and which can\r\n    return a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the\r\n    rule's effect, or null to indicate the input was not handled.\r\n    */\r\n    constructor(\r\n    /**\r\n    @internal\r\n    */\r\n    match, handler, options = {}) {\r\n        this.match = match;\r\n        this.match = match;\r\n        this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler;\r\n        this.undoable = options.undoable !== false;\r\n        this.inCode = options.inCode || false;\r\n    }\r\n}\r\nfunction stringHandler(string) {\r\n    return function (state, match, start, end) {\r\n        let insert = string;\r\n        if (match[1]) {\r\n            let offset = match[0].lastIndexOf(match[1]);\r\n            insert += match[0].slice(offset + match[1].length);\r\n            start += offset;\r\n            let cutOff = start - end;\r\n            if (cutOff > 0) {\r\n                insert = match[0].slice(offset - cutOff, offset) + insert;\r\n                start = end;\r\n            }\r\n        }\r\n        return state.tr.insertText(insert, start, end);\r\n    };\r\n}\r\nconst MAX_MATCH = 500;\r\n/**\r\nCreate an input rules plugin. When enabled, it will cause text\r\ninput that matches any of the given rules to trigger the rule's\r\naction.\r\n*/\r\nfunction inputRules({ rules }) {\r\n    let plugin = new Plugin({\r\n        state: {\r\n            init() { return null; },\r\n            apply(tr, prev) {\r\n                let stored = tr.getMeta(this);\r\n                if (stored)\r\n                    return stored;\r\n                return tr.selectionSet || tr.docChanged ? null : prev;\r\n            }\r\n        },\r\n        props: {\r\n            handleTextInput(view, from, to, text) {\r\n                return run(view, from, to, text, rules, plugin);\r\n            },\r\n            handleDOMEvents: {\r\n                compositionend: (view) => {\r\n                    setTimeout(() => {\r\n                        let { $cursor } = view.state.selection;\r\n                        if ($cursor)\r\n                            run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin);\r\n                    });\r\n                }\r\n            }\r\n        },\r\n        isInputRules: true\r\n    });\r\n    return plugin;\r\n}\r\nfunction run(view, from, to, text, rules, plugin) {\r\n    if (view.composing)\r\n        return false;\r\n    let state = view.state, $from = state.doc.resolve(from);\r\n    let textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset, null, \"\\ufffc\") + text;\r\n    for (let i = 0; i < rules.length; i++) {\r\n        let rule = rules[i];\r\n        if ($from.parent.type.spec.code) {\r\n            if (!rule.inCode)\r\n                continue;\r\n        }\r\n        else if (rule.inCode === \"only\") {\r\n            continue;\r\n        }\r\n        let match = rule.match.exec(textBefore);\r\n        let tr = match && rule.handler(state, match, from - (match[0].length - text.length), to);\r\n        if (!tr)\r\n            continue;\r\n        if (rule.undoable)\r\n            tr.setMeta(plugin, { transform: tr, from, to, text });\r\n        view.dispatch(tr);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n/**\r\nThis is a command that will undo an input rule, if applying such a\r\nrule was the last thing that the user did.\r\n*/\r\nconst undoInputRule = (state, dispatch) => {\r\n    let plugins = state.plugins;\r\n    for (let i = 0; i < plugins.length; i++) {\r\n        let plugin = plugins[i], undoable;\r\n        if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\r\n            if (dispatch) {\r\n                let tr = state.tr, toUndo = undoable.transform;\r\n                for (let j = toUndo.steps.length - 1; j >= 0; j--)\r\n                    tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\r\n                if (undoable.text) {\r\n                    let marks = tr.doc.resolve(undoable.from).marks();\r\n                    tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\r\n                }\r\n                else {\r\n                    tr.delete(undoable.from, undoable.to);\r\n                }\r\n                dispatch(tr);\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\n/**\r\nConverts double dashes to an emdash.\r\n*/\r\nconst emDash = new InputRule(/--$/, \"—\");\r\n/**\r\nConverts three dots to an ellipsis character.\r\n*/\r\nconst ellipsis = new InputRule(/\\.\\.\\.$/, \"…\");\r\n/**\r\n“Smart” opening double quotes.\r\n*/\r\nconst openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"“\");\r\n/**\r\n“Smart” closing double quotes.\r\n*/\r\nconst closeDoubleQuote = new InputRule(/\"$/, \"”\");\r\n/**\r\n“Smart” opening single quotes.\r\n*/\r\nconst openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"‘\");\r\n/**\r\n“Smart” closing single quotes.\r\n*/\r\nconst closeSingleQuote = new InputRule(/'$/, \"’\");\r\n/**\r\nSmart-quote related input rules.\r\n*/\r\nconst smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote];\r\n\r\n/**\r\nBuild an input rule for automatically wrapping a textblock when a\r\ngiven string is typed. The `regexp` argument is\r\ndirectly passed through to the `InputRule` constructor. You'll\r\nprobably want the regexp to start with `^`, so that the pattern can\r\nonly occur at the start of a textblock.\r\n\r\n`nodeType` is the type of node to wrap in. If it needs attributes,\r\nyou can either pass them directly, or pass a function that will\r\ncompute them from the regular expression match.\r\n\r\nBy default, if there's a node with the same type above the newly\r\nwrapped node, the rule will try to [join](https://prosemirror.net/docs/ref/#transform.Transform.join) those\r\ntwo nodes. You can pass a join predicate, which takes a regular\r\nexpression match and the node before the wrapped node, and can\r\nreturn a boolean to indicate whether a join should happen.\r\n*/\r\nfunction wrappingInputRule(regexp, nodeType, getAttrs = null, joinPredicate) {\r\n    return new InputRule(regexp, (state, match, start, end) => {\r\n        let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\r\n        let tr = state.tr.delete(start, end);\r\n        let $start = tr.doc.resolve(start), range = $start.blockRange(), wrapping = range && findWrapping(range, nodeType, attrs);\r\n        if (!wrapping)\r\n            return null;\r\n        tr.wrap(range, wrapping);\r\n        let before = tr.doc.resolve(start - 1).nodeBefore;\r\n        if (before && before.type == nodeType && canJoin(tr.doc, start - 1) &&\r\n            (!joinPredicate || joinPredicate(match, before)))\r\n            tr.join(start - 1);\r\n        return tr;\r\n    });\r\n}\r\n/**\r\nBuild an input rule that changes the type of a textblock when the\r\nmatched text is typed into it. You'll usually want to start your\r\nregexp with `^` to that it is only matched at the start of a\r\ntextblock. The optional `getAttrs` parameter can be used to compute\r\nthe new node's attributes, and works the same as in the\r\n`wrappingInputRule` function.\r\n*/\r\nfunction textblockTypeInputRule(regexp, nodeType, getAttrs = null) {\r\n    return new InputRule(regexp, (state, match, start, end) => {\r\n        let $start = state.doc.resolve(start);\r\n        let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\r\n        if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType))\r\n            return null;\r\n        return state.tr\r\n            .delete(start, end)\r\n            .setBlockType(start, start, nodeType, attrs);\r\n    });\r\n}\r\n\r\nexport { InputRule, closeDoubleQuote, closeSingleQuote, ellipsis, emDash, inputRules, openDoubleQuote, openSingleQuote, smartQuotes, textblockTypeInputRule, undoInputRule, wrappingInputRule };\r\n"],
  "mappings": "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",
  "names": []
}

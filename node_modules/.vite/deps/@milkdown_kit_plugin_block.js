import {
  computePosition,
  flip,
  offset
} from "./chunk-CLZSD3LK.js";
import {
  h,
  ue
} from "./chunk-B6SXNU5U.js";
import {
  L,
  browser,
  findParent
} from "./chunk-CZGTFHL6.js";
import "./chunk-LPJCFVHB.js";
import "./chunk-HS3MAESO.js";
import {
  DOMSerializer,
  NodeSelection,
  Plugin,
  PluginKey
} from "./chunk-G36XMPLZ.js";
import "./chunk-AP6IPAVY.js";
import {
  __commonJS,
  __toESM
} from "./chunk-DP4XHQAG.js";

// node_modules/lodash.throttle/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.throttle/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function throttle(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = throttle;
  }
});

// node_modules/@milkdown/plugin-block/lib/index.es.js
var import_lodash = __toESM(require_lodash());
var q = (o, t, e) => {
  if (!t.has(o))
    throw TypeError("Cannot " + e);
};
var i = (o, t, e) => (q(o, t, "read from private field"), e ? e.call(o) : t.get(o));
var a = (o, t, e) => {
  if (t.has(o))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(o) : t.set(o, e);
};
var n = (o, t, e, r) => (q(o, t, "write to private field"), r ? r.call(o, e) : t.set(o, e), e);
var Z = (o, t, e) => (q(o, t, "access private method"), e);
function W(o, t) {
  return Object.assign(o, {
    meta: {
      package: "@milkdown/plugin-block",
      ...t
    }
  }), o;
}
var mt = (o) => !findParent((e) => e.type.name === "table")(o);
var _ = h({ filterNodes: mt }, "blockConfig");
W(_, {
  displayName: "Ctx<blockConfig>"
});
function bt(o, t, e) {
  var S;
  if (!o.dom.parentElement)
    return null;
  const s = (S = o.posAtCoords({
    left: t.x,
    top: t.y
  })) == null ? void 0 : S.inside;
  if (s == null || s < 0)
    return null;
  let l = o.state.doc.resolve(s), c = o.state.doc.nodeAt(s), d = o.nodeDOM(s);
  const h2 = (z) => {
    const Y = l.depth >= 1 && l.index(l.depth) === 0;
    if (!(z || Y))
      return;
    const T = l.before(l.depth);
    c = o.state.doc.nodeAt(T), d = o.nodeDOM(T), l = o.state.doc.resolve(T), e(l, c) || h2(true);
  }, u = e(l, c);
  return h2(!u), !d || !c ? null : { node: c, $pos: l, el: d };
}
var et = null;
function kt() {
  return et || (et = document.implementation.createHTMLDocument("title"));
}
var Ct = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
function yt(o, t) {
  const e = [];
  let { openStart: r, openEnd: s, content: l } = t;
  for (; r > 1 && s > 1 && l.childCount === 1 && l.firstChild.childCount === 1; ) {
    r -= 1, s -= 1;
    const p = l.firstChild;
    e.push(
      p.type.name,
      p.attrs !== p.type.defaultAttrs ? p.attrs : null
    ), l = p.content;
  }
  const c = o.someProp("clipboardSerializer") || DOMSerializer.fromSchema(o.state.schema), d = kt(), h2 = d.createElement("div");
  h2.appendChild(c.serializeFragment(l, { document: d }));
  let u = h2.firstChild, S, z = 0;
  for (; u && u.nodeType === 1 && (S = Ct[u.nodeName.toLowerCase()]); ) {
    for (let p = S.length - 1; p >= 0; p--) {
      const T = d.createElement(S[p]);
      for (; h2.firstChild; )
        T.appendChild(h2.firstChild);
      h2.appendChild(T), z++;
    }
    u = h2.firstChild;
  }
  u && u.nodeType === 1 && u.setAttribute(
    "data-pm-slice",
    `${r} ${s}${z ? ` -${z}` : ""} ${JSON.stringify(e)}`
  );
  const Y = o.someProp("clipboardTextSerializer", (p) => p(t, o)) || t.content.textBetween(0, t.content.size, `

`);
  return { dom: h2, text: Y };
}
var it = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
var st = 20;
var D;
var H;
var k;
var g;
var M;
var m;
var I;
var ot;
var C;
var A;
var y;
var v;
var F;
var P;
var B;
var N;
var K;
var x;
var vt = class {
  constructor() {
    a(this, I);
    a(this, C);
    a(this, D, void 0);
    a(this, H, void 0);
    a(this, k, void 0);
    a(this, g, void 0);
    a(this, M, void 0);
    a(this, m, void 0);
    a(this, y, void 0);
    a(this, v, void 0);
    a(this, F, void 0);
    a(this, P, void 0);
    a(this, B, void 0);
    a(this, N, void 0);
    a(this, K, void 0);
    a(this, x, void 0);
    n(this, H, () => {
      if (!i(this, g))
        return null;
      const t = i(this, g), e = i(this, C, A);
      if (e && NodeSelection.isSelectable(t.node)) {
        const r = NodeSelection.create(e.state.doc, t.$pos.pos);
        return e.dispatch(e.state.tr.setSelection(r)), e.focus(), n(this, k, r), r;
      }
      return null;
    }), n(this, k, null), n(this, g, null), n(this, M, void 0), n(this, m, false), n(this, v, () => {
      var t;
      (t = i(this, y)) == null || t.call(this, { type: "hide" }), n(this, g, null);
    }), n(this, F, (t) => {
      var e;
      n(this, g, t), (e = i(this, y)) == null || e.call(this, { type: "show", active: t });
    }), this.bind = (t, e) => {
      n(this, D, t), n(this, y, e);
    }, this.addEvent = (t) => {
      t.addEventListener("mousedown", i(this, P)), t.addEventListener("mouseup", i(this, B)), t.addEventListener("dragstart", i(this, N));
    }, this.removeEvent = (t) => {
      t.removeEventListener("mousedown", i(this, P)), t.removeEventListener("mouseup", i(this, B)), t.removeEventListener("dragstart", i(this, N));
    }, this.unBind = () => {
      n(this, y, void 0);
    }, n(this, P, () => {
      var t;
      n(this, M, (t = i(this, g)) == null ? void 0 : t.el.getBoundingClientRect()), i(this, H).call(this);
    }), n(this, B, () => {
      if (!i(this, m)) {
        requestAnimationFrame(() => {
          var t;
          i(this, M) && ((t = i(this, C, A)) == null || t.focus());
        });
        return;
      }
      n(this, m, false), n(this, k, null);
    }), n(this, N, (t) => {
      var s;
      n(this, m, true);
      const e = i(this, C, A);
      if (!e)
        return;
      e.dom.dataset.dragging = "true";
      const r = i(this, k);
      if (t.dataTransfer && r) {
        const l = r.content();
        t.dataTransfer.effectAllowed = "copyMove";
        const { dom: c, text: d } = yt(e, l);
        t.dataTransfer.clearData(), t.dataTransfer.setData(it ? "Text" : "text/html", c.innerHTML), it || t.dataTransfer.setData("text/plain", d);
        const h2 = (s = i(this, g)) == null ? void 0 : s.el;
        h2 && t.dataTransfer.setDragImage(h2, 0, 0), e.dragging = {
          slice: l,
          move: true
        };
      }
    }), this.keydownCallback = (t) => (i(this, v).call(this), n(this, m, false), t.dom.dataset.dragging = "false", false), n(this, K, (0, import_lodash.default)((t, e) => {
      if (!t.editable)
        return;
      const r = t.dom.getBoundingClientRect(), s = r.left + r.width / 2;
      if (!(t.root.elementFromPoint(s, e.clientY) instanceof Element)) {
        i(this, v).call(this);
        return;
      }
      const c = i(this, I, ot);
      if (!c)
        return;
      const d = bt(t, { x: s, y: e.clientY }, c);
      if (!d) {
        i(this, v).call(this);
        return;
      }
      i(this, F).call(this, d);
    }, 200)), this.mousemoveCallback = (t, e) => (t.composing || !t.editable || i(this, K).call(this, t, e), false), this.dragoverCallback = (t, e) => {
      var r;
      if (i(this, m)) {
        const s = (r = i(this, C, A)) == null ? void 0 : r.dom.parentElement;
        if (!s)
          return false;
        const l = s.scrollHeight > s.clientHeight, c = s.getBoundingClientRect();
        if (l) {
          if (s.scrollTop > 0 && Math.abs(e.y - c.y) < st) {
            const u = s.scrollTop > 10 ? s.scrollTop - 10 : 0;
            return s.scrollTop = u, false;
          }
          const d = Math.round(t.dom.getBoundingClientRect().height);
          if (Math.round(s.scrollTop + c.height) < d && Math.abs(e.y - (c.height + c.y)) < st) {
            const u = s.scrollTop + 10;
            return s.scrollTop = u, false;
          }
        }
      }
      return false;
    }, this.dragenterCallback = (t) => {
      t.dragging && (n(this, m, true), t.dom.dataset.dragging = "true");
    }, this.dragleaveCallback = (t, e) => {
      const r = e.clientX, s = e.clientY;
      (r < 0 || s < 0 || r > window.innerWidth || s > window.innerHeight) && (n(this, g, null), i(this, x).call(this, t));
    }, this.dropCallback = (t) => (i(this, x).call(this, t), false), this.dragendCallback = (t) => {
      i(this, x).call(this, t);
    }, n(this, x, (t) => {
      n(this, m, false), t.dom.dataset.dragging = "false";
    });
  }
};
D = /* @__PURE__ */ new WeakMap(), H = /* @__PURE__ */ new WeakMap(), k = /* @__PURE__ */ new WeakMap(), g = /* @__PURE__ */ new WeakMap(), M = /* @__PURE__ */ new WeakMap(), m = /* @__PURE__ */ new WeakMap(), I = /* @__PURE__ */ new WeakSet(), ot = function() {
  var t;
  return (t = i(this, D)) == null ? void 0 : t.get(_.key).filterNodes;
}, C = /* @__PURE__ */ new WeakSet(), A = function() {
  var t;
  return (t = i(this, D)) == null ? void 0 : t.get(L);
}, y = /* @__PURE__ */ new WeakMap(), v = /* @__PURE__ */ new WeakMap(), F = /* @__PURE__ */ new WeakMap(), P = /* @__PURE__ */ new WeakMap(), B = /* @__PURE__ */ new WeakMap(), N = /* @__PURE__ */ new WeakMap(), K = /* @__PURE__ */ new WeakMap(), x = /* @__PURE__ */ new WeakMap();
var X = h(new vt(), "blockService");
W(_, {
  displayName: "Ctx<blockService>"
});
var G = h({}, "blockSpec");
W(_, {
  displayName: "Ctx<blockSpec>"
});
var Q = ue((o) => {
  const t = new PluginKey("MILKDOWN_BLOCK"), e = o.get(X.key), r = o.get(G.key);
  return new Plugin({
    key: t,
    ...r,
    props: {
      ...r.props,
      handleDOMEvents: {
        drop: (s) => e.dropCallback(s),
        pointermove: (s, l) => e.mousemoveCallback(s, l),
        keydown: (s) => e.keydownCallback(s),
        dragover: (s, l) => e.dragoverCallback(s, l),
        dragleave: (s, l) => e.dragleaveCallback(s, l),
        dragenter: (s) => e.dragenterCallback(s),
        dragend: (s) => e.dragendCallback(s)
      }
    }
  });
});
W(Q, {
  displayName: "Prose<block>"
});
var f;
var b;
var w;
var E;
var O;
var L2;
var $;
var R;
var U;
var nt;
var Bt = class {
  constructor(t) {
    a(this, U);
    a(this, f, void 0);
    a(this, b, void 0);
    a(this, w, void 0);
    a(this, E, void 0);
    a(this, O, void 0);
    a(this, L2, void 0);
    a(this, $, void 0);
    a(this, R, void 0);
    n(this, E, null), n(this, O, false), this.update = () => {
      requestAnimationFrame(() => {
        if (!i(this, O))
          try {
            Z(this, U, nt).call(this), n(this, O, true);
          } catch {
          }
      });
    }, this.destroy = () => {
      var e, r;
      (e = i(this, w)) == null || e.unBind(), (r = i(this, w)) == null || r.removeEvent(i(this, f)), i(this, f).remove();
    }, this.show = (e) => {
      const r = e.el, s = i(this, b).get(L).dom, l = {
        ctx: i(this, b),
        active: e,
        editorDom: s,
        blockDom: i(this, f)
      }, c = {
        contextElement: r,
        getBoundingClientRect: () => i(this, $) ? i(this, $).call(this, l) : r.getBoundingClientRect()
      }, d = [flip()];
      if (i(this, L2)) {
        const h2 = i(this, L2).call(this, l), u = offset(h2);
        d.push(u);
      }
      computePosition(c, i(this, f), {
        placement: i(this, R) ? i(this, R).call(this, l) : "left",
        middleware: d
      }).then(({ x: h2, y: u }) => {
        Object.assign(i(this, f).style, {
          left: `${h2}px`,
          top: `${u}px`
        }), i(this, f).dataset.show = "true";
      });
    }, this.hide = () => {
      i(this, f).dataset.show = "false", setTimeout(() => {
        Object.assign(i(this, f).style, {
          left: "-999px",
          top: "-999px"
        });
      }, 200);
    }, n(this, b, t.ctx), n(this, f, t.content), n(this, L2, t.getOffset), n(this, $, t.getPosition), n(this, R, t.getPlacement), this.hide();
  }
  /// The context of current active node.
  get active() {
    return i(this, E);
  }
};
f = /* @__PURE__ */ new WeakMap(), b = /* @__PURE__ */ new WeakMap(), w = /* @__PURE__ */ new WeakMap(), E = /* @__PURE__ */ new WeakMap(), O = /* @__PURE__ */ new WeakMap(), L2 = /* @__PURE__ */ new WeakMap(), $ = /* @__PURE__ */ new WeakMap(), R = /* @__PURE__ */ new WeakMap(), U = /* @__PURE__ */ new WeakSet(), nt = function() {
  var r;
  (r = i(this, b).get(L).dom.parentElement) == null || r.appendChild(i(this, f));
  const e = i(this, b).get(X.key);
  e.bind(i(this, b), (s) => {
    s.type === "hide" ? (this.hide(), n(this, E, null)) : s.type === "show" && (this.show(s.active), n(this, E, s.active));
  }), n(this, w, e), i(this, w).addEvent(i(this, f)), i(this, f).draggable = true;
};
var rt = [G, _, X, Q];
rt.key = G.key;
rt.pluginKey = Q.key;
export {
  Bt as BlockProvider,
  vt as BlockService,
  rt as block,
  _ as blockConfig,
  Q as blockPlugin,
  X as blockService,
  G as blockSpec,
  mt as defaultNodeFilter
};
//# sourceMappingURL=@milkdown_kit_plugin_block.js.map

import {
  Et,
  H,
  K,
  L,
  M,
  M2,
  N,
  R,
  U,
  X,
  Y,
  Z,
  ae,
  b,
  fe,
  ie,
  je,
  keymap,
  ne,
  pe,
  q,
  re,
  ue,
  x,
  x2,
  ye
} from "./chunk-ICFNTP7Z.js";
import {
  DOMSerializer,
  EditorState,
  NodeType,
  Slice
} from "./chunk-JD2NWN4W.js";

// node_modules/nanoid/index.browser.js
var random = (bytes) => crypto.getRandomValues(new Uint8Array(bytes));
var customRandom = (alphabet, defaultSize, getRandom) => {
  let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
  let step = -~(1.6 * mask * defaultSize / alphabet.length);
  return (size = defaultSize) => {
    let id = "";
    while (true) {
      let bytes = getRandom(step);
      let j = step;
      while (j--) {
        id += alphabet[bytes[j] & mask] || "";
        if (id.length === size) return id;
      }
    }
  };
};
var customAlphabet = (alphabet, size = 21) => customRandom(alphabet, size, random);

// node_modules/@milkdown/utils/lib/index.es.js
var J = customAlphabet("abcedfghicklmn", 10);
function y(n, o, r) {
  const t = K(r || J());
  let e = false;
  const a = (s) => (s.record(t), s.update(o, (i) => i.concat(t)), async () => {
    const u = await n(s, a, () => {
      s.done(t), e = true;
    });
    return e || s.done(t), () => {
      s.update(o, (c) => c.filter((m) => m !== t)), s.clearTimer(t), u == null || u();
    };
  });
  return a.timer = t, a;
}
function re2(n, o) {
  const r = Et(n), t = (e) => async () => {
    t.key = r, await e.wait(Y);
    const a = o(e);
    return e.get(je).create(r, a), t.run = (s) => e.get(je).call(n, s), () => {
      e.get(je).remove(r);
    };
  };
  return t;
}
function ae2(n, o, r) {
  const t = Et(n);
  return y(
    async (e, a) => {
      await e.wait(Y);
      const s = await o(e);
      return e.get(je).create(t, s), a.run = (i) => e.get(je).call(n, i), a.key = t, () => {
        e.get(je).remove(t);
      };
    },
    x2,
    r
  );
}
function oe(n) {
  const o = (r) => async () => {
    await r.wait(R);
    const t = n(r);
    return r.update(ue, (e) => [...e, t]), o.inputRule = t, () => {
      r.update(ue, (e) => e.filter((a) => a !== t));
    };
  };
  return o;
}
function se(n, o) {
  return y(
    async (r, t) => {
      await r.wait(R);
      const e = await n(r);
      return r.update(ue, (a) => [...a, e]), t.inputRule = e, () => {
        r.update(ue, (a) => a.filter((s) => s !== e));
      };
    },
    ne,
    o
  );
}
function Q(n, o) {
  const r = (t) => async () => {
    const e = o(t);
    return t.update(Z, (a) => [...a.filter((s) => s[0] !== n), [n, e]]), r.id = n, r.schema = e, () => {
      t.update(Z, (a) => a.filter(([s]) => s !== n));
    };
  };
  return r.type = (t) => {
    const e = t.get(b).marks[n];
    if (!e)
      throw x(n);
    return e;
  }, r;
}
function ie2(n, o, r) {
  const t = y(
    async (e, a, s) => {
      const i = await o(e);
      return e.update(Z, (u) => [...u.filter((c) => c[0] !== n), [n, i]]), a.id = n, a.schema = i, s(), () => {
        e.update(Z, (u) => u.filter(([c]) => c !== n));
      };
    },
    U,
    r
  );
  return t.type = (e) => {
    const a = e.get(b).marks[n];
    if (!a)
      throw x(n);
    return a;
  }, t;
}
function W(n, o) {
  const r = (t) => async () => {
    const e = o(t);
    return t.update(X, (a) => [...a.filter((s) => s[0] !== n), [n, e]]), r.id = n, r.schema = e, () => {
      t.update(X, (a) => a.filter(([s]) => s !== n));
    };
  };
  return r.type = (t) => {
    const e = t.get(b).nodes[n];
    if (!e)
      throw M(n);
    return e;
  }, r;
}
function ce(n, o, r) {
  const t = y(
    async (e, a, s) => {
      const i = await o(e);
      return e.update(X, (u) => [...u.filter((c) => c[0] !== n), [n, i]]), a.id = n, a.schema = i, s(), () => {
        e.update(X, (u) => u.filter(([c]) => c !== n));
      };
    },
    U,
    r
  );
  return t.type = (e) => {
    const a = e.get(b).nodes[n];
    if (!a)
      throw M(n);
    return a;
  }, t;
}
function ue2(n) {
  let o;
  const r = (t) => async () => (await t.wait(R), o = n(t), t.update(N, (e) => [...e, o]), () => {
    t.update(N, (e) => e.filter((a) => a !== o));
  });
  return r.plugin = () => o, r.key = () => o.spec.key, r;
}
function me(n, o) {
  let r;
  const t = y(
    async (e) => (await e.wait(R), r = await n(e), e.update(N, (a) => [...a, r]), () => {
      e.update(N, (a) => a.filter((s) => s !== r));
    }),
    ne,
    o
  );
  return t.plugin = () => r, t.key = () => r.spec.key, t;
}
function X2(n) {
  const o = (r) => async () => {
    await r.wait(R);
    const t = n(r), e = keymap(t);
    return r.update(N, (a) => [...a, e]), o.keymap = t, () => {
      r.update(N, (a) => a.filter((s) => s !== e));
    };
  };
  return o;
}
function pe2(n, o) {
  return y(
    async (r, t) => {
      await r.wait(R);
      const e = await n(r), a = keymap(e);
      return r.update(N, (s) => [...s, a]), t.keymap = e, () => {
        r.update(N, (s) => s.filter((i) => i !== a));
      };
    },
    ne,
    o
  );
}
function le(n, o) {
  const r = (t) => async () => {
    await t.wait(R);
    const e = o(t);
    return n.type(t) instanceof NodeType ? t.update(fe, (a) => [...a, [n.id, e]]) : t.update(ye, (a) => [...a, [n.id, e]]), r.view = e, r.type = n, () => {
      n.type(t) instanceof NodeType ? t.update(fe, (a) => a.filter((s) => s[0] !== n.id)) : t.update(ye, (a) => a.filter((s) => s[0] !== n.id));
    };
  };
  return r;
}
function de(n, o, r) {
  return y(
    async (t, e) => {
      await t.wait(R);
      const a = await o(t);
      return n.type(t) instanceof NodeType ? t.update(fe, (s) => [...s, [n.id, a]]) : t.update(ye, (s) => [...s, [n.id, a]]), e.view = a, e.type = n, () => {
        n.type(t) instanceof NodeType ? t.update(fe, (s) => s.filter((i) => i[0] !== n.id)) : t.update(ye, (s) => s.filter((i) => i[0] !== n.id));
      };
    },
    ae,
    r
  );
}
function h(n, o) {
  const r = H(n, o), t = (e) => (e.inject(r), () => () => {
    e.remove(r);
  });
  return t.key = r, t;
}
function fe2(n, o) {
  const r = h(o, n), t = W(n, (a) => a.get(r.key)(a)), e = [r, t];
  return e.id = t.id, e.node = t, e.type = (a) => t.type(a), e.schema = t.schema, e.ctx = r, e.key = r.key, e.extendSchema = (a) => (s) => () => {
    const i = s.get(r.key), c = a(i)(s);
    s.update(X, (m) => [...m.filter((S) => S[0] !== n), [n, c]]), e.schema = c;
  }, e;
}
function ye2(n, o) {
  const r = h(o, n), t = Q(n, (a) => a.get(r.key)(a)), e = [r, t];
  return e.id = t.id, e.mark = t, e.type = t.type, e.schema = t.schema, e.ctx = r, e.key = r.key, e.extendSchema = (a) => (s) => () => {
    const i = s.get(r.key), c = a(i)(s);
    s.update(Z, (m) => [...m.filter((S) => S[0] !== n), [n, c]]), e.schema = c;
  }, e;
}
function ge(n, o) {
  const r = Object.fromEntries(Object.entries(o).map(([s, { shortcuts: i }]) => [s, i])), t = h(r, `${n}Keymap`), e = X2((s) => {
    const i = s.get(t.key), u = Object.entries(o).flatMap(([c, { command: m }]) => [i[c]].flat().map((V) => [V, m(s)]));
    return Object.fromEntries(u);
  }), a = [t, e];
  return a.ctx = t, a.shortcuts = e, a.key = t.key, a.keymap = e.keymap, a;
}
var he = (n, o = () => ({})) => h(o, `${n}Attr`);
var we = (n, o = () => ({})) => h(o, `${n}Attr`);
function ke(n, o, r) {
  const t = h(r ?? {}, n), e = (s) => async () => {
    await s.wait(M2);
    const u = {
      plugin: o(s),
      options: s.get(t.key)
    };
    return s.update(pe, (c) => [...c, u]), () => {
      s.update(pe, (c) => c.filter((m) => m !== u));
    };
  }, a = [t, e];
  return a.id = n, a.plugin = e, a.options = t, a;
}
function Se(n, o) {
  return (r) => r.get(je).call(n, o);
}
function Ce() {
  return (n) => {
    const o = n.get(L), { tr: r } = o.state, t = Object.assign(Object.create(r), r).setTime(Date.now());
    return o.dispatch(t);
  };
}
function ve() {
  return (n) => {
    const o = document.createElement("div"), r = n.get(b), t = n.get(L), e = DOMSerializer.fromSchema(r).serializeFragment(t.state.doc.content);
    return o.appendChild(e), o.innerHTML;
  };
}
function $e() {
  return (n) => {
    const o = n.get(L);
    return n.get(re)(o.state.doc);
  };
}
function Te(n) {
  return (o) => {
    const r = o.get(L), e = o.get(q)(n);
    if (!e)
      return;
    const a = r.state.selection.content();
    return r.dispatch(
      r.state.tr.replaceSelection(new Slice(e.content, a.openStart, a.openEnd)).scrollIntoView()
    );
  };
}
function Ae() {
  return (n) => {
    const o = n.get(L), r = [];
    return o.state.doc.descendants((e) => {
      e.type.name === "heading" && e.attrs.level && r.push({ text: e.textContent, level: e.attrs.level, id: e.attrs.id });
    }), r;
  };
}
function be(n, o = false) {
  return (r) => {
    const t = r.get(L), a = r.get(q)(n);
    if (!a)
      return;
    if (!o) {
      const { state: m } = t;
      return t.dispatch(m.tr.replace(0, m.doc.content.size, new Slice(a.content, 0, 0)));
    }
    const s = r.get(b), i = r.get(ie), u = r.get(N), c = EditorState.create({
      schema: s,
      doc: a,
      plugins: u,
      ...i
    });
    t.updateState(c);
  };
}
function Oe(n, o) {
  return (r) => {
    const t = r.get(L), { tr: e } = t.state, a = e.doc.nodeAt(n);
    if (!a)
      return;
    const s = o(a.attrs);
    return t.dispatch(e.setNodeMarkup(n, void 0, s));
  };
}
var Re = (...n) => {
  const o = n.length;
  let r = o;
  for (; r--; )
    if (typeof n[r] != "function")
      throw new TypeError("Expected a function");
  return (...t) => {
    let e = 0, a = o ? n[e](...t) : t[0];
    for (; ++e < o; )
      a = n[e](a);
    return a;
  };
};

export {
  J,
  y,
  re2 as re,
  ae2 as ae,
  oe,
  se,
  Q,
  ie2 as ie,
  W,
  ce,
  ue2 as ue,
  me,
  X2 as X,
  pe2 as pe,
  le,
  de,
  h,
  fe2 as fe,
  ye2 as ye,
  ge,
  he,
  we,
  ke,
  Se,
  Ce,
  ve,
  $e,
  Te,
  Ae,
  be,
  Oe,
  Re
};
//# sourceMappingURL=chunk-KJ6QXBW5.js.map

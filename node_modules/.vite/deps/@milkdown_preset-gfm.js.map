{
  "version": 3,
  "sources": ["../../prosemirror-tables/dist/index.js", "../../prosemirror-safari-ime-span/dist/index.js", "../../ccount/index.js", "../../mdast-util-find-and-replace/lib/index.js", "../../mdast-util-gfm-autolink-literal/lib/index.js", "../../mdast-util-gfm-footnote/lib/index.js", "../../mdast-util-gfm-strikethrough/lib/index.js", "../../markdown-table/index.js", "../../mdast-util-gfm-table/lib/index.js", "../../mdast-util-gfm-task-list-item/lib/index.js", "../../mdast-util-gfm/lib/index.js", "../../micromark-extension-gfm-autolink-literal/dev/lib/syntax.js", "../../micromark-extension-gfm-footnote/dev/lib/syntax.js", "../../micromark-extension-gfm-footnote/dev/lib/html.js", "../../micromark-extension-gfm-strikethrough/dev/lib/syntax.js", "../../micromark-extension-gfm-table/dev/lib/edit-map.js", "../../micromark-extension-gfm-table/dev/lib/infer.js", "../../micromark-extension-gfm-table/dev/lib/syntax.js", "../../micromark-extension-gfm-tagfilter/lib/index.js", "../../micromark-extension-gfm-task-list-item/dev/lib/syntax.js", "../../micromark-extension-gfm/index.js", "../../remark-gfm/lib/index.js", "../../@milkdown/preset-gfm/src/__internal__/with-meta.ts", "../../@milkdown/preset-gfm/src/mark/strike-through.ts", "../../@milkdown/preset-gfm/src/node/table/schema.ts", "../../@milkdown/preset-gfm/src/node/table/utils.ts", "../../@milkdown/preset-gfm/src/node/table/command.ts", "../../@milkdown/preset-gfm/src/node/table/input.ts", "../../@milkdown/preset-gfm/src/node/footnote/definition.ts", "../../@milkdown/preset-gfm/src/node/footnote/reference.ts", "../../@milkdown/preset-gfm/src/node/task-list-item.ts", "../../@milkdown/preset-gfm/src/composed/keymap.ts", "../../@milkdown/preset-gfm/src/composed/inputrules.ts", "../../@milkdown/preset-gfm/src/plugin/auto-insert-span-plugin.ts", "../../@milkdown/preset-gfm/src/plugin/column-resizing-plugin.ts", "../../@milkdown/preset-gfm/src/plugin/table-editing-plugin.ts", "../../@milkdown/preset-gfm/src/plugin/remark-gfm-plugin.ts", "../../@milkdown/preset-gfm/src/plugin/keep-table-align-plugin.ts", "../../@milkdown/preset-gfm/src/composed/plugins.ts", "../../@milkdown/preset-gfm/src/composed/schema.ts", "../../@milkdown/preset-gfm/src/composed/commands.ts", "../../@milkdown/preset-gfm/src/index.ts"],
  "sourcesContent": ["// src/index.ts\r\nimport { Plugin as Plugin2 } from \"prosemirror-state\";\r\n\r\n// src/cellselection.ts\r\nimport { Fragment, Slice } from \"prosemirror-model\";\r\nimport {\r\n  NodeSelection as NodeSelection2,\r\n  Selection,\r\n  SelectionRange,\r\n  TextSelection\r\n} from \"prosemirror-state\";\r\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\r\n\r\n// src/tablemap.ts\r\nvar readFromCache;\r\nvar addToCache;\r\nif (typeof WeakMap != \"undefined\") {\r\n  let cache = /* @__PURE__ */ new WeakMap();\r\n  readFromCache = (key) => cache.get(key);\r\n  addToCache = (key, value) => {\r\n    cache.set(key, value);\r\n    return value;\r\n  };\r\n} else {\r\n  const cache = [];\r\n  const cacheSize = 10;\r\n  let cachePos = 0;\r\n  readFromCache = (key) => {\r\n    for (let i = 0; i < cache.length; i += 2)\r\n      if (cache[i] == key)\r\n        return cache[i + 1];\r\n  };\r\n  addToCache = (key, value) => {\r\n    if (cachePos == cacheSize)\r\n      cachePos = 0;\r\n    cache[cachePos++] = key;\r\n    return cache[cachePos++] = value;\r\n  };\r\n}\r\nvar TableMap = class {\r\n  constructor(width, height, map, problems) {\r\n    this.width = width;\r\n    this.height = height;\r\n    this.map = map;\r\n    this.problems = problems;\r\n  }\r\n  // Find the dimensions of the cell at the given position.\r\n  findCell(pos) {\r\n    for (let i = 0; i < this.map.length; i++) {\r\n      const curPos = this.map[i];\r\n      if (curPos != pos)\r\n        continue;\r\n      const left = i % this.width;\r\n      const top = i / this.width | 0;\r\n      let right = left + 1;\r\n      let bottom = top + 1;\r\n      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++) {\r\n        right++;\r\n      }\r\n      for (let j = 1; bottom < this.height && this.map[i + this.width * j] == curPos; j++) {\r\n        bottom++;\r\n      }\r\n      return { left, top, right, bottom };\r\n    }\r\n    throw new RangeError(`No cell with offset ${pos} found`);\r\n  }\r\n  // Find the left side of the cell at the given position.\r\n  colCount(pos) {\r\n    for (let i = 0; i < this.map.length; i++) {\r\n      if (this.map[i] == pos) {\r\n        return i % this.width;\r\n      }\r\n    }\r\n    throw new RangeError(`No cell with offset ${pos} found`);\r\n  }\r\n  // Find the next cell in the given direction, starting from the cell\r\n  // at `pos`, if any.\r\n  nextCell(pos, axis, dir) {\r\n    const { left, right, top, bottom } = this.findCell(pos);\r\n    if (axis == \"horiz\") {\r\n      if (dir < 0 ? left == 0 : right == this.width)\r\n        return null;\r\n      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];\r\n    } else {\r\n      if (dir < 0 ? top == 0 : bottom == this.height)\r\n        return null;\r\n      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\r\n    }\r\n  }\r\n  // Get the rectangle spanning the two given cells.\r\n  rectBetween(a, b) {\r\n    const {\r\n      left: leftA,\r\n      right: rightA,\r\n      top: topA,\r\n      bottom: bottomA\r\n    } = this.findCell(a);\r\n    const {\r\n      left: leftB,\r\n      right: rightB,\r\n      top: topB,\r\n      bottom: bottomB\r\n    } = this.findCell(b);\r\n    return {\r\n      left: Math.min(leftA, leftB),\r\n      top: Math.min(topA, topB),\r\n      right: Math.max(rightA, rightB),\r\n      bottom: Math.max(bottomA, bottomB)\r\n    };\r\n  }\r\n  // Return the position of all cells that have the top left corner in\r\n  // the given rectangle.\r\n  cellsInRect(rect) {\r\n    const result = [];\r\n    const seen = {};\r\n    for (let row = rect.top; row < rect.bottom; row++) {\r\n      for (let col = rect.left; col < rect.right; col++) {\r\n        const index = row * this.width + col;\r\n        const pos = this.map[index];\r\n        if (seen[pos])\r\n          continue;\r\n        seen[pos] = true;\r\n        if (col == rect.left && col && this.map[index - 1] == pos || row == rect.top && row && this.map[index - this.width] == pos) {\r\n          continue;\r\n        }\r\n        result.push(pos);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  // Return the position at which the cell at the given row and column\r\n  // starts, or would start, if a cell started there.\r\n  positionAt(row, col, table) {\r\n    for (let i = 0, rowStart = 0; ; i++) {\r\n      const rowEnd = rowStart + table.child(i).nodeSize;\r\n      if (i == row) {\r\n        let index = col + row * this.width;\r\n        const rowEndIndex = (row + 1) * this.width;\r\n        while (index < rowEndIndex && this.map[index] < rowStart)\r\n          index++;\r\n        return index == rowEndIndex ? rowEnd - 1 : this.map[index];\r\n      }\r\n      rowStart = rowEnd;\r\n    }\r\n  }\r\n  // Find the table map for the given table node.\r\n  static get(table) {\r\n    return readFromCache(table) || addToCache(table, computeMap(table));\r\n  }\r\n};\r\nfunction computeMap(table) {\r\n  if (table.type.spec.tableRole != \"table\")\r\n    throw new RangeError(\"Not a table node: \" + table.type.name);\r\n  const width = findWidth(table), height = table.childCount;\r\n  const map = [];\r\n  let mapPos = 0;\r\n  let problems = null;\r\n  const colWidths = [];\r\n  for (let i = 0, e = width * height; i < e; i++)\r\n    map[i] = 0;\r\n  for (let row = 0, pos = 0; row < height; row++) {\r\n    const rowNode = table.child(row);\r\n    pos++;\r\n    for (let i = 0; ; i++) {\r\n      while (mapPos < map.length && map[mapPos] != 0)\r\n        mapPos++;\r\n      if (i == rowNode.childCount)\r\n        break;\r\n      const cellNode = rowNode.child(i);\r\n      const { colspan, rowspan, colwidth } = cellNode.attrs;\r\n      for (let h = 0; h < rowspan; h++) {\r\n        if (h + row >= height) {\r\n          (problems || (problems = [])).push({\r\n            type: \"overlong_rowspan\",\r\n            pos,\r\n            n: rowspan - h\r\n          });\r\n          break;\r\n        }\r\n        const start = mapPos + h * width;\r\n        for (let w = 0; w < colspan; w++) {\r\n          if (map[start + w] == 0)\r\n            map[start + w] = pos;\r\n          else\r\n            (problems || (problems = [])).push({\r\n              type: \"collision\",\r\n              row,\r\n              pos,\r\n              n: colspan - w\r\n            });\r\n          const colW = colwidth && colwidth[w];\r\n          if (colW) {\r\n            const widthIndex = (start + w) % width * 2, prev = colWidths[widthIndex];\r\n            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {\r\n              colWidths[widthIndex] = colW;\r\n              colWidths[widthIndex + 1] = 1;\r\n            } else if (prev == colW) {\r\n              colWidths[widthIndex + 1]++;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      mapPos += colspan;\r\n      pos += cellNode.nodeSize;\r\n    }\r\n    const expectedPos = (row + 1) * width;\r\n    let missing = 0;\r\n    while (mapPos < expectedPos)\r\n      if (map[mapPos++] == 0)\r\n        missing++;\r\n    if (missing)\r\n      (problems || (problems = [])).push({ type: \"missing\", row, n: missing });\r\n    pos++;\r\n  }\r\n  const tableMap = new TableMap(width, height, map, problems);\r\n  let badWidths = false;\r\n  for (let i = 0; !badWidths && i < colWidths.length; i += 2)\r\n    if (colWidths[i] != null && colWidths[i + 1] < height)\r\n      badWidths = true;\r\n  if (badWidths)\r\n    findBadColWidths(tableMap, colWidths, table);\r\n  return tableMap;\r\n}\r\nfunction findWidth(table) {\r\n  let width = -1;\r\n  let hasRowSpan = false;\r\n  for (let row = 0; row < table.childCount; row++) {\r\n    const rowNode = table.child(row);\r\n    let rowWidth = 0;\r\n    if (hasRowSpan)\r\n      for (let j = 0; j < row; j++) {\r\n        const prevRow = table.child(j);\r\n        for (let i = 0; i < prevRow.childCount; i++) {\r\n          const cell = prevRow.child(i);\r\n          if (j + cell.attrs.rowspan > row)\r\n            rowWidth += cell.attrs.colspan;\r\n        }\r\n      }\r\n    for (let i = 0; i < rowNode.childCount; i++) {\r\n      const cell = rowNode.child(i);\r\n      rowWidth += cell.attrs.colspan;\r\n      if (cell.attrs.rowspan > 1)\r\n        hasRowSpan = true;\r\n    }\r\n    if (width == -1)\r\n      width = rowWidth;\r\n    else if (width != rowWidth)\r\n      width = Math.max(width, rowWidth);\r\n  }\r\n  return width;\r\n}\r\nfunction findBadColWidths(map, colWidths, table) {\r\n  if (!map.problems)\r\n    map.problems = [];\r\n  const seen = {};\r\n  for (let i = 0; i < map.map.length; i++) {\r\n    const pos = map.map[i];\r\n    if (seen[pos])\r\n      continue;\r\n    seen[pos] = true;\r\n    const node = table.nodeAt(pos);\r\n    if (!node) {\r\n      throw new RangeError(`No cell with offset ${pos} found`);\r\n    }\r\n    let updated = null;\r\n    const attrs = node.attrs;\r\n    for (let j = 0; j < attrs.colspan; j++) {\r\n      const col = (i + j) % map.width;\r\n      const colWidth = colWidths[col * 2];\r\n      if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth))\r\n        (updated || (updated = freshColWidth(attrs)))[j] = colWidth;\r\n    }\r\n    if (updated)\r\n      map.problems.unshift({\r\n        type: \"colwidth mismatch\",\r\n        pos,\r\n        colwidth: updated\r\n      });\r\n  }\r\n}\r\nfunction freshColWidth(attrs) {\r\n  if (attrs.colwidth)\r\n    return attrs.colwidth.slice();\r\n  const result = [];\r\n  for (let i = 0; i < attrs.colspan; i++)\r\n    result.push(0);\r\n  return result;\r\n}\r\n\r\n// src/util.ts\r\nimport { PluginKey } from \"prosemirror-state\";\r\n\r\n// src/schema.ts\r\nfunction getCellAttrs(dom, extraAttrs) {\r\n  if (typeof dom === \"string\") {\r\n    return {};\r\n  }\r\n  const widthAttr = dom.getAttribute(\"data-colwidth\");\r\n  const widths = widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr) ? widthAttr.split(\",\").map((s) => Number(s)) : null;\r\n  const colspan = Number(dom.getAttribute(\"colspan\") || 1);\r\n  const result = {\r\n    colspan,\r\n    rowspan: Number(dom.getAttribute(\"rowspan\") || 1),\r\n    colwidth: widths && widths.length == colspan ? widths : null\r\n  };\r\n  for (const prop in extraAttrs) {\r\n    const getter = extraAttrs[prop].getFromDOM;\r\n    const value = getter && getter(dom);\r\n    if (value != null) {\r\n      result[prop] = value;\r\n    }\r\n  }\r\n  return result;\r\n}\r\nfunction setCellAttrs(node, extraAttrs) {\r\n  const attrs = {};\r\n  if (node.attrs.colspan != 1)\r\n    attrs.colspan = node.attrs.colspan;\r\n  if (node.attrs.rowspan != 1)\r\n    attrs.rowspan = node.attrs.rowspan;\r\n  if (node.attrs.colwidth)\r\n    attrs[\"data-colwidth\"] = node.attrs.colwidth.join(\",\");\r\n  for (const prop in extraAttrs) {\r\n    const setter = extraAttrs[prop].setDOMAttr;\r\n    if (setter)\r\n      setter(node.attrs[prop], attrs);\r\n  }\r\n  return attrs;\r\n}\r\nfunction tableNodes(options) {\r\n  const extraAttrs = options.cellAttributes || {};\r\n  const cellAttrs = {\r\n    colspan: { default: 1 },\r\n    rowspan: { default: 1 },\r\n    colwidth: { default: null }\r\n  };\r\n  for (const prop in extraAttrs)\r\n    cellAttrs[prop] = { default: extraAttrs[prop].default };\r\n  return {\r\n    table: {\r\n      content: \"table_row+\",\r\n      tableRole: \"table\",\r\n      isolating: true,\r\n      group: options.tableGroup,\r\n      parseDOM: [{ tag: \"table\" }],\r\n      toDOM() {\r\n        return [\"table\", [\"tbody\", 0]];\r\n      }\r\n    },\r\n    table_row: {\r\n      content: \"(table_cell | table_header)*\",\r\n      tableRole: \"row\",\r\n      parseDOM: [{ tag: \"tr\" }],\r\n      toDOM() {\r\n        return [\"tr\", 0];\r\n      }\r\n    },\r\n    table_cell: {\r\n      content: options.cellContent,\r\n      attrs: cellAttrs,\r\n      tableRole: \"cell\",\r\n      isolating: true,\r\n      parseDOM: [\r\n        { tag: \"td\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\r\n      ],\r\n      toDOM(node) {\r\n        return [\"td\", setCellAttrs(node, extraAttrs), 0];\r\n      }\r\n    },\r\n    table_header: {\r\n      content: options.cellContent,\r\n      attrs: cellAttrs,\r\n      tableRole: \"header_cell\",\r\n      isolating: true,\r\n      parseDOM: [\r\n        { tag: \"th\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\r\n      ],\r\n      toDOM(node) {\r\n        return [\"th\", setCellAttrs(node, extraAttrs), 0];\r\n      }\r\n    }\r\n  };\r\n}\r\nfunction tableNodeTypes(schema) {\r\n  let result = schema.cached.tableNodeTypes;\r\n  if (!result) {\r\n    result = schema.cached.tableNodeTypes = {};\r\n    for (const name in schema.nodes) {\r\n      const type = schema.nodes[name], role = type.spec.tableRole;\r\n      if (role)\r\n        result[role] = type;\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n// src/util.ts\r\nvar tableEditingKey = new PluginKey(\"selectingCells\");\r\nfunction cellAround($pos) {\r\n  for (let d = $pos.depth - 1; d > 0; d--)\r\n    if ($pos.node(d).type.spec.tableRole == \"row\")\r\n      return $pos.node(0).resolve($pos.before(d + 1));\r\n  return null;\r\n}\r\nfunction cellWrapping($pos) {\r\n  for (let d = $pos.depth; d > 0; d--) {\r\n    const role = $pos.node(d).type.spec.tableRole;\r\n    if (role === \"cell\" || role === \"header_cell\")\r\n      return $pos.node(d);\r\n  }\r\n  return null;\r\n}\r\nfunction isInTable(state) {\r\n  const $head = state.selection.$head;\r\n  for (let d = $head.depth; d > 0; d--)\r\n    if ($head.node(d).type.spec.tableRole == \"row\")\r\n      return true;\r\n  return false;\r\n}\r\nfunction selectionCell(state) {\r\n  const sel = state.selection;\r\n  if (\"$anchorCell\" in sel && sel.$anchorCell) {\r\n    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\r\n  } else if (\"node\" in sel && sel.node && sel.node.type.spec.tableRole == \"cell\") {\r\n    return sel.$anchor;\r\n  }\r\n  const $cell = cellAround(sel.$head) || cellNear(sel.$head);\r\n  if ($cell) {\r\n    return $cell;\r\n  }\r\n  throw new RangeError(`No cell found around position ${sel.head}`);\r\n}\r\nfunction cellNear($pos) {\r\n  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {\r\n    const role = after.type.spec.tableRole;\r\n    if (role == \"cell\" || role == \"header_cell\")\r\n      return $pos.doc.resolve(pos);\r\n  }\r\n  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {\r\n    const role = before.type.spec.tableRole;\r\n    if (role == \"cell\" || role == \"header_cell\")\r\n      return $pos.doc.resolve(pos - before.nodeSize);\r\n  }\r\n}\r\nfunction pointsAtCell($pos) {\r\n  return $pos.parent.type.spec.tableRole == \"row\" && !!$pos.nodeAfter;\r\n}\r\nfunction moveCellForward($pos) {\r\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);\r\n}\r\nfunction inSameTable($cellA, $cellB) {\r\n  return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);\r\n}\r\nfunction findCell($pos) {\r\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));\r\n}\r\nfunction colCount($pos) {\r\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));\r\n}\r\nfunction nextCell($pos, axis, dir) {\r\n  const table = $pos.node(-1);\r\n  const map = TableMap.get(table);\r\n  const tableStart = $pos.start(-1);\r\n  const moved = map.nextCell($pos.pos - tableStart, axis, dir);\r\n  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);\r\n}\r\nfunction removeColSpan(attrs, pos, n = 1) {\r\n  const result = { ...attrs, colspan: attrs.colspan - n };\r\n  if (result.colwidth) {\r\n    result.colwidth = result.colwidth.slice();\r\n    result.colwidth.splice(pos, n);\r\n    if (!result.colwidth.some((w) => w > 0))\r\n      result.colwidth = null;\r\n  }\r\n  return result;\r\n}\r\nfunction addColSpan(attrs, pos, n = 1) {\r\n  const result = { ...attrs, colspan: attrs.colspan + n };\r\n  if (result.colwidth) {\r\n    result.colwidth = result.colwidth.slice();\r\n    for (let i = 0; i < n; i++)\r\n      result.colwidth.splice(pos, 0, 0);\r\n  }\r\n  return result;\r\n}\r\nfunction columnIsHeader(map, table, col) {\r\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\r\n  for (let row = 0; row < map.height; row++)\r\n    if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)\r\n      return false;\r\n  return true;\r\n}\r\n\r\n// src/cellselection.ts\r\nvar CellSelection = class _CellSelection extends Selection {\r\n  // A table selection is identified by its anchor and head cells. The\r\n  // positions given to this constructor should point _before_ two\r\n  // cells in the same table. They may be the same, to select a single\r\n  // cell.\r\n  constructor($anchorCell, $headCell = $anchorCell) {\r\n    const table = $anchorCell.node(-1);\r\n    const map = TableMap.get(table);\r\n    const tableStart = $anchorCell.start(-1);\r\n    const rect = map.rectBetween(\r\n      $anchorCell.pos - tableStart,\r\n      $headCell.pos - tableStart\r\n    );\r\n    const doc = $anchorCell.node(0);\r\n    const cells = map.cellsInRect(rect).filter((p) => p != $headCell.pos - tableStart);\r\n    cells.unshift($headCell.pos - tableStart);\r\n    const ranges = cells.map((pos) => {\r\n      const cell = table.nodeAt(pos);\r\n      if (!cell) {\r\n        throw RangeError(`No cell with offset ${pos} found`);\r\n      }\r\n      const from = tableStart + pos + 1;\r\n      return new SelectionRange(\r\n        doc.resolve(from),\r\n        doc.resolve(from + cell.content.size)\r\n      );\r\n    });\r\n    super(ranges[0].$from, ranges[0].$to, ranges);\r\n    this.$anchorCell = $anchorCell;\r\n    this.$headCell = $headCell;\r\n  }\r\n  map(doc, mapping) {\r\n    const $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\r\n    const $headCell = doc.resolve(mapping.map(this.$headCell.pos));\r\n    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\r\n      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\r\n      if (tableChanged && this.isRowSelection())\r\n        return _CellSelection.rowSelection($anchorCell, $headCell);\r\n      else if (tableChanged && this.isColSelection())\r\n        return _CellSelection.colSelection($anchorCell, $headCell);\r\n      else\r\n        return new _CellSelection($anchorCell, $headCell);\r\n    }\r\n    return TextSelection.between($anchorCell, $headCell);\r\n  }\r\n  // Returns a rectangular slice of table rows containing the selected\r\n  // cells.\r\n  content() {\r\n    const table = this.$anchorCell.node(-1);\r\n    const map = TableMap.get(table);\r\n    const tableStart = this.$anchorCell.start(-1);\r\n    const rect = map.rectBetween(\r\n      this.$anchorCell.pos - tableStart,\r\n      this.$headCell.pos - tableStart\r\n    );\r\n    const seen = {};\r\n    const rows = [];\r\n    for (let row = rect.top; row < rect.bottom; row++) {\r\n      const rowContent = [];\r\n      for (let index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {\r\n        const pos = map.map[index];\r\n        if (seen[pos])\r\n          continue;\r\n        seen[pos] = true;\r\n        const cellRect = map.findCell(pos);\r\n        let cell = table.nodeAt(pos);\r\n        if (!cell) {\r\n          throw RangeError(`No cell with offset ${pos} found`);\r\n        }\r\n        const extraLeft = rect.left - cellRect.left;\r\n        const extraRight = cellRect.right - rect.right;\r\n        if (extraLeft > 0 || extraRight > 0) {\r\n          let attrs = cell.attrs;\r\n          if (extraLeft > 0) {\r\n            attrs = removeColSpan(attrs, 0, extraLeft);\r\n          }\r\n          if (extraRight > 0) {\r\n            attrs = removeColSpan(\r\n              attrs,\r\n              attrs.colspan - extraRight,\r\n              extraRight\r\n            );\r\n          }\r\n          if (cellRect.left < rect.left) {\r\n            cell = cell.type.createAndFill(attrs);\r\n            if (!cell) {\r\n              throw RangeError(\r\n                `Could not create cell with attrs ${JSON.stringify(attrs)}`\r\n              );\r\n            }\r\n          } else {\r\n            cell = cell.type.create(attrs, cell.content);\r\n          }\r\n        }\r\n        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\r\n          const attrs = {\r\n            ...cell.attrs,\r\n            rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)\r\n          };\r\n          if (cellRect.top < rect.top) {\r\n            cell = cell.type.createAndFill(attrs);\r\n          } else {\r\n            cell = cell.type.create(attrs, cell.content);\r\n          }\r\n        }\r\n        rowContent.push(cell);\r\n      }\r\n      rows.push(table.child(row).copy(Fragment.from(rowContent)));\r\n    }\r\n    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\r\n    return new Slice(Fragment.from(fragment), 1, 1);\r\n  }\r\n  replace(tr, content = Slice.empty) {\r\n    const mapFrom = tr.steps.length, ranges = this.ranges;\r\n    for (let i = 0; i < ranges.length; i++) {\r\n      const { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\r\n      tr.replace(\r\n        mapping.map($from.pos),\r\n        mapping.map($to.pos),\r\n        i ? Slice.empty : content\r\n      );\r\n    }\r\n    const sel = Selection.findFrom(\r\n      tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),\r\n      -1\r\n    );\r\n    if (sel)\r\n      tr.setSelection(sel);\r\n  }\r\n  replaceWith(tr, node) {\r\n    this.replace(tr, new Slice(Fragment.from(node), 0, 0));\r\n  }\r\n  forEachCell(f) {\r\n    const table = this.$anchorCell.node(-1);\r\n    const map = TableMap.get(table);\r\n    const tableStart = this.$anchorCell.start(-1);\r\n    const cells = map.cellsInRect(\r\n      map.rectBetween(\r\n        this.$anchorCell.pos - tableStart,\r\n        this.$headCell.pos - tableStart\r\n      )\r\n    );\r\n    for (let i = 0; i < cells.length; i++) {\r\n      f(table.nodeAt(cells[i]), tableStart + cells[i]);\r\n    }\r\n  }\r\n  // True if this selection goes all the way from the top to the\r\n  // bottom of the table.\r\n  isColSelection() {\r\n    const anchorTop = this.$anchorCell.index(-1);\r\n    const headTop = this.$headCell.index(-1);\r\n    if (Math.min(anchorTop, headTop) > 0)\r\n      return false;\r\n    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;\r\n    const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;\r\n    return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;\r\n  }\r\n  // Returns the smallest column selection that covers the given anchor\r\n  // and head cell.\r\n  static colSelection($anchorCell, $headCell = $anchorCell) {\r\n    const table = $anchorCell.node(-1);\r\n    const map = TableMap.get(table);\r\n    const tableStart = $anchorCell.start(-1);\r\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\r\n    const headRect = map.findCell($headCell.pos - tableStart);\r\n    const doc = $anchorCell.node(0);\r\n    if (anchorRect.top <= headRect.top) {\r\n      if (anchorRect.top > 0)\r\n        $anchorCell = doc.resolve(tableStart + map.map[anchorRect.left]);\r\n      if (headRect.bottom < map.height)\r\n        $headCell = doc.resolve(\r\n          tableStart + map.map[map.width * (map.height - 1) + headRect.right - 1]\r\n        );\r\n    } else {\r\n      if (headRect.top > 0)\r\n        $headCell = doc.resolve(tableStart + map.map[headRect.left]);\r\n      if (anchorRect.bottom < map.height)\r\n        $anchorCell = doc.resolve(\r\n          tableStart + map.map[map.width * (map.height - 1) + anchorRect.right - 1]\r\n        );\r\n    }\r\n    return new _CellSelection($anchorCell, $headCell);\r\n  }\r\n  // True if this selection goes all the way from the left to the\r\n  // right of the table.\r\n  isRowSelection() {\r\n    const table = this.$anchorCell.node(-1);\r\n    const map = TableMap.get(table);\r\n    const tableStart = this.$anchorCell.start(-1);\r\n    const anchorLeft = map.colCount(this.$anchorCell.pos - tableStart);\r\n    const headLeft = map.colCount(this.$headCell.pos - tableStart);\r\n    if (Math.min(anchorLeft, headLeft) > 0)\r\n      return false;\r\n    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;\r\n    const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;\r\n    return Math.max(anchorRight, headRight) == map.width;\r\n  }\r\n  eq(other) {\r\n    return other instanceof _CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;\r\n  }\r\n  // Returns the smallest row selection that covers the given anchor\r\n  // and head cell.\r\n  static rowSelection($anchorCell, $headCell = $anchorCell) {\r\n    const table = $anchorCell.node(-1);\r\n    const map = TableMap.get(table);\r\n    const tableStart = $anchorCell.start(-1);\r\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\r\n    const headRect = map.findCell($headCell.pos - tableStart);\r\n    const doc = $anchorCell.node(0);\r\n    if (anchorRect.left <= headRect.left) {\r\n      if (anchorRect.left > 0)\r\n        $anchorCell = doc.resolve(\r\n          tableStart + map.map[anchorRect.top * map.width]\r\n        );\r\n      if (headRect.right < map.width)\r\n        $headCell = doc.resolve(\r\n          tableStart + map.map[map.width * (headRect.top + 1) - 1]\r\n        );\r\n    } else {\r\n      if (headRect.left > 0)\r\n        $headCell = doc.resolve(tableStart + map.map[headRect.top * map.width]);\r\n      if (anchorRect.right < map.width)\r\n        $anchorCell = doc.resolve(\r\n          tableStart + map.map[map.width * (anchorRect.top + 1) - 1]\r\n        );\r\n    }\r\n    return new _CellSelection($anchorCell, $headCell);\r\n  }\r\n  toJSON() {\r\n    return {\r\n      type: \"cell\",\r\n      anchor: this.$anchorCell.pos,\r\n      head: this.$headCell.pos\r\n    };\r\n  }\r\n  static fromJSON(doc, json) {\r\n    return new _CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\r\n  }\r\n  static create(doc, anchorCell, headCell = anchorCell) {\r\n    return new _CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\r\n  }\r\n  getBookmark() {\r\n    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\r\n  }\r\n};\r\nCellSelection.prototype.visible = false;\r\nSelection.jsonID(\"cell\", CellSelection);\r\nvar CellBookmark = class _CellBookmark {\r\n  constructor(anchor, head) {\r\n    this.anchor = anchor;\r\n    this.head = head;\r\n  }\r\n  map(mapping) {\r\n    return new _CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\r\n  }\r\n  resolve(doc) {\r\n    const $anchorCell = doc.resolve(this.anchor), $headCell = doc.resolve(this.head);\r\n    if ($anchorCell.parent.type.spec.tableRole == \"row\" && $headCell.parent.type.spec.tableRole == \"row\" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell))\r\n      return new CellSelection($anchorCell, $headCell);\r\n    else\r\n      return Selection.near($headCell, 1);\r\n  }\r\n};\r\nfunction drawCellSelection(state) {\r\n  if (!(state.selection instanceof CellSelection))\r\n    return null;\r\n  const cells = [];\r\n  state.selection.forEachCell((node, pos) => {\r\n    cells.push(\r\n      Decoration.node(pos, pos + node.nodeSize, { class: \"selectedCell\" })\r\n    );\r\n  });\r\n  return DecorationSet.create(state.doc, cells);\r\n}\r\nfunction isCellBoundarySelection({ $from, $to }) {\r\n  if ($from.pos == $to.pos || $from.pos < $from.pos - 6)\r\n    return false;\r\n  let afterFrom = $from.pos;\r\n  let beforeTo = $to.pos;\r\n  let depth = $from.depth;\r\n  for (; depth >= 0; depth--, afterFrom++)\r\n    if ($from.after(depth + 1) < $from.end(depth))\r\n      break;\r\n  for (let d = $to.depth; d >= 0; d--, beforeTo--)\r\n    if ($to.before(d + 1) > $to.start(d))\r\n      break;\r\n  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);\r\n}\r\nfunction isTextSelectionAcrossCells({ $from, $to }) {\r\n  let fromCellBoundaryNode;\r\n  let toCellBoundaryNode;\r\n  for (let i = $from.depth; i > 0; i--) {\r\n    const node = $from.node(i);\r\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\r\n      fromCellBoundaryNode = node;\r\n      break;\r\n    }\r\n  }\r\n  for (let i = $to.depth; i > 0; i--) {\r\n    const node = $to.node(i);\r\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\r\n      toCellBoundaryNode = node;\r\n      break;\r\n    }\r\n  }\r\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\r\n}\r\nfunction normalizeSelection(state, tr, allowTableNodeSelection) {\r\n  const sel = (tr || state).selection;\r\n  const doc = (tr || state).doc;\r\n  let normalize;\r\n  let role;\r\n  if (sel instanceof NodeSelection2 && (role = sel.node.type.spec.tableRole)) {\r\n    if (role == \"cell\" || role == \"header_cell\") {\r\n      normalize = CellSelection.create(doc, sel.from);\r\n    } else if (role == \"row\") {\r\n      const $cell = doc.resolve(sel.from + 1);\r\n      normalize = CellSelection.rowSelection($cell, $cell);\r\n    } else if (!allowTableNodeSelection) {\r\n      const map = TableMap.get(sel.node);\r\n      const start = sel.from + 1;\r\n      const lastCell = start + map.map[map.width * map.height - 1];\r\n      normalize = CellSelection.create(doc, start + 1, lastCell);\r\n    }\r\n  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {\r\n    normalize = TextSelection.create(doc, sel.from);\r\n  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {\r\n    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());\r\n  }\r\n  if (normalize)\r\n    (tr || (tr = state.tr)).setSelection(normalize);\r\n  return tr;\r\n}\r\n\r\n// src/fixtables.ts\r\nimport { PluginKey as PluginKey2 } from \"prosemirror-state\";\r\nvar fixTablesKey = new PluginKey2(\"fix-tables\");\r\nfunction changedDescendants(old, cur, offset, f) {\r\n  const oldSize = old.childCount, curSize = cur.childCount;\r\n  outer:\r\n    for (let i = 0, j = 0; i < curSize; i++) {\r\n      const child = cur.child(i);\r\n      for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\r\n        if (old.child(scan) == child) {\r\n          j = scan + 1;\r\n          offset += child.nodeSize;\r\n          continue outer;\r\n        }\r\n      }\r\n      f(child, offset);\r\n      if (j < oldSize && old.child(j).sameMarkup(child))\r\n        changedDescendants(old.child(j), child, offset + 1, f);\r\n      else\r\n        child.nodesBetween(0, child.content.size, f, offset + 1);\r\n      offset += child.nodeSize;\r\n    }\r\n}\r\nfunction fixTables(state, oldState) {\r\n  let tr;\r\n  const check = (node, pos) => {\r\n    if (node.type.spec.tableRole == \"table\")\r\n      tr = fixTable(state, node, pos, tr);\r\n  };\r\n  if (!oldState)\r\n    state.doc.descendants(check);\r\n  else if (oldState.doc != state.doc)\r\n    changedDescendants(oldState.doc, state.doc, 0, check);\r\n  return tr;\r\n}\r\nfunction fixTable(state, table, tablePos, tr) {\r\n  const map = TableMap.get(table);\r\n  if (!map.problems)\r\n    return tr;\r\n  if (!tr)\r\n    tr = state.tr;\r\n  const mustAdd = [];\r\n  for (let i = 0; i < map.height; i++)\r\n    mustAdd.push(0);\r\n  for (let i = 0; i < map.problems.length; i++) {\r\n    const prob = map.problems[i];\r\n    if (prob.type == \"collision\") {\r\n      const cell = table.nodeAt(prob.pos);\r\n      if (!cell)\r\n        continue;\r\n      const attrs = cell.attrs;\r\n      for (let j = 0; j < attrs.rowspan; j++)\r\n        mustAdd[prob.row + j] += prob.n;\r\n      tr.setNodeMarkup(\r\n        tr.mapping.map(tablePos + 1 + prob.pos),\r\n        null,\r\n        removeColSpan(attrs, attrs.colspan - prob.n, prob.n)\r\n      );\r\n    } else if (prob.type == \"missing\") {\r\n      mustAdd[prob.row] += prob.n;\r\n    } else if (prob.type == \"overlong_rowspan\") {\r\n      const cell = table.nodeAt(prob.pos);\r\n      if (!cell)\r\n        continue;\r\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\r\n        ...cell.attrs,\r\n        rowspan: cell.attrs.rowspan - prob.n\r\n      });\r\n    } else if (prob.type == \"colwidth mismatch\") {\r\n      const cell = table.nodeAt(prob.pos);\r\n      if (!cell)\r\n        continue;\r\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\r\n        ...cell.attrs,\r\n        colwidth: prob.colwidth\r\n      });\r\n    }\r\n  }\r\n  let first, last;\r\n  for (let i = 0; i < mustAdd.length; i++)\r\n    if (mustAdd[i]) {\r\n      if (first == null)\r\n        first = i;\r\n      last = i;\r\n    }\r\n  for (let i = 0, pos = tablePos + 1; i < map.height; i++) {\r\n    const row = table.child(i);\r\n    const end = pos + row.nodeSize;\r\n    const add = mustAdd[i];\r\n    if (add > 0) {\r\n      let role = \"cell\";\r\n      if (row.firstChild) {\r\n        role = row.firstChild.type.spec.tableRole;\r\n      }\r\n      const nodes = [];\r\n      for (let j = 0; j < add; j++) {\r\n        const node = tableNodeTypes(state.schema)[role].createAndFill();\r\n        if (node)\r\n          nodes.push(node);\r\n      }\r\n      const side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;\r\n      tr.insert(tr.mapping.map(side), nodes);\r\n    }\r\n    pos = end;\r\n  }\r\n  return tr.setMeta(fixTablesKey, { fixTables: true });\r\n}\r\n\r\n// src/input.ts\r\nimport { keydownHandler } from \"prosemirror-keymap\";\r\nimport { Fragment as Fragment4 } from \"prosemirror-model\";\r\nimport {\r\n  Selection as Selection2,\r\n  TextSelection as TextSelection3\r\n} from \"prosemirror-state\";\r\n\r\n// src/commands.ts\r\nimport {\r\n  Fragment as Fragment2,\r\n  Slice as Slice2\r\n} from \"prosemirror-model\";\r\nimport {\r\n  TextSelection as TextSelection2\r\n} from \"prosemirror-state\";\r\nfunction selectedRect(state) {\r\n  const sel = state.selection;\r\n  const $pos = selectionCell(state);\r\n  const table = $pos.node(-1);\r\n  const tableStart = $pos.start(-1);\r\n  const map = TableMap.get(table);\r\n  const rect = sel instanceof CellSelection ? map.rectBetween(\r\n    sel.$anchorCell.pos - tableStart,\r\n    sel.$headCell.pos - tableStart\r\n  ) : map.findCell($pos.pos - tableStart);\r\n  return { ...rect, tableStart, map, table };\r\n}\r\nfunction addColumn(tr, { map, tableStart, table }, col) {\r\n  let refColumn = col > 0 ? -1 : 0;\r\n  if (columnIsHeader(map, table, col + refColumn)) {\r\n    refColumn = col == 0 || col == map.width ? null : 0;\r\n  }\r\n  for (let row = 0; row < map.height; row++) {\r\n    const index = row * map.width + col;\r\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\r\n      const pos = map.map[index];\r\n      const cell = table.nodeAt(pos);\r\n      tr.setNodeMarkup(\r\n        tr.mapping.map(tableStart + pos),\r\n        null,\r\n        addColSpan(cell.attrs, col - map.colCount(pos))\r\n      );\r\n      row += cell.attrs.rowspan - 1;\r\n    } else {\r\n      const type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refColumn]).type;\r\n      const pos = map.positionAt(row, col, table);\r\n      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());\r\n    }\r\n  }\r\n  return tr;\r\n}\r\nfunction addColumnBefore(state, dispatch) {\r\n  if (!isInTable(state))\r\n    return false;\r\n  if (dispatch) {\r\n    const rect = selectedRect(state);\r\n    dispatch(addColumn(state.tr, rect, rect.left));\r\n  }\r\n  return true;\r\n}\r\nfunction addColumnAfter(state, dispatch) {\r\n  if (!isInTable(state))\r\n    return false;\r\n  if (dispatch) {\r\n    const rect = selectedRect(state);\r\n    dispatch(addColumn(state.tr, rect, rect.right));\r\n  }\r\n  return true;\r\n}\r\nfunction removeColumn(tr, { map, table, tableStart }, col) {\r\n  const mapStart = tr.mapping.maps.length;\r\n  for (let row = 0; row < map.height; ) {\r\n    const index = row * map.width + col;\r\n    const pos = map.map[index];\r\n    const cell = table.nodeAt(pos);\r\n    const attrs = cell.attrs;\r\n    if (col > 0 && map.map[index - 1] == pos || col < map.width - 1 && map.map[index + 1] == pos) {\r\n      tr.setNodeMarkup(\r\n        tr.mapping.slice(mapStart).map(tableStart + pos),\r\n        null,\r\n        removeColSpan(attrs, col - map.colCount(pos))\r\n      );\r\n    } else {\r\n      const start = tr.mapping.slice(mapStart).map(tableStart + pos);\r\n      tr.delete(start, start + cell.nodeSize);\r\n    }\r\n    row += attrs.rowspan;\r\n  }\r\n}\r\nfunction deleteColumn(state, dispatch) {\r\n  if (!isInTable(state))\r\n    return false;\r\n  if (dispatch) {\r\n    const rect = selectedRect(state);\r\n    const tr = state.tr;\r\n    if (rect.left == 0 && rect.right == rect.map.width)\r\n      return false;\r\n    for (let i = rect.right - 1; ; i--) {\r\n      removeColumn(tr, rect, i);\r\n      if (i == rect.left)\r\n        break;\r\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\r\n      if (!table) {\r\n        throw RangeError(\"No table found\");\r\n      }\r\n      rect.table = table;\r\n      rect.map = TableMap.get(table);\r\n    }\r\n    dispatch(tr);\r\n  }\r\n  return true;\r\n}\r\nfunction rowIsHeader(map, table, row) {\r\n  var _a;\r\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\r\n  for (let col = 0; col < map.width; col++)\r\n    if (((_a = table.nodeAt(map.map[col + row * map.width])) == null ? void 0 : _a.type) != headerCell)\r\n      return false;\r\n  return true;\r\n}\r\nfunction addRow(tr, { map, tableStart, table }, row) {\r\n  var _a;\r\n  let rowPos = tableStart;\r\n  for (let i = 0; i < row; i++)\r\n    rowPos += table.child(i).nodeSize;\r\n  const cells = [];\r\n  let refRow = row > 0 ? -1 : 0;\r\n  if (rowIsHeader(map, table, row + refRow))\r\n    refRow = row == 0 || row == map.height ? null : 0;\r\n  for (let col = 0, index = map.width * row; col < map.width; col++, index++) {\r\n    if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\r\n      const pos = map.map[index];\r\n      const attrs = table.nodeAt(pos).attrs;\r\n      tr.setNodeMarkup(tableStart + pos, null, {\r\n        ...attrs,\r\n        rowspan: attrs.rowspan + 1\r\n      });\r\n      col += attrs.colspan - 1;\r\n    } else {\r\n      const type = refRow == null ? tableNodeTypes(table.type.schema).cell : (_a = table.nodeAt(map.map[index + refRow * map.width])) == null ? void 0 : _a.type;\r\n      const node = type == null ? void 0 : type.createAndFill();\r\n      if (node)\r\n        cells.push(node);\r\n    }\r\n  }\r\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\r\n  return tr;\r\n}\r\nfunction addRowBefore(state, dispatch) {\r\n  if (!isInTable(state))\r\n    return false;\r\n  if (dispatch) {\r\n    const rect = selectedRect(state);\r\n    dispatch(addRow(state.tr, rect, rect.top));\r\n  }\r\n  return true;\r\n}\r\nfunction addRowAfter(state, dispatch) {\r\n  if (!isInTable(state))\r\n    return false;\r\n  if (dispatch) {\r\n    const rect = selectedRect(state);\r\n    dispatch(addRow(state.tr, rect, rect.bottom));\r\n  }\r\n  return true;\r\n}\r\nfunction removeRow(tr, { map, table, tableStart }, row) {\r\n  let rowPos = 0;\r\n  for (let i = 0; i < row; i++)\r\n    rowPos += table.child(i).nodeSize;\r\n  const nextRow = rowPos + table.child(row).nodeSize;\r\n  const mapFrom = tr.mapping.maps.length;\r\n  tr.delete(rowPos + tableStart, nextRow + tableStart);\r\n  const seen = /* @__PURE__ */ new Set();\r\n  for (let col = 0, index = row * map.width; col < map.width; col++, index++) {\r\n    const pos = map.map[index];\r\n    if (seen.has(pos))\r\n      continue;\r\n    seen.add(pos);\r\n    if (row > 0 && pos == map.map[index - map.width]) {\r\n      const attrs = table.nodeAt(pos).attrs;\r\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, {\r\n        ...attrs,\r\n        rowspan: attrs.rowspan - 1\r\n      });\r\n      col += attrs.colspan - 1;\r\n    } else if (row < map.height && pos == map.map[index + map.width]) {\r\n      const cell = table.nodeAt(pos);\r\n      const attrs = cell.attrs;\r\n      const copy = cell.type.create(\r\n        { ...attrs, rowspan: cell.attrs.rowspan - 1 },\r\n        cell.content\r\n      );\r\n      const newPos = map.positionAt(row + 1, col, table);\r\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\r\n      col += attrs.colspan - 1;\r\n    }\r\n  }\r\n}\r\nfunction deleteRow(state, dispatch) {\r\n  if (!isInTable(state))\r\n    return false;\r\n  if (dispatch) {\r\n    const rect = selectedRect(state), tr = state.tr;\r\n    if (rect.top == 0 && rect.bottom == rect.map.height)\r\n      return false;\r\n    for (let i = rect.bottom - 1; ; i--) {\r\n      removeRow(tr, rect, i);\r\n      if (i == rect.top)\r\n        break;\r\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\r\n      if (!table) {\r\n        throw RangeError(\"No table found\");\r\n      }\r\n      rect.table = table;\r\n      rect.map = TableMap.get(rect.table);\r\n    }\r\n    dispatch(tr);\r\n  }\r\n  return true;\r\n}\r\nfunction isEmpty(cell) {\r\n  const c = cell.content;\r\n  return c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0;\r\n}\r\nfunction cellsOverlapRectangle({ width, height, map }, rect) {\r\n  let indexTop = rect.top * width + rect.left, indexLeft = indexTop;\r\n  let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);\r\n  for (let i = rect.top; i < rect.bottom; i++) {\r\n    if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] || rect.right < width && map[indexRight] == map[indexRight + 1])\r\n      return true;\r\n    indexLeft += width;\r\n    indexRight += width;\r\n  }\r\n  for (let i = rect.left; i < rect.right; i++) {\r\n    if (rect.top > 0 && map[indexTop] == map[indexTop - width] || rect.bottom < height && map[indexBottom] == map[indexBottom + width])\r\n      return true;\r\n    indexTop++;\r\n    indexBottom++;\r\n  }\r\n  return false;\r\n}\r\nfunction mergeCells(state, dispatch) {\r\n  const sel = state.selection;\r\n  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos)\r\n    return false;\r\n  const rect = selectedRect(state), { map } = rect;\r\n  if (cellsOverlapRectangle(map, rect))\r\n    return false;\r\n  if (dispatch) {\r\n    const tr = state.tr;\r\n    const seen = {};\r\n    let content = Fragment2.empty;\r\n    let mergedPos;\r\n    let mergedCell;\r\n    for (let row = rect.top; row < rect.bottom; row++) {\r\n      for (let col = rect.left; col < rect.right; col++) {\r\n        const cellPos = map.map[row * map.width + col];\r\n        const cell = rect.table.nodeAt(cellPos);\r\n        if (seen[cellPos] || !cell)\r\n          continue;\r\n        seen[cellPos] = true;\r\n        if (mergedPos == null) {\r\n          mergedPos = cellPos;\r\n          mergedCell = cell;\r\n        } else {\r\n          if (!isEmpty(cell))\r\n            content = content.append(cell.content);\r\n          const mapped = tr.mapping.map(cellPos + rect.tableStart);\r\n          tr.delete(mapped, mapped + cell.nodeSize);\r\n        }\r\n      }\r\n    }\r\n    if (mergedPos == null || mergedCell == null) {\r\n      return true;\r\n    }\r\n    tr.setNodeMarkup(mergedPos + rect.tableStart, null, {\r\n      ...addColSpan(\r\n        mergedCell.attrs,\r\n        mergedCell.attrs.colspan,\r\n        rect.right - rect.left - mergedCell.attrs.colspan\r\n      ),\r\n      rowspan: rect.bottom - rect.top\r\n    });\r\n    if (content.size) {\r\n      const end = mergedPos + 1 + mergedCell.content.size;\r\n      const start = isEmpty(mergedCell) ? mergedPos + 1 : end;\r\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\r\n    }\r\n    tr.setSelection(\r\n      new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart))\r\n    );\r\n    dispatch(tr);\r\n  }\r\n  return true;\r\n}\r\nfunction splitCell(state, dispatch) {\r\n  const nodeTypes = tableNodeTypes(state.schema);\r\n  return splitCellWithType(({ node }) => {\r\n    return nodeTypes[node.type.spec.tableRole];\r\n  })(state, dispatch);\r\n}\r\nfunction splitCellWithType(getCellType) {\r\n  return (state, dispatch) => {\r\n    var _a;\r\n    const sel = state.selection;\r\n    let cellNode;\r\n    let cellPos;\r\n    if (!(sel instanceof CellSelection)) {\r\n      cellNode = cellWrapping(sel.$from);\r\n      if (!cellNode)\r\n        return false;\r\n      cellPos = (_a = cellAround(sel.$from)) == null ? void 0 : _a.pos;\r\n    } else {\r\n      if (sel.$anchorCell.pos != sel.$headCell.pos)\r\n        return false;\r\n      cellNode = sel.$anchorCell.nodeAfter;\r\n      cellPos = sel.$anchorCell.pos;\r\n    }\r\n    if (cellNode == null || cellPos == null) {\r\n      return false;\r\n    }\r\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {\r\n      return false;\r\n    }\r\n    if (dispatch) {\r\n      let baseAttrs = cellNode.attrs;\r\n      const attrs = [];\r\n      const colwidth = baseAttrs.colwidth;\r\n      if (baseAttrs.rowspan > 1)\r\n        baseAttrs = { ...baseAttrs, rowspan: 1 };\r\n      if (baseAttrs.colspan > 1)\r\n        baseAttrs = { ...baseAttrs, colspan: 1 };\r\n      const rect = selectedRect(state), tr = state.tr;\r\n      for (let i = 0; i < rect.right - rect.left; i++)\r\n        attrs.push(\r\n          colwidth ? {\r\n            ...baseAttrs,\r\n            colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null\r\n          } : baseAttrs\r\n        );\r\n      let lastCell;\r\n      for (let row = rect.top; row < rect.bottom; row++) {\r\n        let pos = rect.map.positionAt(row, rect.left, rect.table);\r\n        if (row == rect.top)\r\n          pos += cellNode.nodeSize;\r\n        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {\r\n          if (col == rect.left && row == rect.top)\r\n            continue;\r\n          tr.insert(\r\n            lastCell = tr.mapping.map(pos + rect.tableStart, 1),\r\n            getCellType({ node: cellNode, row, col }).createAndFill(attrs[i])\r\n          );\r\n        }\r\n      }\r\n      tr.setNodeMarkup(\r\n        cellPos,\r\n        getCellType({ node: cellNode, row: rect.top, col: rect.left }),\r\n        attrs[0]\r\n      );\r\n      if (sel instanceof CellSelection)\r\n        tr.setSelection(\r\n          new CellSelection(\r\n            tr.doc.resolve(sel.$anchorCell.pos),\r\n            lastCell ? tr.doc.resolve(lastCell) : void 0\r\n          )\r\n        );\r\n      dispatch(tr);\r\n    }\r\n    return true;\r\n  };\r\n}\r\nfunction setCellAttr(name, value) {\r\n  return function(state, dispatch) {\r\n    if (!isInTable(state))\r\n      return false;\r\n    const $cell = selectionCell(state);\r\n    if ($cell.nodeAfter.attrs[name] === value)\r\n      return false;\r\n    if (dispatch) {\r\n      const tr = state.tr;\r\n      if (state.selection instanceof CellSelection)\r\n        state.selection.forEachCell((node, pos) => {\r\n          if (node.attrs[name] !== value)\r\n            tr.setNodeMarkup(pos, null, {\r\n              ...node.attrs,\r\n              [name]: value\r\n            });\r\n        });\r\n      else\r\n        tr.setNodeMarkup($cell.pos, null, {\r\n          ...$cell.nodeAfter.attrs,\r\n          [name]: value\r\n        });\r\n      dispatch(tr);\r\n    }\r\n    return true;\r\n  };\r\n}\r\nfunction deprecated_toggleHeader(type) {\r\n  return function(state, dispatch) {\r\n    if (!isInTable(state))\r\n      return false;\r\n    if (dispatch) {\r\n      const types = tableNodeTypes(state.schema);\r\n      const rect = selectedRect(state), tr = state.tr;\r\n      const cells = rect.map.cellsInRect(\r\n        type == \"column\" ? {\r\n          left: rect.left,\r\n          top: 0,\r\n          right: rect.right,\r\n          bottom: rect.map.height\r\n        } : type == \"row\" ? {\r\n          left: 0,\r\n          top: rect.top,\r\n          right: rect.map.width,\r\n          bottom: rect.bottom\r\n        } : rect\r\n      );\r\n      const nodes = cells.map((pos) => rect.table.nodeAt(pos));\r\n      for (let i = 0; i < cells.length; i++)\r\n        if (nodes[i].type == types.header_cell)\r\n          tr.setNodeMarkup(\r\n            rect.tableStart + cells[i],\r\n            types.cell,\r\n            nodes[i].attrs\r\n          );\r\n      if (tr.steps.length == 0)\r\n        for (let i = 0; i < cells.length; i++)\r\n          tr.setNodeMarkup(\r\n            rect.tableStart + cells[i],\r\n            types.header_cell,\r\n            nodes[i].attrs\r\n          );\r\n      dispatch(tr);\r\n    }\r\n    return true;\r\n  };\r\n}\r\nfunction isHeaderEnabledByType(type, rect, types) {\r\n  const cellPositions = rect.map.cellsInRect({\r\n    left: 0,\r\n    top: 0,\r\n    right: type == \"row\" ? rect.map.width : 1,\r\n    bottom: type == \"column\" ? rect.map.height : 1\r\n  });\r\n  for (let i = 0; i < cellPositions.length; i++) {\r\n    const cell = rect.table.nodeAt(cellPositions[i]);\r\n    if (cell && cell.type !== types.header_cell) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\nfunction toggleHeader(type, options) {\r\n  options = options || { useDeprecatedLogic: false };\r\n  if (options.useDeprecatedLogic)\r\n    return deprecated_toggleHeader(type);\r\n  return function(state, dispatch) {\r\n    if (!isInTable(state))\r\n      return false;\r\n    if (dispatch) {\r\n      const types = tableNodeTypes(state.schema);\r\n      const rect = selectedRect(state), tr = state.tr;\r\n      const isHeaderRowEnabled = isHeaderEnabledByType(\"row\", rect, types);\r\n      const isHeaderColumnEnabled = isHeaderEnabledByType(\r\n        \"column\",\r\n        rect,\r\n        types\r\n      );\r\n      const isHeaderEnabled = type === \"column\" ? isHeaderRowEnabled : type === \"row\" ? isHeaderColumnEnabled : false;\r\n      const selectionStartsAt = isHeaderEnabled ? 1 : 0;\r\n      const cellsRect = type == \"column\" ? {\r\n        left: 0,\r\n        top: selectionStartsAt,\r\n        right: 1,\r\n        bottom: rect.map.height\r\n      } : type == \"row\" ? {\r\n        left: selectionStartsAt,\r\n        top: 0,\r\n        right: rect.map.width,\r\n        bottom: 1\r\n      } : rect;\r\n      const newType = type == \"column\" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == \"row\" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;\r\n      rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {\r\n        const cellPos = relativeCellPos + rect.tableStart;\r\n        const cell = tr.doc.nodeAt(cellPos);\r\n        if (cell) {\r\n          tr.setNodeMarkup(cellPos, newType, cell.attrs);\r\n        }\r\n      });\r\n      dispatch(tr);\r\n    }\r\n    return true;\r\n  };\r\n}\r\nvar toggleHeaderRow = toggleHeader(\"row\", {\r\n  useDeprecatedLogic: true\r\n});\r\nvar toggleHeaderColumn = toggleHeader(\"column\", {\r\n  useDeprecatedLogic: true\r\n});\r\nvar toggleHeaderCell = toggleHeader(\"cell\", {\r\n  useDeprecatedLogic: true\r\n});\r\nfunction findNextCell($cell, dir) {\r\n  if (dir < 0) {\r\n    const before = $cell.nodeBefore;\r\n    if (before)\r\n      return $cell.pos - before.nodeSize;\r\n    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {\r\n      const rowNode = $cell.node(-1).child(row);\r\n      const lastChild = rowNode.lastChild;\r\n      if (lastChild) {\r\n        return rowEnd - 1 - lastChild.nodeSize;\r\n      }\r\n      rowEnd -= rowNode.nodeSize;\r\n    }\r\n  } else {\r\n    if ($cell.index() < $cell.parent.childCount - 1) {\r\n      return $cell.pos + $cell.nodeAfter.nodeSize;\r\n    }\r\n    const table = $cell.node(-1);\r\n    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {\r\n      const rowNode = table.child(row);\r\n      if (rowNode.childCount)\r\n        return rowStart + 1;\r\n      rowStart += rowNode.nodeSize;\r\n    }\r\n  }\r\n  return null;\r\n}\r\nfunction goToNextCell(direction) {\r\n  return function(state, dispatch) {\r\n    if (!isInTable(state))\r\n      return false;\r\n    const cell = findNextCell(selectionCell(state), direction);\r\n    if (cell == null)\r\n      return false;\r\n    if (dispatch) {\r\n      const $cell = state.doc.resolve(cell);\r\n      dispatch(\r\n        state.tr.setSelection(TextSelection2.between($cell, moveCellForward($cell))).scrollIntoView()\r\n      );\r\n    }\r\n    return true;\r\n  };\r\n}\r\nfunction deleteTable(state, dispatch) {\r\n  const $pos = state.selection.$anchor;\r\n  for (let d = $pos.depth; d > 0; d--) {\r\n    const node = $pos.node(d);\r\n    if (node.type.spec.tableRole == \"table\") {\r\n      if (dispatch)\r\n        dispatch(\r\n          state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView()\r\n        );\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\nfunction deleteCellSelection(state, dispatch) {\r\n  const sel = state.selection;\r\n  if (!(sel instanceof CellSelection))\r\n    return false;\r\n  if (dispatch) {\r\n    const tr = state.tr;\r\n    const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\r\n    sel.forEachCell((cell, pos) => {\r\n      if (!cell.content.eq(baseContent))\r\n        tr.replace(\r\n          tr.mapping.map(pos + 1),\r\n          tr.mapping.map(pos + cell.nodeSize - 1),\r\n          new Slice2(baseContent, 0, 0)\r\n        );\r\n    });\r\n    if (tr.docChanged)\r\n      dispatch(tr);\r\n  }\r\n  return true;\r\n}\r\n\r\n// src/copypaste.ts\r\nimport { Fragment as Fragment3, Slice as Slice3 } from \"prosemirror-model\";\r\nimport { Transform } from \"prosemirror-transform\";\r\nfunction pastedCells(slice) {\r\n  if (!slice.size)\r\n    return null;\r\n  let { content, openStart, openEnd } = slice;\r\n  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.child(0).type.spec.tableRole == \"table\")) {\r\n    openStart--;\r\n    openEnd--;\r\n    content = content.child(0).content;\r\n  }\r\n  const first = content.child(0);\r\n  const role = first.type.spec.tableRole;\r\n  const schema = first.type.schema, rows = [];\r\n  if (role == \"row\") {\r\n    for (let i = 0; i < content.childCount; i++) {\r\n      let cells = content.child(i).content;\r\n      const left = i ? 0 : Math.max(0, openStart - 1);\r\n      const right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\r\n      if (left || right)\r\n        cells = fitSlice(\r\n          tableNodeTypes(schema).row,\r\n          new Slice3(cells, left, right)\r\n        ).content;\r\n      rows.push(cells);\r\n    }\r\n  } else if (role == \"cell\" || role == \"header_cell\") {\r\n    rows.push(\r\n      openStart || openEnd ? fitSlice(\r\n        tableNodeTypes(schema).row,\r\n        new Slice3(content, openStart, openEnd)\r\n      ).content : content\r\n    );\r\n  } else {\r\n    return null;\r\n  }\r\n  return ensureRectangular(schema, rows);\r\n}\r\nfunction ensureRectangular(schema, rows) {\r\n  const widths = [];\r\n  for (let i = 0; i < rows.length; i++) {\r\n    const row = rows[i];\r\n    for (let j = row.childCount - 1; j >= 0; j--) {\r\n      const { rowspan, colspan } = row.child(j).attrs;\r\n      for (let r = i; r < i + rowspan; r++)\r\n        widths[r] = (widths[r] || 0) + colspan;\r\n    }\r\n  }\r\n  let width = 0;\r\n  for (let r = 0; r < widths.length; r++)\r\n    width = Math.max(width, widths[r]);\r\n  for (let r = 0; r < widths.length; r++) {\r\n    if (r >= rows.length)\r\n      rows.push(Fragment3.empty);\r\n    if (widths[r] < width) {\r\n      const empty = tableNodeTypes(schema).cell.createAndFill();\r\n      const cells = [];\r\n      for (let i = widths[r]; i < width; i++) {\r\n        cells.push(empty);\r\n      }\r\n      rows[r] = rows[r].append(Fragment3.from(cells));\r\n    }\r\n  }\r\n  return { height: rows.length, width, rows };\r\n}\r\nfunction fitSlice(nodeType, slice) {\r\n  const node = nodeType.createAndFill();\r\n  const tr = new Transform(node).replace(0, node.content.size, slice);\r\n  return tr.doc;\r\n}\r\nfunction clipCells({ width, height, rows }, newWidth, newHeight) {\r\n  if (width != newWidth) {\r\n    const added = [];\r\n    const newRows = [];\r\n    for (let row = 0; row < rows.length; row++) {\r\n      const frag = rows[row], cells = [];\r\n      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {\r\n        let cell = frag.child(i % frag.childCount);\r\n        if (col + cell.attrs.colspan > newWidth)\r\n          cell = cell.type.createChecked(\r\n            removeColSpan(\r\n              cell.attrs,\r\n              cell.attrs.colspan,\r\n              col + cell.attrs.colspan - newWidth\r\n            ),\r\n            cell.content\r\n          );\r\n        cells.push(cell);\r\n        col += cell.attrs.colspan;\r\n        for (let j = 1; j < cell.attrs.rowspan; j++)\r\n          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;\r\n      }\r\n      newRows.push(Fragment3.from(cells));\r\n    }\r\n    rows = newRows;\r\n    width = newWidth;\r\n  }\r\n  if (height != newHeight) {\r\n    const newRows = [];\r\n    for (let row = 0, i = 0; row < newHeight; row++, i++) {\r\n      const cells = [], source = rows[i % height];\r\n      for (let j = 0; j < source.childCount; j++) {\r\n        let cell = source.child(j);\r\n        if (row + cell.attrs.rowspan > newHeight)\r\n          cell = cell.type.create(\r\n            {\r\n              ...cell.attrs,\r\n              rowspan: Math.max(1, newHeight - cell.attrs.rowspan)\r\n            },\r\n            cell.content\r\n          );\r\n        cells.push(cell);\r\n      }\r\n      newRows.push(Fragment3.from(cells));\r\n    }\r\n    rows = newRows;\r\n    height = newHeight;\r\n  }\r\n  return { width, height, rows };\r\n}\r\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\r\n  const schema = tr.doc.type.schema;\r\n  const types = tableNodeTypes(schema);\r\n  let empty;\r\n  let emptyHead;\r\n  if (width > map.width) {\r\n    for (let row = 0, rowEnd = 0; row < map.height; row++) {\r\n      const rowNode = table.child(row);\r\n      rowEnd += rowNode.nodeSize;\r\n      const cells = [];\r\n      let add;\r\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)\r\n        add = empty || (empty = types.cell.createAndFill());\r\n      else\r\n        add = emptyHead || (emptyHead = types.header_cell.createAndFill());\r\n      for (let i = map.width; i < width; i++)\r\n        cells.push(add);\r\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\r\n    }\r\n  }\r\n  if (height > map.height) {\r\n    const cells = [];\r\n    for (let i = 0, start2 = (map.height - 1) * map.width; i < Math.max(map.width, width); i++) {\r\n      const header = i >= map.width ? false : table.nodeAt(map.map[start2 + i]).type == types.header_cell;\r\n      cells.push(\r\n        header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty || (empty = types.cell.createAndFill())\r\n      );\r\n    }\r\n    const emptyRow = types.row.create(null, Fragment3.from(cells)), rows = [];\r\n    for (let i = map.height; i < height; i++)\r\n      rows.push(emptyRow);\r\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\r\n  }\r\n  return !!(empty || emptyHead);\r\n}\r\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\r\n  if (top == 0 || top == map.height)\r\n    return false;\r\n  let found = false;\r\n  for (let col = left; col < right; col++) {\r\n    const index = top * map.width + col, pos = map.map[index];\r\n    if (map.map[index - map.width] == pos) {\r\n      found = true;\r\n      const cell = table.nodeAt(pos);\r\n      const { top: cellTop, left: cellLeft } = map.findCell(pos);\r\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, {\r\n        ...cell.attrs,\r\n        rowspan: top - cellTop\r\n      });\r\n      tr.insert(\r\n        tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)),\r\n        cell.type.createAndFill({\r\n          ...cell.attrs,\r\n          rowspan: cellTop + cell.attrs.rowspan - top\r\n        })\r\n      );\r\n      col += cell.attrs.colspan - 1;\r\n    }\r\n  }\r\n  return found;\r\n}\r\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\r\n  if (left == 0 || left == map.width)\r\n    return false;\r\n  let found = false;\r\n  for (let row = top; row < bottom; row++) {\r\n    const index = row * map.width + left, pos = map.map[index];\r\n    if (map.map[index - 1] == pos) {\r\n      found = true;\r\n      const cell = table.nodeAt(pos);\r\n      const cellLeft = map.colCount(pos);\r\n      const updatePos = tr.mapping.slice(mapFrom).map(pos + start);\r\n      tr.setNodeMarkup(\r\n        updatePos,\r\n        null,\r\n        removeColSpan(\r\n          cell.attrs,\r\n          left - cellLeft,\r\n          cell.attrs.colspan - (left - cellLeft)\r\n        )\r\n      );\r\n      tr.insert(\r\n        updatePos + cell.nodeSize,\r\n        cell.type.createAndFill(\r\n          removeColSpan(cell.attrs, 0, left - cellLeft)\r\n        )\r\n      );\r\n      row += cell.attrs.rowspan - 1;\r\n    }\r\n  }\r\n  return found;\r\n}\r\nfunction insertCells(state, dispatch, tableStart, rect, cells) {\r\n  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;\r\n  if (!table) {\r\n    throw new Error(\"No table found\");\r\n  }\r\n  let map = TableMap.get(table);\r\n  const { top, left } = rect;\r\n  const right = left + cells.width, bottom = top + cells.height;\r\n  const tr = state.tr;\r\n  let mapFrom = 0;\r\n  function recomp() {\r\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\r\n    if (!table) {\r\n      throw new Error(\"No table found\");\r\n    }\r\n    map = TableMap.get(table);\r\n    mapFrom = tr.mapping.maps.length;\r\n  }\r\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom))\r\n    recomp();\r\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom))\r\n    recomp();\r\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom))\r\n    recomp();\r\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom))\r\n    recomp();\r\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom))\r\n    recomp();\r\n  for (let row = top; row < bottom; row++) {\r\n    const from = map.positionAt(row, left, table), to = map.positionAt(row, right, table);\r\n    tr.replace(\r\n      tr.mapping.slice(mapFrom).map(from + tableStart),\r\n      tr.mapping.slice(mapFrom).map(to + tableStart),\r\n      new Slice3(cells.rows[row - top], 0, 0)\r\n    );\r\n  }\r\n  recomp();\r\n  tr.setSelection(\r\n    new CellSelection(\r\n      tr.doc.resolve(tableStart + map.positionAt(top, left, table)),\r\n      tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))\r\n    )\r\n  );\r\n  dispatch(tr);\r\n}\r\n\r\n// src/input.ts\r\nvar handleKeyDown = keydownHandler({\r\n  ArrowLeft: arrow(\"horiz\", -1),\r\n  ArrowRight: arrow(\"horiz\", 1),\r\n  ArrowUp: arrow(\"vert\", -1),\r\n  ArrowDown: arrow(\"vert\", 1),\r\n  \"Shift-ArrowLeft\": shiftArrow(\"horiz\", -1),\r\n  \"Shift-ArrowRight\": shiftArrow(\"horiz\", 1),\r\n  \"Shift-ArrowUp\": shiftArrow(\"vert\", -1),\r\n  \"Shift-ArrowDown\": shiftArrow(\"vert\", 1),\r\n  Backspace: deleteCellSelection,\r\n  \"Mod-Backspace\": deleteCellSelection,\r\n  Delete: deleteCellSelection,\r\n  \"Mod-Delete\": deleteCellSelection\r\n});\r\nfunction maybeSetSelection(state, dispatch, selection) {\r\n  if (selection.eq(state.selection))\r\n    return false;\r\n  if (dispatch)\r\n    dispatch(state.tr.setSelection(selection).scrollIntoView());\r\n  return true;\r\n}\r\nfunction arrow(axis, dir) {\r\n  return (state, dispatch, view) => {\r\n    if (!view)\r\n      return false;\r\n    const sel = state.selection;\r\n    if (sel instanceof CellSelection) {\r\n      return maybeSetSelection(\r\n        state,\r\n        dispatch,\r\n        Selection2.near(sel.$headCell, dir)\r\n      );\r\n    }\r\n    if (axis != \"horiz\" && !sel.empty)\r\n      return false;\r\n    const end = atEndOfCell(view, axis, dir);\r\n    if (end == null)\r\n      return false;\r\n    if (axis == \"horiz\") {\r\n      return maybeSetSelection(\r\n        state,\r\n        dispatch,\r\n        Selection2.near(state.doc.resolve(sel.head + dir), dir)\r\n      );\r\n    } else {\r\n      const $cell = state.doc.resolve(end);\r\n      const $next = nextCell($cell, axis, dir);\r\n      let newSel;\r\n      if ($next)\r\n        newSel = Selection2.near($next, 1);\r\n      else if (dir < 0)\r\n        newSel = Selection2.near(state.doc.resolve($cell.before(-1)), -1);\r\n      else\r\n        newSel = Selection2.near(state.doc.resolve($cell.after(-1)), 1);\r\n      return maybeSetSelection(state, dispatch, newSel);\r\n    }\r\n  };\r\n}\r\nfunction shiftArrow(axis, dir) {\r\n  return (state, dispatch, view) => {\r\n    if (!view)\r\n      return false;\r\n    const sel = state.selection;\r\n    let cellSel;\r\n    if (sel instanceof CellSelection) {\r\n      cellSel = sel;\r\n    } else {\r\n      const end = atEndOfCell(view, axis, dir);\r\n      if (end == null)\r\n        return false;\r\n      cellSel = new CellSelection(state.doc.resolve(end));\r\n    }\r\n    const $head = nextCell(cellSel.$headCell, axis, dir);\r\n    if (!$head)\r\n      return false;\r\n    return maybeSetSelection(\r\n      state,\r\n      dispatch,\r\n      new CellSelection(cellSel.$anchorCell, $head)\r\n    );\r\n  };\r\n}\r\nfunction handleTripleClick(view, pos) {\r\n  const doc = view.state.doc, $cell = cellAround(doc.resolve(pos));\r\n  if (!$cell)\r\n    return false;\r\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\r\n  return true;\r\n}\r\nfunction handlePaste(view, _, slice) {\r\n  if (!isInTable(view.state))\r\n    return false;\r\n  let cells = pastedCells(slice);\r\n  const sel = view.state.selection;\r\n  if (sel instanceof CellSelection) {\r\n    if (!cells)\r\n      cells = {\r\n        width: 1,\r\n        height: 1,\r\n        rows: [\r\n          Fragment4.from(\r\n            fitSlice(tableNodeTypes(view.state.schema).cell, slice)\r\n          )\r\n        ]\r\n      };\r\n    const table = sel.$anchorCell.node(-1);\r\n    const start = sel.$anchorCell.start(-1);\r\n    const rect = TableMap.get(table).rectBetween(\r\n      sel.$anchorCell.pos - start,\r\n      sel.$headCell.pos - start\r\n    );\r\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\r\n    insertCells(view.state, view.dispatch, start, rect, cells);\r\n    return true;\r\n  } else if (cells) {\r\n    const $cell = selectionCell(view.state);\r\n    const start = $cell.start(-1);\r\n    insertCells(\r\n      view.state,\r\n      view.dispatch,\r\n      start,\r\n      TableMap.get($cell.node(-1)).findCell($cell.pos - start),\r\n      cells\r\n    );\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\nfunction handleMouseDown(view, startEvent) {\r\n  var _a;\r\n  if (startEvent.ctrlKey || startEvent.metaKey)\r\n    return;\r\n  const startDOMCell = domInCell(view, startEvent.target);\r\n  let $anchor;\r\n  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\r\n    setCellSelection(view.state.selection.$anchorCell, startEvent);\r\n    startEvent.preventDefault();\r\n  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a = cellUnderMouse(view, startEvent)) == null ? void 0 : _a.pos) != $anchor.pos) {\r\n    setCellSelection($anchor, startEvent);\r\n    startEvent.preventDefault();\r\n  } else if (!startDOMCell) {\r\n    return;\r\n  }\r\n  function setCellSelection($anchor2, event) {\r\n    let $head = cellUnderMouse(view, event);\r\n    const starting = tableEditingKey.getState(view.state) == null;\r\n    if (!$head || !inSameTable($anchor2, $head)) {\r\n      if (starting)\r\n        $head = $anchor2;\r\n      else\r\n        return;\r\n    }\r\n    const selection = new CellSelection($anchor2, $head);\r\n    if (starting || !view.state.selection.eq(selection)) {\r\n      const tr = view.state.tr.setSelection(selection);\r\n      if (starting)\r\n        tr.setMeta(tableEditingKey, $anchor2.pos);\r\n      view.dispatch(tr);\r\n    }\r\n  }\r\n  function stop() {\r\n    view.root.removeEventListener(\"mouseup\", stop);\r\n    view.root.removeEventListener(\"dragstart\", stop);\r\n    view.root.removeEventListener(\"mousemove\", move);\r\n    if (tableEditingKey.getState(view.state) != null)\r\n      view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));\r\n  }\r\n  function move(_event) {\r\n    const event = _event;\r\n    const anchor = tableEditingKey.getState(view.state);\r\n    let $anchor2;\r\n    if (anchor != null) {\r\n      $anchor2 = view.state.doc.resolve(anchor);\r\n    } else if (domInCell(view, event.target) != startDOMCell) {\r\n      $anchor2 = cellUnderMouse(view, startEvent);\r\n      if (!$anchor2)\r\n        return stop();\r\n    }\r\n    if ($anchor2)\r\n      setCellSelection($anchor2, event);\r\n  }\r\n  view.root.addEventListener(\"mouseup\", stop);\r\n  view.root.addEventListener(\"dragstart\", stop);\r\n  view.root.addEventListener(\"mousemove\", move);\r\n}\r\nfunction atEndOfCell(view, axis, dir) {\r\n  if (!(view.state.selection instanceof TextSelection3))\r\n    return null;\r\n  const { $head } = view.state.selection;\r\n  for (let d = $head.depth - 1; d >= 0; d--) {\r\n    const parent = $head.node(d), index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\r\n    if (index != (dir < 0 ? 0 : parent.childCount))\r\n      return null;\r\n    if (parent.type.spec.tableRole == \"cell\" || parent.type.spec.tableRole == \"header_cell\") {\r\n      const cellPos = $head.before(d);\r\n      const dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\r\n      return view.endOfTextblock(dirStr) ? cellPos : null;\r\n    }\r\n  }\r\n  return null;\r\n}\r\nfunction domInCell(view, dom) {\r\n  for (; dom && dom != view.dom; dom = dom.parentNode) {\r\n    if (dom.nodeName == \"TD\" || dom.nodeName == \"TH\") {\r\n      return dom;\r\n    }\r\n  }\r\n  return null;\r\n}\r\nfunction cellUnderMouse(view, event) {\r\n  const mousePos = view.posAtCoords({\r\n    left: event.clientX,\r\n    top: event.clientY\r\n  });\r\n  if (!mousePos)\r\n    return null;\r\n  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;\r\n}\r\n\r\n// src/columnresizing.ts\r\nimport { Plugin, PluginKey as PluginKey3 } from \"prosemirror-state\";\r\nimport {\r\n  Decoration as Decoration2,\r\n  DecorationSet as DecorationSet2\r\n} from \"prosemirror-view\";\r\n\r\n// src/tableview.ts\r\nvar TableView = class {\r\n  constructor(node, cellMinWidth) {\r\n    this.node = node;\r\n    this.cellMinWidth = cellMinWidth;\r\n    this.dom = document.createElement(\"div\");\r\n    this.dom.className = \"tableWrapper\";\r\n    this.table = this.dom.appendChild(document.createElement(\"table\"));\r\n    this.colgroup = this.table.appendChild(document.createElement(\"colgroup\"));\r\n    updateColumnsOnResize(node, this.colgroup, this.table, cellMinWidth);\r\n    this.contentDOM = this.table.appendChild(document.createElement(\"tbody\"));\r\n  }\r\n  update(node) {\r\n    if (node.type != this.node.type)\r\n      return false;\r\n    this.node = node;\r\n    updateColumnsOnResize(node, this.colgroup, this.table, this.cellMinWidth);\r\n    return true;\r\n  }\r\n  ignoreMutation(record) {\r\n    return record.type == \"attributes\" && (record.target == this.table || this.colgroup.contains(record.target));\r\n  }\r\n};\r\nfunction updateColumnsOnResize(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\r\n  var _a;\r\n  let totalWidth = 0;\r\n  let fixedWidth = true;\r\n  let nextDOM = colgroup.firstChild;\r\n  const row = node.firstChild;\r\n  if (!row)\r\n    return;\r\n  for (let i = 0, col = 0; i < row.childCount; i++) {\r\n    const { colspan, colwidth } = row.child(i).attrs;\r\n    for (let j = 0; j < colspan; j++, col++) {\r\n      const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];\r\n      const cssWidth = hasWidth ? hasWidth + \"px\" : \"\";\r\n      totalWidth += hasWidth || cellMinWidth;\r\n      if (!hasWidth)\r\n        fixedWidth = false;\r\n      if (!nextDOM) {\r\n        colgroup.appendChild(document.createElement(\"col\")).style.width = cssWidth;\r\n      } else {\r\n        if (nextDOM.style.width != cssWidth)\r\n          nextDOM.style.width = cssWidth;\r\n        nextDOM = nextDOM.nextSibling;\r\n      }\r\n    }\r\n  }\r\n  while (nextDOM) {\r\n    const after = nextDOM.nextSibling;\r\n    (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);\r\n    nextDOM = after;\r\n  }\r\n  if (fixedWidth) {\r\n    table.style.width = totalWidth + \"px\";\r\n    table.style.minWidth = \"\";\r\n  } else {\r\n    table.style.width = \"\";\r\n    table.style.minWidth = totalWidth + \"px\";\r\n  }\r\n}\r\n\r\n// src/columnresizing.ts\r\nvar columnResizingPluginKey = new PluginKey3(\r\n  \"tableColumnResizing\"\r\n);\r\nfunction columnResizing({\r\n  handleWidth = 5,\r\n  cellMinWidth = 25,\r\n  View = TableView,\r\n  lastColumnResizable = true\r\n} = {}) {\r\n  const plugin = new Plugin({\r\n    key: columnResizingPluginKey,\r\n    state: {\r\n      init(_, state) {\r\n        var _a, _b;\r\n        const nodeViews = (_b = (_a = plugin.spec) == null ? void 0 : _a.props) == null ? void 0 : _b.nodeViews;\r\n        const tableName = tableNodeTypes(state.schema).table.name;\r\n        if (View && nodeViews) {\r\n          nodeViews[tableName] = (node, view) => {\r\n            return new View(node, cellMinWidth, view);\r\n          };\r\n        }\r\n        return new ResizeState(-1, false);\r\n      },\r\n      apply(tr, prev) {\r\n        return prev.apply(tr);\r\n      }\r\n    },\r\n    props: {\r\n      attributes: (state) => {\r\n        const pluginState = columnResizingPluginKey.getState(state);\r\n        return pluginState && pluginState.activeHandle > -1 ? { class: \"resize-cursor\" } : {};\r\n      },\r\n      handleDOMEvents: {\r\n        mousemove: (view, event) => {\r\n          handleMouseMove(\r\n            view,\r\n            event,\r\n            handleWidth,\r\n            cellMinWidth,\r\n            lastColumnResizable\r\n          );\r\n        },\r\n        mouseleave: (view) => {\r\n          handleMouseLeave(view);\r\n        },\r\n        mousedown: (view, event) => {\r\n          handleMouseDown2(view, event, cellMinWidth);\r\n        }\r\n      },\r\n      decorations: (state) => {\r\n        const pluginState = columnResizingPluginKey.getState(state);\r\n        if (pluginState && pluginState.activeHandle > -1) {\r\n          return handleDecorations(state, pluginState.activeHandle);\r\n        }\r\n      },\r\n      nodeViews: {}\r\n    }\r\n  });\r\n  return plugin;\r\n}\r\nvar ResizeState = class _ResizeState {\r\n  constructor(activeHandle, dragging) {\r\n    this.activeHandle = activeHandle;\r\n    this.dragging = dragging;\r\n  }\r\n  apply(tr) {\r\n    const state = this;\r\n    const action = tr.getMeta(columnResizingPluginKey);\r\n    if (action && action.setHandle != null)\r\n      return new _ResizeState(action.setHandle, false);\r\n    if (action && action.setDragging !== void 0)\r\n      return new _ResizeState(state.activeHandle, action.setDragging);\r\n    if (state.activeHandle > -1 && tr.docChanged) {\r\n      let handle = tr.mapping.map(state.activeHandle, -1);\r\n      if (!pointsAtCell(tr.doc.resolve(handle))) {\r\n        handle = -1;\r\n      }\r\n      return new _ResizeState(handle, state.dragging);\r\n    }\r\n    return state;\r\n  }\r\n};\r\nfunction handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {\r\n  const pluginState = columnResizingPluginKey.getState(view.state);\r\n  if (!pluginState)\r\n    return;\r\n  if (!pluginState.dragging) {\r\n    const target = domCellAround(event.target);\r\n    let cell = -1;\r\n    if (target) {\r\n      const { left, right } = target.getBoundingClientRect();\r\n      if (event.clientX - left <= handleWidth)\r\n        cell = edgeCell(view, event, \"left\", handleWidth);\r\n      else if (right - event.clientX <= handleWidth)\r\n        cell = edgeCell(view, event, \"right\", handleWidth);\r\n    }\r\n    if (cell != pluginState.activeHandle) {\r\n      if (!lastColumnResizable && cell !== -1) {\r\n        const $cell = view.state.doc.resolve(cell);\r\n        const table = $cell.node(-1);\r\n        const map = TableMap.get(table);\r\n        const tableStart = $cell.start(-1);\r\n        const col = map.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;\r\n        if (col == map.width - 1) {\r\n          return;\r\n        }\r\n      }\r\n      updateHandle(view, cell);\r\n    }\r\n  }\r\n}\r\nfunction handleMouseLeave(view) {\r\n  const pluginState = columnResizingPluginKey.getState(view.state);\r\n  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging)\r\n    updateHandle(view, -1);\r\n}\r\nfunction handleMouseDown2(view, event, cellMinWidth) {\r\n  var _a;\r\n  const win = (_a = view.dom.ownerDocument.defaultView) != null ? _a : window;\r\n  const pluginState = columnResizingPluginKey.getState(view.state);\r\n  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging)\r\n    return false;\r\n  const cell = view.state.doc.nodeAt(pluginState.activeHandle);\r\n  const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\r\n  view.dispatch(\r\n    view.state.tr.setMeta(columnResizingPluginKey, {\r\n      setDragging: { startX: event.clientX, startWidth: width }\r\n    })\r\n  );\r\n  function finish(event2) {\r\n    win.removeEventListener(\"mouseup\", finish);\r\n    win.removeEventListener(\"mousemove\", move);\r\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\r\n    if (pluginState2 == null ? void 0 : pluginState2.dragging) {\r\n      updateColumnWidth(\r\n        view,\r\n        pluginState2.activeHandle,\r\n        draggedWidth(pluginState2.dragging, event2, cellMinWidth)\r\n      );\r\n      view.dispatch(\r\n        view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null })\r\n      );\r\n    }\r\n  }\r\n  function move(event2) {\r\n    if (!event2.which)\r\n      return finish(event2);\r\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\r\n    if (!pluginState2)\r\n      return;\r\n    if (pluginState2.dragging) {\r\n      const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);\r\n      displayColumnWidth(view, pluginState2.activeHandle, dragged, cellMinWidth);\r\n    }\r\n  }\r\n  win.addEventListener(\"mouseup\", finish);\r\n  win.addEventListener(\"mousemove\", move);\r\n  event.preventDefault();\r\n  return true;\r\n}\r\nfunction currentColWidth(view, cellPos, { colspan, colwidth }) {\r\n  const width = colwidth && colwidth[colwidth.length - 1];\r\n  if (width)\r\n    return width;\r\n  const dom = view.domAtPos(cellPos);\r\n  const node = dom.node.childNodes[dom.offset];\r\n  let domWidth = node.offsetWidth, parts = colspan;\r\n  if (colwidth) {\r\n    for (let i = 0; i < colspan; i++)\r\n      if (colwidth[i]) {\r\n        domWidth -= colwidth[i];\r\n        parts--;\r\n      }\r\n  }\r\n  return domWidth / parts;\r\n}\r\nfunction domCellAround(target) {\r\n  while (target && target.nodeName != \"TD\" && target.nodeName != \"TH\")\r\n    target = target.classList && target.classList.contains(\"ProseMirror\") ? null : target.parentNode;\r\n  return target;\r\n}\r\nfunction edgeCell(view, event, side, handleWidth) {\r\n  const offset = side == \"right\" ? -handleWidth : handleWidth;\r\n  const found = view.posAtCoords({\r\n    left: event.clientX + offset,\r\n    top: event.clientY\r\n  });\r\n  if (!found)\r\n    return -1;\r\n  const { pos } = found;\r\n  const $cell = cellAround(view.state.doc.resolve(pos));\r\n  if (!$cell)\r\n    return -1;\r\n  if (side == \"right\")\r\n    return $cell.pos;\r\n  const map = TableMap.get($cell.node(-1)), start = $cell.start(-1);\r\n  const index = map.map.indexOf($cell.pos - start);\r\n  return index % map.width == 0 ? -1 : start + map.map[index - 1];\r\n}\r\nfunction draggedWidth(dragging, event, cellMinWidth) {\r\n  const offset = event.clientX - dragging.startX;\r\n  return Math.max(cellMinWidth, dragging.startWidth + offset);\r\n}\r\nfunction updateHandle(view, value) {\r\n  view.dispatch(\r\n    view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value })\r\n  );\r\n}\r\nfunction updateColumnWidth(view, cell, width) {\r\n  const $cell = view.state.doc.resolve(cell);\r\n  const table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);\r\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\r\n  const tr = view.state.tr;\r\n  for (let row = 0; row < map.height; row++) {\r\n    const mapIndex = row * map.width + col;\r\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width])\r\n      continue;\r\n    const pos = map.map[mapIndex];\r\n    const attrs = table.nodeAt(pos).attrs;\r\n    const index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\r\n    if (attrs.colwidth && attrs.colwidth[index] == width)\r\n      continue;\r\n    const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);\r\n    colwidth[index] = width;\r\n    tr.setNodeMarkup(start + pos, null, { ...attrs, colwidth });\r\n  }\r\n  if (tr.docChanged)\r\n    view.dispatch(tr);\r\n}\r\nfunction displayColumnWidth(view, cell, width, cellMinWidth) {\r\n  const $cell = view.state.doc.resolve(cell);\r\n  const table = $cell.node(-1), start = $cell.start(-1);\r\n  const col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\r\n  let dom = view.domAtPos($cell.start(-1)).node;\r\n  while (dom && dom.nodeName != \"TABLE\") {\r\n    dom = dom.parentNode;\r\n  }\r\n  if (!dom)\r\n    return;\r\n  updateColumnsOnResize(\r\n    table,\r\n    dom.firstChild,\r\n    dom,\r\n    cellMinWidth,\r\n    col,\r\n    width\r\n  );\r\n}\r\nfunction zeroes(n) {\r\n  return Array(n).fill(0);\r\n}\r\nfunction handleDecorations(state, cell) {\r\n  const decorations = [];\r\n  const $cell = state.doc.resolve(cell);\r\n  const table = $cell.node(-1);\r\n  if (!table) {\r\n    return DecorationSet2.empty;\r\n  }\r\n  const map = TableMap.get(table);\r\n  const start = $cell.start(-1);\r\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\r\n  for (let row = 0; row < map.height; row++) {\r\n    const index = col + row * map.width;\r\n    if ((col == map.width - 1 || map.map[index] != map.map[index + 1]) && (row == 0 || map.map[index] != map.map[index - map.width])) {\r\n      const cellPos = map.map[index];\r\n      const pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;\r\n      const dom = document.createElement(\"div\");\r\n      dom.className = \"column-resize-handle\";\r\n      decorations.push(Decoration2.widget(pos, dom));\r\n    }\r\n  }\r\n  return DecorationSet2.create(state.doc, decorations);\r\n}\r\n\r\n// src/index.ts\r\nfunction tableEditing({\r\n  allowTableNodeSelection = false\r\n} = {}) {\r\n  return new Plugin2({\r\n    key: tableEditingKey,\r\n    // This piece of state is used to remember when a mouse-drag\r\n    // cell-selection is happening, so that it can continue even as\r\n    // transactions (which might move its anchor cell) come in.\r\n    state: {\r\n      init() {\r\n        return null;\r\n      },\r\n      apply(tr, cur) {\r\n        const set = tr.getMeta(tableEditingKey);\r\n        if (set != null)\r\n          return set == -1 ? null : set;\r\n        if (cur == null || !tr.docChanged)\r\n          return cur;\r\n        const { deleted, pos } = tr.mapping.mapResult(cur);\r\n        return deleted ? null : pos;\r\n      }\r\n    },\r\n    props: {\r\n      decorations: drawCellSelection,\r\n      handleDOMEvents: {\r\n        mousedown: handleMouseDown\r\n      },\r\n      createSelectionBetween(view) {\r\n        return tableEditingKey.getState(view.state) != null ? view.state.selection : null;\r\n      },\r\n      handleTripleClick,\r\n      handleKeyDown,\r\n      handlePaste\r\n    },\r\n    appendTransaction(_, oldState, state) {\r\n      return normalizeSelection(\r\n        state,\r\n        fixTables(state, oldState),\r\n        allowTableNodeSelection\r\n      );\r\n    }\r\n  });\r\n}\r\nexport {\r\n  CellBookmark,\r\n  CellSelection,\r\n  ResizeState,\r\n  TableMap,\r\n  TableView,\r\n  clipCells as __clipCells,\r\n  insertCells as __insertCells,\r\n  pastedCells as __pastedCells,\r\n  addColSpan,\r\n  addColumn,\r\n  addColumnAfter,\r\n  addColumnBefore,\r\n  addRow,\r\n  addRowAfter,\r\n  addRowBefore,\r\n  cellAround,\r\n  cellNear,\r\n  colCount,\r\n  columnIsHeader,\r\n  columnResizing,\r\n  columnResizingPluginKey,\r\n  deleteCellSelection,\r\n  deleteColumn,\r\n  deleteRow,\r\n  deleteTable,\r\n  findCell,\r\n  fixTables,\r\n  fixTablesKey,\r\n  goToNextCell,\r\n  handlePaste,\r\n  inSameTable,\r\n  isInTable,\r\n  mergeCells,\r\n  moveCellForward,\r\n  nextCell,\r\n  pointsAtCell,\r\n  removeColSpan,\r\n  removeColumn,\r\n  removeRow,\r\n  rowIsHeader,\r\n  selectedRect,\r\n  selectionCell,\r\n  setCellAttr,\r\n  splitCell,\r\n  splitCellWithType,\r\n  tableEditing,\r\n  tableEditingKey,\r\n  tableNodeTypes,\r\n  tableNodes,\r\n  toggleHeader,\r\n  toggleHeaderCell,\r\n  toggleHeaderColumn,\r\n  toggleHeaderRow,\r\n  updateColumnsOnResize\r\n};\r\n", "// src/index.ts\r\nimport {\r\n  Plugin,\r\n  PluginKey\r\n} from \"prosemirror-state\";\r\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\r\n\r\n// src/browser.ts\r\nvar nav = typeof navigator != \"undefined\" ? navigator : null;\r\nvar agent = nav && nav.userAgent || \"\";\r\nvar ie_edge = /Edge\\/(\\d+)/.exec(agent);\r\nvar ie_upto10 = /MSIE \\d/.exec(agent);\r\nvar ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(agent);\r\nvar ie = !!(ie_upto10 || ie_11up || ie_edge);\r\nvar safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);\r\n\r\n// src/index.ts\r\nvar key = new PluginKey(\"safari-ime-span\");\r\nvar isComposing = false;\r\nvar spec = {\r\n  key,\r\n  props: {\r\n    decorations: createDecorations,\r\n    handleDOMEvents: {\r\n      compositionstart: () => {\r\n        isComposing = true;\r\n      },\r\n      compositionend: () => {\r\n        isComposing = false;\r\n      }\r\n    }\r\n  }\r\n};\r\nfunction createDecorations(state) {\r\n  const { $from, $to, to } = state.selection;\r\n  if (isComposing && $from.sameParent($to)) {\r\n    const deco = Decoration.widget(to, createSpan, {\r\n      ignoreSelection: true,\r\n      key: \"safari-ime-span\"\r\n    });\r\n    return DecorationSet.create(state.doc, [deco]);\r\n  }\r\n}\r\nfunction createSpan(view) {\r\n  const span = view.dom.ownerDocument.createElement(\"span\");\r\n  span.className = \"ProseMirror-safari-ime-span\";\r\n  return span;\r\n}\r\nvar imeSpan = new Plugin(safari ? spec : { key });\r\nexport {\r\n  imeSpan\r\n};\r\n", "/**\r\n * Count how often a character (or substring) is used in a string.\r\n *\r\n * @param {string} value\r\n *   Value to search in.\r\n * @param {string} character\r\n *   Character (or substring) to look for.\r\n * @return {number}\r\n *   Number of times `character` occurred in `value`.\r\n */\r\nexport function ccount(value, character) {\r\n  const source = String(value)\r\n\r\n  if (typeof character !== 'string') {\r\n    throw new TypeError('Expected character')\r\n  }\r\n\r\n  let count = 0\r\n  let index = source.indexOf(character)\r\n\r\n  while (index !== -1) {\r\n    count++\r\n    index = source.indexOf(character, index + character.length)\r\n  }\r\n\r\n  return count\r\n}\r\n", "/**\r\n * @typedef {import('mdast').Nodes} Nodes\r\n * @typedef {import('mdast').Parents} Parents\r\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\r\n * @typedef {import('mdast').Root} Root\r\n * @typedef {import('mdast').Text} Text\r\n * @typedef {import('unist-util-visit-parents').Test} Test\r\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\r\n */\r\n\r\n/**\r\n * @typedef RegExpMatchObject\r\n *   Info on the match.\r\n * @property {number} index\r\n *   The index of the search at which the result was found.\r\n * @property {string} input\r\n *   A copy of the search string in the text node.\r\n * @property {[...Array<Parents>, Text]} stack\r\n *   All ancestors of the text node, where the last node is the text itself.\r\n *\r\n * @typedef {RegExp | string} Find\r\n *   Pattern to find.\r\n *\r\n *   Strings are escaped and then turned into global expressions.\r\n *\r\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\r\n *   Several find and replaces, in array form.\r\n *\r\n * @typedef {[Find, Replace?]} FindAndReplaceTuple\r\n *   Find and replace in tuple form.\r\n *\r\n * @typedef {ReplaceFunction | string | null | undefined} Replace\r\n *   Thing to replace with.\r\n *\r\n * @callback ReplaceFunction\r\n *   Callback called when a search matches.\r\n * @param {...any} parameters\r\n *   The parameters are the result of corresponding search expression:\r\n *\r\n *   * `value` (`string`) — whole match\r\n *   * `...capture` (`Array<string>`) — matches from regex capture groups\r\n *   * `match` (`RegExpMatchObject`) — info on the match\r\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | null | undefined}\r\n *   Thing to replace with.\r\n *\r\n *   * when `null`, `undefined`, `''`, remove the match\r\n *   * …or when `false`, do not replace at all\r\n *   * …or when `string`, replace with a text node of that value\r\n *   * …or when `Node` or `Array<Node>`, replace with those nodes\r\n *\r\n * @typedef {[RegExp, ReplaceFunction]} Pair\r\n *   Normalized find and replace.\r\n *\r\n * @typedef {Array<Pair>} Pairs\r\n *   All find and replaced.\r\n *\r\n * @typedef Options\r\n *   Configuration.\r\n * @property {Test | null | undefined} [ignore]\r\n *   Test for which nodes to ignore (optional).\r\n */\r\n\r\nimport escape from 'escape-string-regexp'\r\nimport {visitParents} from 'unist-util-visit-parents'\r\nimport {convert} from 'unist-util-is'\r\n\r\n/**\r\n * Find patterns in a tree and replace them.\r\n *\r\n * The algorithm searches the tree in *preorder* for complete values in `Text`\r\n * nodes.\r\n * Partial matches are not supported.\r\n *\r\n * @param {Nodes} tree\r\n *   Tree to change.\r\n * @param {FindAndReplaceList | FindAndReplaceTuple} list\r\n *   Patterns to find.\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration (when `find` is not `Find`).\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nexport function findAndReplace(tree, list, options) {\r\n  const settings = options || {}\r\n  const ignored = convert(settings.ignore || [])\r\n  const pairs = toPairs(list)\r\n  let pairIndex = -1\r\n\r\n  while (++pairIndex < pairs.length) {\r\n    visitParents(tree, 'text', visitor)\r\n  }\r\n\r\n  /** @type {import('unist-util-visit-parents').BuildVisitor<Root, 'text'>} */\r\n  function visitor(node, parents) {\r\n    let index = -1\r\n    /** @type {Parents | undefined} */\r\n    let grandparent\r\n\r\n    while (++index < parents.length) {\r\n      const parent = parents[index]\r\n      /** @type {Array<Nodes> | undefined} */\r\n      const siblings = grandparent ? grandparent.children : undefined\r\n\r\n      if (\r\n        ignored(\r\n          parent,\r\n          siblings ? siblings.indexOf(parent) : undefined,\r\n          grandparent\r\n        )\r\n      ) {\r\n        return\r\n      }\r\n\r\n      grandparent = parent\r\n    }\r\n\r\n    if (grandparent) {\r\n      return handler(node, parents)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle a text node which is not in an ignored parent.\r\n   *\r\n   * @param {Text} node\r\n   *   Text node.\r\n   * @param {Array<Parents>} parents\r\n   *   Parents.\r\n   * @returns {VisitorResult}\r\n   *   Result.\r\n   */\r\n  function handler(node, parents) {\r\n    const parent = parents[parents.length - 1]\r\n    const find = pairs[pairIndex][0]\r\n    const replace = pairs[pairIndex][1]\r\n    let start = 0\r\n    /** @type {Array<Nodes>} */\r\n    const siblings = parent.children\r\n    const index = siblings.indexOf(node)\r\n    let change = false\r\n    /** @type {Array<PhrasingContent>} */\r\n    let nodes = []\r\n\r\n    find.lastIndex = 0\r\n\r\n    let match = find.exec(node.value)\r\n\r\n    while (match) {\r\n      const position = match.index\r\n      /** @type {RegExpMatchObject} */\r\n      const matchObject = {\r\n        index: match.index,\r\n        input: match.input,\r\n        stack: [...parents, node]\r\n      }\r\n      let value = replace(...match, matchObject)\r\n\r\n      if (typeof value === 'string') {\r\n        value = value.length > 0 ? {type: 'text', value} : undefined\r\n      }\r\n\r\n      // It wasn’t a match after all.\r\n      if (value === false) {\r\n        // False acts as if there was no match.\r\n        // So we need to reset `lastIndex`, which currently being at the end of\r\n        // the current match, to the beginning.\r\n        find.lastIndex = position + 1\r\n      } else {\r\n        if (start !== position) {\r\n          nodes.push({\r\n            type: 'text',\r\n            value: node.value.slice(start, position)\r\n          })\r\n        }\r\n\r\n        if (Array.isArray(value)) {\r\n          nodes.push(...value)\r\n        } else if (value) {\r\n          nodes.push(value)\r\n        }\r\n\r\n        start = position + match[0].length\r\n        change = true\r\n      }\r\n\r\n      if (!find.global) {\r\n        break\r\n      }\r\n\r\n      match = find.exec(node.value)\r\n    }\r\n\r\n    if (change) {\r\n      if (start < node.value.length) {\r\n        nodes.push({type: 'text', value: node.value.slice(start)})\r\n      }\r\n\r\n      parent.children.splice(index, 1, ...nodes)\r\n    } else {\r\n      nodes = [node]\r\n    }\r\n\r\n    return index + nodes.length\r\n  }\r\n}\r\n\r\n/**\r\n * Turn a tuple or a list of tuples into pairs.\r\n *\r\n * @param {FindAndReplaceList | FindAndReplaceTuple} tupleOrList\r\n *   Schema.\r\n * @returns {Pairs}\r\n *   Clean pairs.\r\n */\r\nfunction toPairs(tupleOrList) {\r\n  /** @type {Pairs} */\r\n  const result = []\r\n\r\n  if (!Array.isArray(tupleOrList)) {\r\n    throw new TypeError('Expected find and replace tuple or list of tuples')\r\n  }\r\n\r\n  /** @type {FindAndReplaceList} */\r\n  // @ts-expect-error: correct.\r\n  const list =\r\n    !tupleOrList[0] || Array.isArray(tupleOrList[0])\r\n      ? tupleOrList\r\n      : [tupleOrList]\r\n\r\n  let index = -1\r\n\r\n  while (++index < list.length) {\r\n    const tuple = list[index]\r\n    result.push([toExpression(tuple[0]), toFunction(tuple[1])])\r\n  }\r\n\r\n  return result\r\n}\r\n\r\n/**\r\n * Turn a find into an expression.\r\n *\r\n * @param {Find} find\r\n *   Find.\r\n * @returns {RegExp}\r\n *   Expression.\r\n */\r\nfunction toExpression(find) {\r\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\r\n}\r\n\r\n/**\r\n * Turn a replace into a function.\r\n *\r\n * @param {Replace} replace\r\n *   Replace.\r\n * @returns {ReplaceFunction}\r\n *   Function.\r\n */\r\nfunction toFunction(replace) {\r\n  return typeof replace === 'function'\r\n    ? replace\r\n    : function () {\r\n        return replace\r\n      }\r\n}\r\n", "/**\r\n * @import {RegExpMatchObject, ReplaceFunction} from 'mdast-util-find-and-replace'\r\n * @import {CompileContext, Extension as FromMarkdownExtension, Handle as FromMarkdownHandle, Transform as FromMarkdownTransform} from 'mdast-util-from-markdown'\r\n * @import {ConstructName, Options as ToMarkdownExtension} from 'mdast-util-to-markdown'\r\n * @import {Link, PhrasingContent} from 'mdast'\r\n */\r\n\r\nimport {ccount} from 'ccount'\r\nimport {ok as assert} from 'devlop'\r\nimport {unicodePunctuation, unicodeWhitespace} from 'micromark-util-character'\r\nimport {findAndReplace} from 'mdast-util-find-and-replace'\r\n\r\n/** @type {ConstructName} */\r\nconst inConstruct = 'phrasing'\r\n/** @type {Array<ConstructName>} */\r\nconst notInConstruct = ['autolink', 'link', 'image', 'label']\r\n\r\n/**\r\n * Create an extension for `mdast-util-from-markdown` to enable GFM autolink\r\n * literals in markdown.\r\n *\r\n * @returns {FromMarkdownExtension}\r\n *   Extension for `mdast-util-to-markdown` to enable GFM autolink literals.\r\n */\r\nexport function gfmAutolinkLiteralFromMarkdown() {\r\n  return {\r\n    transforms: [transformGfmAutolinkLiterals],\r\n    enter: {\r\n      literalAutolink: enterLiteralAutolink,\r\n      literalAutolinkEmail: enterLiteralAutolinkValue,\r\n      literalAutolinkHttp: enterLiteralAutolinkValue,\r\n      literalAutolinkWww: enterLiteralAutolinkValue\r\n    },\r\n    exit: {\r\n      literalAutolink: exitLiteralAutolink,\r\n      literalAutolinkEmail: exitLiteralAutolinkEmail,\r\n      literalAutolinkHttp: exitLiteralAutolinkHttp,\r\n      literalAutolinkWww: exitLiteralAutolinkWww\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Create an extension for `mdast-util-to-markdown` to enable GFM autolink\r\n * literals in markdown.\r\n *\r\n * @returns {ToMarkdownExtension}\r\n *   Extension for `mdast-util-to-markdown` to enable GFM autolink literals.\r\n */\r\nexport function gfmAutolinkLiteralToMarkdown() {\r\n  return {\r\n    unsafe: [\r\n      {\r\n        character: '@',\r\n        before: '[+\\\\-.\\\\w]',\r\n        after: '[\\\\-.\\\\w]',\r\n        inConstruct,\r\n        notInConstruct\r\n      },\r\n      {\r\n        character: '.',\r\n        before: '[Ww]',\r\n        after: '[\\\\-.\\\\w]',\r\n        inConstruct,\r\n        notInConstruct\r\n      },\r\n      {\r\n        character: ':',\r\n        before: '[ps]',\r\n        after: '\\\\/',\r\n        inConstruct,\r\n        notInConstruct\r\n      }\r\n    ]\r\n  }\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction enterLiteralAutolink(token) {\r\n  this.enter({type: 'link', title: null, url: '', children: []}, token)\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction enterLiteralAutolinkValue(token) {\r\n  this.config.enter.autolinkProtocol.call(this, token)\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction exitLiteralAutolinkHttp(token) {\r\n  this.config.exit.autolinkProtocol.call(this, token)\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction exitLiteralAutolinkWww(token) {\r\n  this.config.exit.data.call(this, token)\r\n  const node = this.stack[this.stack.length - 1]\r\n  assert(node.type === 'link')\r\n  node.url = 'http://' + this.sliceSerialize(token)\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction exitLiteralAutolinkEmail(token) {\r\n  this.config.exit.autolinkEmail.call(this, token)\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction exitLiteralAutolink(token) {\r\n  this.exit(token)\r\n}\r\n\r\n/** @type {FromMarkdownTransform} */\r\nfunction transformGfmAutolinkLiterals(tree) {\r\n  findAndReplace(\r\n    tree,\r\n    [\r\n      [/(https?:\\/\\/|www(?=\\.))([-.\\w]+)([^ \\t\\r\\n]*)/gi, findUrl],\r\n      [/(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)/gu, findEmail]\r\n    ],\r\n    {ignore: ['link', 'linkReference']}\r\n  )\r\n}\r\n\r\n/**\r\n * @type {ReplaceFunction}\r\n * @param {string} _\r\n * @param {string} protocol\r\n * @param {string} domain\r\n * @param {string} path\r\n * @param {RegExpMatchObject} match\r\n * @returns {Array<PhrasingContent> | Link | false}\r\n */\r\n// eslint-disable-next-line max-params\r\nfunction findUrl(_, protocol, domain, path, match) {\r\n  let prefix = ''\r\n\r\n  // Not an expected previous character.\r\n  if (!previous(match)) {\r\n    return false\r\n  }\r\n\r\n  // Treat `www` as part of the domain.\r\n  if (/^w/i.test(protocol)) {\r\n    domain = protocol + domain\r\n    protocol = ''\r\n    prefix = 'http://'\r\n  }\r\n\r\n  if (!isCorrectDomain(domain)) {\r\n    return false\r\n  }\r\n\r\n  const parts = splitUrl(domain + path)\r\n\r\n  if (!parts[0]) return false\r\n\r\n  /** @type {Link} */\r\n  const result = {\r\n    type: 'link',\r\n    title: null,\r\n    url: prefix + protocol + parts[0],\r\n    children: [{type: 'text', value: protocol + parts[0]}]\r\n  }\r\n\r\n  if (parts[1]) {\r\n    return [result, {type: 'text', value: parts[1]}]\r\n  }\r\n\r\n  return result\r\n}\r\n\r\n/**\r\n * @type {ReplaceFunction}\r\n * @param {string} _\r\n * @param {string} atext\r\n * @param {string} label\r\n * @param {RegExpMatchObject} match\r\n * @returns {Link | false}\r\n */\r\nfunction findEmail(_, atext, label, match) {\r\n  if (\r\n    // Not an expected previous character.\r\n    !previous(match, true) ||\r\n    // Label ends in not allowed character.\r\n    /[-\\d_]$/.test(label)\r\n  ) {\r\n    return false\r\n  }\r\n\r\n  return {\r\n    type: 'link',\r\n    title: null,\r\n    url: 'mailto:' + atext + '@' + label,\r\n    children: [{type: 'text', value: atext + '@' + label}]\r\n  }\r\n}\r\n\r\n/**\r\n * @param {string} domain\r\n * @returns {boolean}\r\n */\r\nfunction isCorrectDomain(domain) {\r\n  const parts = domain.split('.')\r\n\r\n  if (\r\n    parts.length < 2 ||\r\n    (parts[parts.length - 1] &&\r\n      (/_/.test(parts[parts.length - 1]) ||\r\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 1]))) ||\r\n    (parts[parts.length - 2] &&\r\n      (/_/.test(parts[parts.length - 2]) ||\r\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 2])))\r\n  ) {\r\n    return false\r\n  }\r\n\r\n  return true\r\n}\r\n\r\n/**\r\n * @param {string} url\r\n * @returns {[string, string | undefined]}\r\n */\r\nfunction splitUrl(url) {\r\n  const trailExec = /[!\"&'),.:;<>?\\]}]+$/.exec(url)\r\n\r\n  if (!trailExec) {\r\n    return [url, undefined]\r\n  }\r\n\r\n  url = url.slice(0, trailExec.index)\r\n\r\n  let trail = trailExec[0]\r\n  let closingParenIndex = trail.indexOf(')')\r\n  const openingParens = ccount(url, '(')\r\n  let closingParens = ccount(url, ')')\r\n\r\n  while (closingParenIndex !== -1 && openingParens > closingParens) {\r\n    url += trail.slice(0, closingParenIndex + 1)\r\n    trail = trail.slice(closingParenIndex + 1)\r\n    closingParenIndex = trail.indexOf(')')\r\n    closingParens++\r\n  }\r\n\r\n  return [url, trail]\r\n}\r\n\r\n/**\r\n * @param {RegExpMatchObject} match\r\n * @param {boolean | null | undefined} [email=false]\r\n * @returns {boolean}\r\n */\r\nfunction previous(match, email) {\r\n  const code = match.input.charCodeAt(match.index - 1)\r\n\r\n  return (\r\n    (match.index === 0 ||\r\n      unicodeWhitespace(code) ||\r\n      unicodePunctuation(code)) &&\r\n    // If it’s an email, the previous character should not be a slash.\r\n    (!email || code !== 47)\r\n  )\r\n}\r\n", "/**\r\n * @typedef {import('mdast').FootnoteDefinition} FootnoteDefinition\r\n * @typedef {import('mdast').FootnoteReference} FootnoteReference\r\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\r\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\r\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\r\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\r\n * @typedef {import('mdast-util-to-markdown').Map} Map\r\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\r\n */\r\n\r\nimport {ok as assert} from 'devlop'\r\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\r\n\r\nfootnoteReference.peek = footnoteReferencePeek\r\n\r\n/**\r\n * Create an extension for `mdast-util-from-markdown` to enable GFM footnotes\r\n * in markdown.\r\n *\r\n * @returns {FromMarkdownExtension}\r\n *   Extension for `mdast-util-from-markdown`.\r\n */\r\nexport function gfmFootnoteFromMarkdown() {\r\n  return {\r\n    enter: {\r\n      gfmFootnoteDefinition: enterFootnoteDefinition,\r\n      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,\r\n      gfmFootnoteCall: enterFootnoteCall,\r\n      gfmFootnoteCallString: enterFootnoteCallString\r\n    },\r\n    exit: {\r\n      gfmFootnoteDefinition: exitFootnoteDefinition,\r\n      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,\r\n      gfmFootnoteCall: exitFootnoteCall,\r\n      gfmFootnoteCallString: exitFootnoteCallString\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Create an extension for `mdast-util-to-markdown` to enable GFM footnotes\r\n * in markdown.\r\n *\r\n * @returns {ToMarkdownExtension}\r\n *   Extension for `mdast-util-to-markdown`.\r\n */\r\nexport function gfmFootnoteToMarkdown() {\r\n  return {\r\n    // This is on by default already.\r\n    unsafe: [{character: '[', inConstruct: ['phrasing', 'label', 'reference']}],\r\n    handlers: {footnoteDefinition, footnoteReference}\r\n  }\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction enterFootnoteDefinition(token) {\r\n  this.enter(\r\n    {type: 'footnoteDefinition', identifier: '', label: '', children: []},\r\n    token\r\n  )\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction enterFootnoteDefinitionLabelString() {\r\n  this.buffer()\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction exitFootnoteDefinitionLabelString(token) {\r\n  const label = this.resume()\r\n  const node = this.stack[this.stack.length - 1]\r\n  assert(node.type === 'footnoteDefinition')\r\n  node.label = label\r\n  node.identifier = normalizeIdentifier(\r\n    this.sliceSerialize(token)\r\n  ).toLowerCase()\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction exitFootnoteDefinition(token) {\r\n  this.exit(token)\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction enterFootnoteCall(token) {\r\n  this.enter({type: 'footnoteReference', identifier: '', label: ''}, token)\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction enterFootnoteCallString() {\r\n  this.buffer()\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction exitFootnoteCallString(token) {\r\n  const label = this.resume()\r\n  const node = this.stack[this.stack.length - 1]\r\n  assert(node.type === 'footnoteReference')\r\n  node.label = label\r\n  node.identifier = normalizeIdentifier(\r\n    this.sliceSerialize(token)\r\n  ).toLowerCase()\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction exitFootnoteCall(token) {\r\n  this.exit(token)\r\n}\r\n\r\n/**\r\n * @type {ToMarkdownHandle}\r\n * @param {FootnoteReference} node\r\n */\r\nfunction footnoteReference(node, _, state, info) {\r\n  const tracker = state.createTracker(info)\r\n  let value = tracker.move('[^')\r\n  const exit = state.enter('footnoteReference')\r\n  const subexit = state.enter('reference')\r\n  value += tracker.move(\r\n    state.safe(state.associationId(node), {\r\n      ...tracker.current(),\r\n      before: value,\r\n      after: ']'\r\n    })\r\n  )\r\n  subexit()\r\n  exit()\r\n  value += tracker.move(']')\r\n  return value\r\n}\r\n\r\n/** @type {ToMarkdownHandle} */\r\nfunction footnoteReferencePeek() {\r\n  return '['\r\n}\r\n\r\n/**\r\n * @type {ToMarkdownHandle}\r\n * @param {FootnoteDefinition} node\r\n */\r\nfunction footnoteDefinition(node, _, state, info) {\r\n  const tracker = state.createTracker(info)\r\n  let value = tracker.move('[^')\r\n  const exit = state.enter('footnoteDefinition')\r\n  const subexit = state.enter('label')\r\n  value += tracker.move(\r\n    state.safe(state.associationId(node), {\r\n      ...tracker.current(),\r\n      before: value,\r\n      after: ']'\r\n    })\r\n  )\r\n  subexit()\r\n  value += tracker.move(\r\n    ']:' + (node.children && node.children.length > 0 ? ' ' : '')\r\n  )\r\n  tracker.shift(4)\r\n  value += tracker.move(\r\n    state.indentLines(state.containerFlow(node, tracker.current()), map)\r\n  )\r\n  exit()\r\n\r\n  return value\r\n}\r\n\r\n/** @type {Map} */\r\nfunction map(line, index, blank) {\r\n  if (index === 0) {\r\n    return line\r\n  }\r\n\r\n  return (blank ? '' : '    ') + line\r\n}\r\n", "/**\r\n * @typedef {import('mdast').Delete} Delete\r\n *\r\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\r\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\r\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\r\n *\r\n * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName\r\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\r\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\r\n */\r\n\r\n/**\r\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\r\n * contain strikethrough.\r\n * So they sort of cancel each other out.\r\n * Note: could use a better name.\r\n *\r\n * Note: keep in sync with: <https://github.com/syntax-tree/mdast-util-to-markdown/blob/8ce8dbf/lib/unsafe.js#L14>\r\n *\r\n * @type {Array<ConstructName>}\r\n */\r\nconst constructsWithoutStrikethrough = [\r\n  'autolink',\r\n  'destinationLiteral',\r\n  'destinationRaw',\r\n  'reference',\r\n  'titleQuote',\r\n  'titleApostrophe'\r\n]\r\n\r\nhandleDelete.peek = peekDelete\r\n\r\n/**\r\n * Create an extension for `mdast-util-from-markdown` to enable GFM\r\n * strikethrough in markdown.\r\n *\r\n * @returns {FromMarkdownExtension}\r\n *   Extension for `mdast-util-from-markdown` to enable GFM strikethrough.\r\n */\r\nexport function gfmStrikethroughFromMarkdown() {\r\n  return {\r\n    canContainEols: ['delete'],\r\n    enter: {strikethrough: enterStrikethrough},\r\n    exit: {strikethrough: exitStrikethrough}\r\n  }\r\n}\r\n\r\n/**\r\n * Create an extension for `mdast-util-to-markdown` to enable GFM\r\n * strikethrough in markdown.\r\n *\r\n * @returns {ToMarkdownExtension}\r\n *   Extension for `mdast-util-to-markdown` to enable GFM strikethrough.\r\n */\r\nexport function gfmStrikethroughToMarkdown() {\r\n  return {\r\n    unsafe: [\r\n      {\r\n        character: '~',\r\n        inConstruct: 'phrasing',\r\n        notInConstruct: constructsWithoutStrikethrough\r\n      }\r\n    ],\r\n    handlers: {delete: handleDelete}\r\n  }\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction enterStrikethrough(token) {\r\n  this.enter({type: 'delete', children: []}, token)\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction exitStrikethrough(token) {\r\n  this.exit(token)\r\n}\r\n\r\n/**\r\n * @type {ToMarkdownHandle}\r\n * @param {Delete} node\r\n */\r\nfunction handleDelete(node, _, state, info) {\r\n  const tracker = state.createTracker(info)\r\n  const exit = state.enter('strikethrough')\r\n  let value = tracker.move('~~')\r\n  value += state.containerPhrasing(node, {\r\n    ...tracker.current(),\r\n    before: value,\r\n    after: '~'\r\n  })\r\n  value += tracker.move('~~')\r\n  exit()\r\n  return value\r\n}\r\n\r\n/** @type {ToMarkdownHandle} */\r\nfunction peekDelete() {\r\n  return '~'\r\n}\r\n", "/**\r\n * @typedef Options\r\n *   Configuration (optional).\r\n * @property {string|null|ReadonlyArray<string|null|undefined>} [align]\r\n *   One style for all columns, or styles for their respective columns.\r\n *   Each style is either `'l'` (left), `'r'` (right), or `'c'` (center).\r\n *   Other values are treated as `''`, which doesn’t place the colon in the\r\n *   alignment row but does align left.\r\n *   *Only the lowercased first character is used, so `Right` is fine.*\r\n * @property {boolean} [padding=true]\r\n *   Whether to add a space of padding between delimiters and cells.\r\n *\r\n *   When `true`, there is padding:\r\n *\r\n *   ```markdown\r\n *   | Alpha | B     |\r\n *   | ----- | ----- |\r\n *   | C     | Delta |\r\n *   ```\r\n *\r\n *   When `false`, there is no padding:\r\n *\r\n *   ```markdown\r\n *   |Alpha|B    |\r\n *   |-----|-----|\r\n *   |C    |Delta|\r\n *   ```\r\n * @property {boolean} [delimiterStart=true]\r\n *   Whether to begin each row with the delimiter.\r\n *\r\n *   > 👉 **Note**: please don’t use this: it could create fragile structures\r\n *   > that aren’t understandable to some markdown parsers.\r\n *\r\n *   When `true`, there are starting delimiters:\r\n *\r\n *   ```markdown\r\n *   | Alpha | B     |\r\n *   | ----- | ----- |\r\n *   | C     | Delta |\r\n *   ```\r\n *\r\n *   When `false`, there are no starting delimiters:\r\n *\r\n *   ```markdown\r\n *   Alpha | B     |\r\n *   ----- | ----- |\r\n *   C     | Delta |\r\n *   ```\r\n * @property {boolean} [delimiterEnd=true]\r\n *   Whether to end each row with the delimiter.\r\n *\r\n *   > 👉 **Note**: please don’t use this: it could create fragile structures\r\n *   > that aren’t understandable to some markdown parsers.\r\n *\r\n *   When `true`, there are ending delimiters:\r\n *\r\n *   ```markdown\r\n *   | Alpha | B     |\r\n *   | ----- | ----- |\r\n *   | C     | Delta |\r\n *   ```\r\n *\r\n *   When `false`, there are no ending delimiters:\r\n *\r\n *   ```markdown\r\n *   | Alpha | B\r\n *   | ----- | -----\r\n *   | C     | Delta\r\n *   ```\r\n * @property {boolean} [alignDelimiters=true]\r\n *   Whether to align the delimiters.\r\n *   By default, they are aligned:\r\n *\r\n *   ```markdown\r\n *   | Alpha | B     |\r\n *   | ----- | ----- |\r\n *   | C     | Delta |\r\n *   ```\r\n *\r\n *   Pass `false` to make them staggered:\r\n *\r\n *   ```markdown\r\n *   | Alpha | B |\r\n *   | - | - |\r\n *   | C | Delta |\r\n *   ```\r\n * @property {(value: string) => number} [stringLength]\r\n *   Function to detect the length of table cell content.\r\n *   This is used when aligning the delimiters (`|`) between table cells.\r\n *   Full-width characters and emoji mess up delimiter alignment when viewing\r\n *   the markdown source.\r\n *   To fix this, you can pass this function, which receives the cell content\r\n *   and returns its “visible” size.\r\n *   Note that what is and isn’t visible depends on where the text is displayed.\r\n *\r\n *   Without such a function, the following:\r\n *\r\n *   ```js\r\n *   markdownTable([\r\n *     ['Alpha', 'Bravo'],\r\n *     ['中文', 'Charlie'],\r\n *     ['👩‍❤️‍👩', 'Delta']\r\n *   ])\r\n *   ```\r\n *\r\n *   Yields:\r\n *\r\n *   ```markdown\r\n *   | Alpha | Bravo |\r\n *   | - | - |\r\n *   | 中文 | Charlie |\r\n *   | 👩‍❤️‍👩 | Delta |\r\n *   ```\r\n *\r\n *   With [`string-width`](https://github.com/sindresorhus/string-width):\r\n *\r\n *   ```js\r\n *   import stringWidth from 'string-width'\r\n *\r\n *   markdownTable(\r\n *     [\r\n *       ['Alpha', 'Bravo'],\r\n *       ['中文', 'Charlie'],\r\n *       ['👩‍❤️‍👩', 'Delta']\r\n *     ],\r\n *     {stringLength: stringWidth}\r\n *   )\r\n *   ```\r\n *\r\n *   Yields:\r\n *\r\n *   ```markdown\r\n *   | Alpha | Bravo   |\r\n *   | ----- | ------- |\r\n *   | 中文  | Charlie |\r\n *   | 👩‍❤️‍👩    | Delta   |\r\n *   ```\r\n */\r\n\r\n/**\r\n * @typedef {Options} MarkdownTableOptions\r\n * @todo\r\n *   Remove next major.\r\n */\r\n\r\n/**\r\n * Generate a markdown ([GFM](https://docs.github.com/en/github/writing-on-github/working-with-advanced-formatting/organizing-information-with-tables)) table..\r\n *\r\n * @param {ReadonlyArray<ReadonlyArray<string|null|undefined>>} table\r\n *   Table data (matrix of strings).\r\n * @param {Options} [options]\r\n *   Configuration (optional).\r\n * @returns {string}\r\n */\r\nexport function markdownTable(table, options = {}) {\r\n  const align = (options.align || []).concat()\r\n  const stringLength = options.stringLength || defaultStringLength\r\n  /** @type {Array<number>} Character codes as symbols for alignment per column. */\r\n  const alignments = []\r\n  /** @type {Array<Array<string>>} Cells per row. */\r\n  const cellMatrix = []\r\n  /** @type {Array<Array<number>>} Sizes of each cell per row. */\r\n  const sizeMatrix = []\r\n  /** @type {Array<number>} */\r\n  const longestCellByColumn = []\r\n  let mostCellsPerRow = 0\r\n  let rowIndex = -1\r\n\r\n  // This is a superfluous loop if we don’t align delimiters, but otherwise we’d\r\n  // do superfluous work when aligning, so optimize for aligning.\r\n  while (++rowIndex < table.length) {\r\n    /** @type {Array<string>} */\r\n    const row = []\r\n    /** @type {Array<number>} */\r\n    const sizes = []\r\n    let columnIndex = -1\r\n\r\n    if (table[rowIndex].length > mostCellsPerRow) {\r\n      mostCellsPerRow = table[rowIndex].length\r\n    }\r\n\r\n    while (++columnIndex < table[rowIndex].length) {\r\n      const cell = serialize(table[rowIndex][columnIndex])\r\n\r\n      if (options.alignDelimiters !== false) {\r\n        const size = stringLength(cell)\r\n        sizes[columnIndex] = size\r\n\r\n        if (\r\n          longestCellByColumn[columnIndex] === undefined ||\r\n          size > longestCellByColumn[columnIndex]\r\n        ) {\r\n          longestCellByColumn[columnIndex] = size\r\n        }\r\n      }\r\n\r\n      row.push(cell)\r\n    }\r\n\r\n    cellMatrix[rowIndex] = row\r\n    sizeMatrix[rowIndex] = sizes\r\n  }\r\n\r\n  // Figure out which alignments to use.\r\n  let columnIndex = -1\r\n\r\n  if (typeof align === 'object' && 'length' in align) {\r\n    while (++columnIndex < mostCellsPerRow) {\r\n      alignments[columnIndex] = toAlignment(align[columnIndex])\r\n    }\r\n  } else {\r\n    const code = toAlignment(align)\r\n\r\n    while (++columnIndex < mostCellsPerRow) {\r\n      alignments[columnIndex] = code\r\n    }\r\n  }\r\n\r\n  // Inject the alignment row.\r\n  columnIndex = -1\r\n  /** @type {Array<string>} */\r\n  const row = []\r\n  /** @type {Array<number>} */\r\n  const sizes = []\r\n\r\n  while (++columnIndex < mostCellsPerRow) {\r\n    const code = alignments[columnIndex]\r\n    let before = ''\r\n    let after = ''\r\n\r\n    if (code === 99 /* `c` */) {\r\n      before = ':'\r\n      after = ':'\r\n    } else if (code === 108 /* `l` */) {\r\n      before = ':'\r\n    } else if (code === 114 /* `r` */) {\r\n      after = ':'\r\n    }\r\n\r\n    // There *must* be at least one hyphen-minus in each alignment cell.\r\n    let size =\r\n      options.alignDelimiters === false\r\n        ? 1\r\n        : Math.max(\r\n            1,\r\n            longestCellByColumn[columnIndex] - before.length - after.length\r\n          )\r\n\r\n    const cell = before + '-'.repeat(size) + after\r\n\r\n    if (options.alignDelimiters !== false) {\r\n      size = before.length + size + after.length\r\n\r\n      if (size > longestCellByColumn[columnIndex]) {\r\n        longestCellByColumn[columnIndex] = size\r\n      }\r\n\r\n      sizes[columnIndex] = size\r\n    }\r\n\r\n    row[columnIndex] = cell\r\n  }\r\n\r\n  // Inject the alignment row.\r\n  cellMatrix.splice(1, 0, row)\r\n  sizeMatrix.splice(1, 0, sizes)\r\n\r\n  rowIndex = -1\r\n  /** @type {Array<string>} */\r\n  const lines = []\r\n\r\n  while (++rowIndex < cellMatrix.length) {\r\n    const row = cellMatrix[rowIndex]\r\n    const sizes = sizeMatrix[rowIndex]\r\n    columnIndex = -1\r\n    /** @type {Array<string>} */\r\n    const line = []\r\n\r\n    while (++columnIndex < mostCellsPerRow) {\r\n      const cell = row[columnIndex] || ''\r\n      let before = ''\r\n      let after = ''\r\n\r\n      if (options.alignDelimiters !== false) {\r\n        const size =\r\n          longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0)\r\n        const code = alignments[columnIndex]\r\n\r\n        if (code === 114 /* `r` */) {\r\n          before = ' '.repeat(size)\r\n        } else if (code === 99 /* `c` */) {\r\n          if (size % 2) {\r\n            before = ' '.repeat(size / 2 + 0.5)\r\n            after = ' '.repeat(size / 2 - 0.5)\r\n          } else {\r\n            before = ' '.repeat(size / 2)\r\n            after = before\r\n          }\r\n        } else {\r\n          after = ' '.repeat(size)\r\n        }\r\n      }\r\n\r\n      if (options.delimiterStart !== false && !columnIndex) {\r\n        line.push('|')\r\n      }\r\n\r\n      if (\r\n        options.padding !== false &&\r\n        // Don’t add the opening space if we’re not aligning and the cell is\r\n        // empty: there will be a closing space.\r\n        !(options.alignDelimiters === false && cell === '') &&\r\n        (options.delimiterStart !== false || columnIndex)\r\n      ) {\r\n        line.push(' ')\r\n      }\r\n\r\n      if (options.alignDelimiters !== false) {\r\n        line.push(before)\r\n      }\r\n\r\n      line.push(cell)\r\n\r\n      if (options.alignDelimiters !== false) {\r\n        line.push(after)\r\n      }\r\n\r\n      if (options.padding !== false) {\r\n        line.push(' ')\r\n      }\r\n\r\n      if (\r\n        options.delimiterEnd !== false ||\r\n        columnIndex !== mostCellsPerRow - 1\r\n      ) {\r\n        line.push('|')\r\n      }\r\n    }\r\n\r\n    lines.push(\r\n      options.delimiterEnd === false\r\n        ? line.join('').replace(/ +$/, '')\r\n        : line.join('')\r\n    )\r\n  }\r\n\r\n  return lines.join('\\n')\r\n}\r\n\r\n/**\r\n * @param {string|null|undefined} [value]\r\n * @returns {string}\r\n */\r\nfunction serialize(value) {\r\n  return value === null || value === undefined ? '' : String(value)\r\n}\r\n\r\n/**\r\n * @param {string} value\r\n * @returns {number}\r\n */\r\nfunction defaultStringLength(value) {\r\n  return value.length\r\n}\r\n\r\n/**\r\n * @param {string|null|undefined} value\r\n * @returns {number}\r\n */\r\nfunction toAlignment(value) {\r\n  const code = typeof value === 'string' ? value.codePointAt(0) : 0\r\n\r\n  return code === 67 /* `C` */ || code === 99 /* `c` */\r\n    ? 99 /* `c` */\r\n    : code === 76 /* `L` */ || code === 108 /* `l` */\r\n    ? 108 /* `l` */\r\n    : code === 82 /* `R` */ || code === 114 /* `r` */\r\n    ? 114 /* `r` */\r\n    : 0\r\n}\r\n", "/**\r\n * @typedef {import('mdast').InlineCode} InlineCode\r\n * @typedef {import('mdast').Table} Table\r\n * @typedef {import('mdast').TableCell} TableCell\r\n * @typedef {import('mdast').TableRow} TableRow\r\n *\r\n * @typedef {import('markdown-table').Options} MarkdownTableOptions\r\n *\r\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\r\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\r\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\r\n *\r\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\r\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\r\n * @typedef {import('mdast-util-to-markdown').State} State\r\n * @typedef {import('mdast-util-to-markdown').Info} Info\r\n */\r\n\r\n/**\r\n * @typedef Options\r\n *   Configuration.\r\n * @property {boolean | null | undefined} [tableCellPadding=true]\r\n *   Whether to add a space of padding between delimiters and cells (default:\r\n *   `true`).\r\n * @property {boolean | null | undefined} [tablePipeAlign=true]\r\n *   Whether to align the delimiters (default: `true`).\r\n * @property {MarkdownTableOptions['stringLength'] | null | undefined} [stringLength]\r\n *   Function to detect the length of table cell content, used when aligning\r\n *   the delimiters between cells (optional).\r\n */\r\n\r\nimport {ok as assert} from 'devlop'\r\nimport {markdownTable} from 'markdown-table'\r\nimport {defaultHandlers} from 'mdast-util-to-markdown'\r\n\r\n/**\r\n * Create an extension for `mdast-util-from-markdown` to enable GFM tables in\r\n * markdown.\r\n *\r\n * @returns {FromMarkdownExtension}\r\n *   Extension for `mdast-util-from-markdown` to enable GFM tables.\r\n */\r\nexport function gfmTableFromMarkdown() {\r\n  return {\r\n    enter: {\r\n      table: enterTable,\r\n      tableData: enterCell,\r\n      tableHeader: enterCell,\r\n      tableRow: enterRow\r\n    },\r\n    exit: {\r\n      codeText: exitCodeText,\r\n      table: exitTable,\r\n      tableData: exit,\r\n      tableHeader: exit,\r\n      tableRow: exit\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction enterTable(token) {\r\n  const align = token._align\r\n  assert(align, 'expected `_align` on table')\r\n  this.enter(\r\n    {\r\n      type: 'table',\r\n      align: align.map(function (d) {\r\n        return d === 'none' ? null : d\r\n      }),\r\n      children: []\r\n    },\r\n    token\r\n  )\r\n  this.data.inTable = true\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction exitTable(token) {\r\n  this.exit(token)\r\n  this.data.inTable = undefined\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction enterRow(token) {\r\n  this.enter({type: 'tableRow', children: []}, token)\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction exit(token) {\r\n  this.exit(token)\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction enterCell(token) {\r\n  this.enter({type: 'tableCell', children: []}, token)\r\n}\r\n\r\n// Overwrite the default code text data handler to unescape escaped pipes when\r\n// they are in tables.\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction exitCodeText(token) {\r\n  let value = this.resume()\r\n\r\n  if (this.data.inTable) {\r\n    value = value.replace(/\\\\([\\\\|])/g, replace)\r\n  }\r\n\r\n  const node = this.stack[this.stack.length - 1]\r\n  assert(node.type === 'inlineCode')\r\n  node.value = value\r\n  this.exit(token)\r\n}\r\n\r\n/**\r\n * @param {string} $0\r\n * @param {string} $1\r\n * @returns {string}\r\n */\r\nfunction replace($0, $1) {\r\n  // Pipes work, backslashes don’t (but can’t escape pipes).\r\n  return $1 === '|' ? $1 : $0\r\n}\r\n\r\n/**\r\n * Create an extension for `mdast-util-to-markdown` to enable GFM tables in\r\n * markdown.\r\n *\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration.\r\n * @returns {ToMarkdownExtension}\r\n *   Extension for `mdast-util-to-markdown` to enable GFM tables.\r\n */\r\nexport function gfmTableToMarkdown(options) {\r\n  const settings = options || {}\r\n  const padding = settings.tableCellPadding\r\n  const alignDelimiters = settings.tablePipeAlign\r\n  const stringLength = settings.stringLength\r\n  const around = padding ? ' ' : '|'\r\n\r\n  return {\r\n    unsafe: [\r\n      {character: '\\r', inConstruct: 'tableCell'},\r\n      {character: '\\n', inConstruct: 'tableCell'},\r\n      // A pipe, when followed by a tab or space (padding), or a dash or colon\r\n      // (unpadded delimiter row), could result in a table.\r\n      {atBreak: true, character: '|', after: '[\\t :-]'},\r\n      // A pipe in a cell must be encoded.\r\n      {character: '|', inConstruct: 'tableCell'},\r\n      // A colon must be followed by a dash, in which case it could start a\r\n      // delimiter row.\r\n      {atBreak: true, character: ':', after: '-'},\r\n      // A delimiter row can also start with a dash, when followed by more\r\n      // dashes, a colon, or a pipe.\r\n      // This is a stricter version than the built in check for lists, thematic\r\n      // breaks, and setex heading underlines though:\r\n      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>\r\n      {atBreak: true, character: '-', after: '[:|-]'}\r\n    ],\r\n    handlers: {\r\n      inlineCode: inlineCodeWithTable,\r\n      table: handleTable,\r\n      tableCell: handleTableCell,\r\n      tableRow: handleTableRow\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @type {ToMarkdownHandle}\r\n   * @param {Table} node\r\n   */\r\n  function handleTable(node, _, state, info) {\r\n    return serializeData(handleTableAsData(node, state, info), node.align)\r\n  }\r\n\r\n  /**\r\n   * This function isn’t really used normally, because we handle rows at the\r\n   * table level.\r\n   * But, if someone passes in a table row, this ensures we make somewhat sense.\r\n   *\r\n   * @type {ToMarkdownHandle}\r\n   * @param {TableRow} node\r\n   */\r\n  function handleTableRow(node, _, state, info) {\r\n    const row = handleTableRowAsData(node, state, info)\r\n    const value = serializeData([row])\r\n    // `markdown-table` will always add an align row\r\n    return value.slice(0, value.indexOf('\\n'))\r\n  }\r\n\r\n  /**\r\n   * @type {ToMarkdownHandle}\r\n   * @param {TableCell} node\r\n   */\r\n  function handleTableCell(node, _, state, info) {\r\n    const exit = state.enter('tableCell')\r\n    const subexit = state.enter('phrasing')\r\n    const value = state.containerPhrasing(node, {\r\n      ...info,\r\n      before: around,\r\n      after: around\r\n    })\r\n    subexit()\r\n    exit()\r\n    return value\r\n  }\r\n\r\n  /**\r\n   * @param {Array<Array<string>>} matrix\r\n   * @param {Array<string | null | undefined> | null | undefined} [align]\r\n   */\r\n  function serializeData(matrix, align) {\r\n    return markdownTable(matrix, {\r\n      align,\r\n      // @ts-expect-error: `markdown-table` types should support `null`.\r\n      alignDelimiters,\r\n      // @ts-expect-error: `markdown-table` types should support `null`.\r\n      padding,\r\n      // @ts-expect-error: `markdown-table` types should support `null`.\r\n      stringLength\r\n    })\r\n  }\r\n\r\n  /**\r\n   * @param {Table} node\r\n   * @param {State} state\r\n   * @param {Info} info\r\n   */\r\n  function handleTableAsData(node, state, info) {\r\n    const children = node.children\r\n    let index = -1\r\n    /** @type {Array<Array<string>>} */\r\n    const result = []\r\n    const subexit = state.enter('table')\r\n\r\n    while (++index < children.length) {\r\n      result[index] = handleTableRowAsData(children[index], state, info)\r\n    }\r\n\r\n    subexit()\r\n\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * @param {TableRow} node\r\n   * @param {State} state\r\n   * @param {Info} info\r\n   */\r\n  function handleTableRowAsData(node, state, info) {\r\n    const children = node.children\r\n    let index = -1\r\n    /** @type {Array<string>} */\r\n    const result = []\r\n    const subexit = state.enter('tableRow')\r\n\r\n    while (++index < children.length) {\r\n      // Note: the positional info as used here is incorrect.\r\n      // Making it correct would be impossible due to aligning cells?\r\n      // And it would need copy/pasting `markdown-table` into this project.\r\n      result[index] = handleTableCell(children[index], node, state, info)\r\n    }\r\n\r\n    subexit()\r\n\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * @type {ToMarkdownHandle}\r\n   * @param {InlineCode} node\r\n   */\r\n  function inlineCodeWithTable(node, parent, state) {\r\n    let value = defaultHandlers.inlineCode(node, parent, state)\r\n\r\n    if (state.stack.includes('tableCell')) {\r\n      value = value.replace(/\\|/g, '\\\\$&')\r\n    }\r\n\r\n    return value\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('mdast').ListItem} ListItem\r\n * @typedef {import('mdast').Paragraph} Paragraph\r\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\r\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\r\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\r\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\r\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\r\n */\r\n\r\nimport {ok as assert} from 'devlop'\r\nimport {defaultHandlers} from 'mdast-util-to-markdown'\r\n\r\n/**\r\n * Create an extension for `mdast-util-from-markdown` to enable GFM task\r\n * list items in markdown.\r\n *\r\n * @returns {FromMarkdownExtension}\r\n *   Extension for `mdast-util-from-markdown` to enable GFM task list items.\r\n */\r\nexport function gfmTaskListItemFromMarkdown() {\r\n  return {\r\n    exit: {\r\n      taskListCheckValueChecked: exitCheck,\r\n      taskListCheckValueUnchecked: exitCheck,\r\n      paragraph: exitParagraphWithTaskListItem\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Create an extension for `mdast-util-to-markdown` to enable GFM task list\r\n * items in markdown.\r\n *\r\n * @returns {ToMarkdownExtension}\r\n *   Extension for `mdast-util-to-markdown` to enable GFM task list items.\r\n */\r\nexport function gfmTaskListItemToMarkdown() {\r\n  return {\r\n    unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],\r\n    handlers: {listItem: listItemWithTaskListItem}\r\n  }\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction exitCheck(token) {\r\n  // We’re always in a paragraph, in a list item.\r\n  const node = this.stack[this.stack.length - 2]\r\n  assert(node.type === 'listItem')\r\n  node.checked = token.type === 'taskListCheckValueChecked'\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @type {FromMarkdownHandle}\r\n */\r\nfunction exitParagraphWithTaskListItem(token) {\r\n  const parent = this.stack[this.stack.length - 2]\r\n\r\n  if (\r\n    parent &&\r\n    parent.type === 'listItem' &&\r\n    typeof parent.checked === 'boolean'\r\n  ) {\r\n    const node = this.stack[this.stack.length - 1]\r\n    assert(node.type === 'paragraph')\r\n    const head = node.children[0]\r\n\r\n    if (head && head.type === 'text') {\r\n      const siblings = parent.children\r\n      let index = -1\r\n      /** @type {Paragraph | undefined} */\r\n      let firstParaghraph\r\n\r\n      while (++index < siblings.length) {\r\n        const sibling = siblings[index]\r\n        if (sibling.type === 'paragraph') {\r\n          firstParaghraph = sibling\r\n          break\r\n        }\r\n      }\r\n\r\n      if (firstParaghraph === node) {\r\n        // Must start with a space or a tab.\r\n        head.value = head.value.slice(1)\r\n\r\n        if (head.value.length === 0) {\r\n          node.children.shift()\r\n        } else if (\r\n          node.position &&\r\n          head.position &&\r\n          typeof head.position.start.offset === 'number'\r\n        ) {\r\n          head.position.start.column++\r\n          head.position.start.offset++\r\n          node.position.start = Object.assign({}, head.position.start)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  this.exit(token)\r\n}\r\n\r\n/**\r\n * @type {ToMarkdownHandle}\r\n * @param {ListItem} node\r\n */\r\nfunction listItemWithTaskListItem(node, parent, state, info) {\r\n  const head = node.children[0]\r\n  const checkable =\r\n    typeof node.checked === 'boolean' && head && head.type === 'paragraph'\r\n  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] '\r\n  const tracker = state.createTracker(info)\r\n\r\n  if (checkable) {\r\n    tracker.move(checkbox)\r\n  }\r\n\r\n  let value = defaultHandlers.listItem(node, parent, state, {\r\n    ...info,\r\n    ...tracker.current()\r\n  })\r\n\r\n  if (checkable) {\r\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check)\r\n  }\r\n\r\n  return value\r\n\r\n  /**\r\n   * @param {string} $0\r\n   * @returns {string}\r\n   */\r\n  function check($0) {\r\n    return $0 + checkbox\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\r\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\r\n */\r\n\r\n/**\r\n * @typedef {import('mdast-util-gfm-table').Options} Options\r\n *   Configuration.\r\n */\r\n\r\nimport {\r\n  gfmAutolinkLiteralFromMarkdown,\r\n  gfmAutolinkLiteralToMarkdown\r\n} from 'mdast-util-gfm-autolink-literal'\r\nimport {\r\n  gfmFootnoteFromMarkdown,\r\n  gfmFootnoteToMarkdown\r\n} from 'mdast-util-gfm-footnote'\r\nimport {\r\n  gfmStrikethroughFromMarkdown,\r\n  gfmStrikethroughToMarkdown\r\n} from 'mdast-util-gfm-strikethrough'\r\nimport {gfmTableFromMarkdown, gfmTableToMarkdown} from 'mdast-util-gfm-table'\r\nimport {\r\n  gfmTaskListItemFromMarkdown,\r\n  gfmTaskListItemToMarkdown\r\n} from 'mdast-util-gfm-task-list-item'\r\n\r\n/**\r\n * Create an extension for `mdast-util-from-markdown` to enable GFM (autolink\r\n * literals, footnotes, strikethrough, tables, tasklists).\r\n *\r\n * @returns {Array<FromMarkdownExtension>}\r\n *   Extension for `mdast-util-from-markdown` to enable GFM (autolink literals,\r\n *   footnotes, strikethrough, tables, tasklists).\r\n */\r\nexport function gfmFromMarkdown() {\r\n  return [\r\n    gfmAutolinkLiteralFromMarkdown(),\r\n    gfmFootnoteFromMarkdown(),\r\n    gfmStrikethroughFromMarkdown(),\r\n    gfmTableFromMarkdown(),\r\n    gfmTaskListItemFromMarkdown()\r\n  ]\r\n}\r\n\r\n/**\r\n * Create an extension for `mdast-util-to-markdown` to enable GFM (autolink\r\n * literals, footnotes, strikethrough, tables, tasklists).\r\n *\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration.\r\n * @returns {ToMarkdownExtension}\r\n *   Extension for `mdast-util-to-markdown` to enable GFM (autolink literals,\r\n *   footnotes, strikethrough, tables, tasklists).\r\n */\r\nexport function gfmToMarkdown(options) {\r\n  return {\r\n    extensions: [\r\n      gfmAutolinkLiteralToMarkdown(),\r\n      gfmFootnoteToMarkdown(),\r\n      gfmStrikethroughToMarkdown(),\r\n      gfmTableToMarkdown(options),\r\n      gfmTaskListItemToMarkdown()\r\n    ]\r\n  }\r\n}\r\n", "/**\r\n * @import {Code, ConstructRecord, Event, Extension, Previous, State, TokenizeContext, Tokenizer} from 'micromark-util-types'\r\n */\r\n\r\nimport {\r\n  asciiAlpha,\r\n  asciiAlphanumeric,\r\n  asciiControl,\r\n  markdownLineEndingOrSpace,\r\n  unicodePunctuation,\r\n  unicodeWhitespace\r\n} from 'micromark-util-character'\r\nimport {codes} from 'micromark-util-symbol'\r\n\r\nconst wwwPrefix = {tokenize: tokenizeWwwPrefix, partial: true}\r\nconst domain = {tokenize: tokenizeDomain, partial: true}\r\nconst path = {tokenize: tokenizePath, partial: true}\r\nconst trail = {tokenize: tokenizeTrail, partial: true}\r\nconst emailDomainDotTrail = {\r\n  tokenize: tokenizeEmailDomainDotTrail,\r\n  partial: true\r\n}\r\n\r\nconst wwwAutolink = {\r\n  name: 'wwwAutolink',\r\n  tokenize: tokenizeWwwAutolink,\r\n  previous: previousWww\r\n}\r\n\r\nconst protocolAutolink = {\r\n  name: 'protocolAutolink',\r\n  tokenize: tokenizeProtocolAutolink,\r\n  previous: previousProtocol\r\n}\r\n\r\nconst emailAutolink = {\r\n  name: 'emailAutolink',\r\n  tokenize: tokenizeEmailAutolink,\r\n  previous: previousEmail\r\n}\r\n\r\n/** @type {ConstructRecord} */\r\nconst text = {}\r\n\r\n/**\r\n * Create an extension for `micromark` to support GitHub autolink literal\r\n * syntax.\r\n *\r\n * @returns {Extension}\r\n *   Extension for `micromark` that can be passed in `extensions` to enable GFM\r\n *   autolink literal syntax.\r\n */\r\nexport function gfmAutolinkLiteral() {\r\n  return {text}\r\n}\r\n\r\n/** @type {Code} */\r\nlet code = codes.digit0\r\n\r\n// Add alphanumerics.\r\nwhile (code < codes.leftCurlyBrace) {\r\n  text[code] = emailAutolink\r\n  code++\r\n  if (code === codes.colon) code = codes.uppercaseA\r\n  else if (code === codes.leftSquareBracket) code = codes.lowercaseA\r\n}\r\n\r\ntext[codes.plusSign] = emailAutolink\r\ntext[codes.dash] = emailAutolink\r\ntext[codes.dot] = emailAutolink\r\ntext[codes.underscore] = emailAutolink\r\ntext[codes.uppercaseH] = [emailAutolink, protocolAutolink]\r\ntext[codes.lowercaseH] = [emailAutolink, protocolAutolink]\r\ntext[codes.uppercaseW] = [emailAutolink, wwwAutolink]\r\ntext[codes.lowercaseW] = [emailAutolink, wwwAutolink]\r\n\r\n// To do: perform email autolink literals on events, afterwards.\r\n// That’s where `markdown-rs` and `cmark-gfm` perform it.\r\n// It should look for `@`, then for atext backwards, and then for a label\r\n// forwards.\r\n// To do: `mailto:`, `xmpp:` protocol as prefix.\r\n\r\n/**\r\n * Email autolink literal.\r\n *\r\n * ```markdown\r\n * > | a contact@example.org b\r\n *       ^^^^^^^^^^^^^^^^^^^\r\n * ```\r\n *\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeEmailAutolink(effects, ok, nok) {\r\n  const self = this\r\n  /** @type {boolean | undefined} */\r\n  let dot\r\n  /** @type {boolean} */\r\n  let data\r\n\r\n  return start\r\n\r\n  /**\r\n   * Start of email autolink literal.\r\n   *\r\n   * ```markdown\r\n   * > | a contact@example.org b\r\n   *       ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function start(code) {\r\n    if (\r\n      !gfmAtext(code) ||\r\n      !previousEmail.call(self, self.previous) ||\r\n      previousUnbalanced(self.events)\r\n    ) {\r\n      return nok(code)\r\n    }\r\n\r\n    effects.enter('literalAutolink')\r\n    effects.enter('literalAutolinkEmail')\r\n    return atext(code)\r\n  }\r\n\r\n  /**\r\n   * In email atext.\r\n   *\r\n   * ```markdown\r\n   * > | a contact@example.org b\r\n   *       ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function atext(code) {\r\n    if (gfmAtext(code)) {\r\n      effects.consume(code)\r\n      return atext\r\n    }\r\n\r\n    if (code === codes.atSign) {\r\n      effects.consume(code)\r\n      return emailDomain\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /**\r\n   * In email domain.\r\n   *\r\n   * The reference code is a bit overly complex as it handles the `@`, of which\r\n   * there may be just one.\r\n   * Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L318>\r\n   *\r\n   * ```markdown\r\n   * > | a contact@example.org b\r\n   *               ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function emailDomain(code) {\r\n    // Dot followed by alphanumerical (not `-` or `_`).\r\n    if (code === codes.dot) {\r\n      return effects.check(\r\n        emailDomainDotTrail,\r\n        emailDomainAfter,\r\n        emailDomainDot\r\n      )(code)\r\n    }\r\n\r\n    // Alphanumerical, `-`, and `_`.\r\n    if (\r\n      code === codes.dash ||\r\n      code === codes.underscore ||\r\n      asciiAlphanumeric(code)\r\n    ) {\r\n      data = true\r\n      effects.consume(code)\r\n      return emailDomain\r\n    }\r\n\r\n    // To do: `/` if xmpp.\r\n\r\n    // Note: normally we’d truncate trailing punctuation from the link.\r\n    // However, email autolink literals cannot contain any of those markers,\r\n    // except for `.`, but that can only occur if it isn’t trailing.\r\n    // So we can ignore truncating!\r\n    return emailDomainAfter(code)\r\n  }\r\n\r\n  /**\r\n   * In email domain, on dot that is not a trail.\r\n   *\r\n   * ```markdown\r\n   * > | a contact@example.org b\r\n   *                      ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function emailDomainDot(code) {\r\n    effects.consume(code)\r\n    dot = true\r\n    return emailDomain\r\n  }\r\n\r\n  /**\r\n   * After email domain.\r\n   *\r\n   * ```markdown\r\n   * > | a contact@example.org b\r\n   *                          ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function emailDomainAfter(code) {\r\n    // Domain must not be empty, must include a dot, and must end in alphabetical.\r\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L332>.\r\n    if (data && dot && asciiAlpha(self.previous)) {\r\n      effects.exit('literalAutolinkEmail')\r\n      effects.exit('literalAutolink')\r\n      return ok(code)\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n}\r\n\r\n/**\r\n * `www` autolink literal.\r\n *\r\n * ```markdown\r\n * > | a www.example.org b\r\n *       ^^^^^^^^^^^^^^^\r\n * ```\r\n *\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeWwwAutolink(effects, ok, nok) {\r\n  const self = this\r\n\r\n  return wwwStart\r\n\r\n  /**\r\n   * Start of www autolink literal.\r\n   *\r\n   * ```markdown\r\n   * > | www.example.com/a?b#c\r\n   *     ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function wwwStart(code) {\r\n    if (\r\n      (code !== codes.uppercaseW && code !== codes.lowercaseW) ||\r\n      !previousWww.call(self, self.previous) ||\r\n      previousUnbalanced(self.events)\r\n    ) {\r\n      return nok(code)\r\n    }\r\n\r\n    effects.enter('literalAutolink')\r\n    effects.enter('literalAutolinkWww')\r\n    // Note: we *check*, so we can discard the `www.` we parsed.\r\n    // If it worked, we consider it as a part of the domain.\r\n    return effects.check(\r\n      wwwPrefix,\r\n      effects.attempt(domain, effects.attempt(path, wwwAfter), nok),\r\n      nok\r\n    )(code)\r\n  }\r\n\r\n  /**\r\n   * After a www autolink literal.\r\n   *\r\n   * ```markdown\r\n   * > | www.example.com/a?b#c\r\n   *                          ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function wwwAfter(code) {\r\n    effects.exit('literalAutolinkWww')\r\n    effects.exit('literalAutolink')\r\n    return ok(code)\r\n  }\r\n}\r\n\r\n/**\r\n * Protocol autolink literal.\r\n *\r\n * ```markdown\r\n * > | a https://example.org b\r\n *       ^^^^^^^^^^^^^^^^^^^\r\n * ```\r\n *\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeProtocolAutolink(effects, ok, nok) {\r\n  const self = this\r\n  let buffer = ''\r\n  let seen = false\r\n\r\n  return protocolStart\r\n\r\n  /**\r\n   * Start of protocol autolink literal.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a?b#c\r\n   *     ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function protocolStart(code) {\r\n    if (\r\n      (code === codes.uppercaseH || code === codes.lowercaseH) &&\r\n      previousProtocol.call(self, self.previous) &&\r\n      !previousUnbalanced(self.events)\r\n    ) {\r\n      effects.enter('literalAutolink')\r\n      effects.enter('literalAutolinkHttp')\r\n      buffer += String.fromCodePoint(code)\r\n      effects.consume(code)\r\n      return protocolPrefixInside\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /**\r\n   * In protocol.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a?b#c\r\n   *     ^^^^^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function protocolPrefixInside(code) {\r\n    // `5` is size of `https`\r\n    if (asciiAlpha(code) && buffer.length < 5) {\r\n      // @ts-expect-error: definitely number.\r\n      buffer += String.fromCodePoint(code)\r\n      effects.consume(code)\r\n      return protocolPrefixInside\r\n    }\r\n\r\n    if (code === codes.colon) {\r\n      const protocol = buffer.toLowerCase()\r\n\r\n      if (protocol === 'http' || protocol === 'https') {\r\n        effects.consume(code)\r\n        return protocolSlashesInside\r\n      }\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /**\r\n   * In slashes.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a?b#c\r\n   *           ^^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function protocolSlashesInside(code) {\r\n    if (code === codes.slash) {\r\n      effects.consume(code)\r\n\r\n      if (seen) {\r\n        return afterProtocol\r\n      }\r\n\r\n      seen = true\r\n      return protocolSlashesInside\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /**\r\n   * After protocol, before domain.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a?b#c\r\n   *             ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function afterProtocol(code) {\r\n    // To do: this is different from `markdown-rs`:\r\n    // https://github.com/wooorm/markdown-rs/blob/b3a921c761309ae00a51fe348d8a43adbc54b518/src/construct/gfm_autolink_literal.rs#L172-L182\r\n    return code === codes.eof ||\r\n      asciiControl(code) ||\r\n      markdownLineEndingOrSpace(code) ||\r\n      unicodeWhitespace(code) ||\r\n      unicodePunctuation(code)\r\n      ? nok(code)\r\n      : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code)\r\n  }\r\n\r\n  /**\r\n   * After a protocol autolink literal.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a?b#c\r\n   *                              ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function protocolAfter(code) {\r\n    effects.exit('literalAutolinkHttp')\r\n    effects.exit('literalAutolink')\r\n    return ok(code)\r\n  }\r\n}\r\n\r\n/**\r\n * `www` prefix.\r\n *\r\n * ```markdown\r\n * > | a www.example.org b\r\n *       ^^^^\r\n * ```\r\n *\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeWwwPrefix(effects, ok, nok) {\r\n  let size = 0\r\n\r\n  return wwwPrefixInside\r\n\r\n  /**\r\n   * In www prefix.\r\n   *\r\n   * ```markdown\r\n   * > | www.example.com\r\n   *     ^^^^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function wwwPrefixInside(code) {\r\n    if ((code === codes.uppercaseW || code === codes.lowercaseW) && size < 3) {\r\n      size++\r\n      effects.consume(code)\r\n      return wwwPrefixInside\r\n    }\r\n\r\n    if (code === codes.dot && size === 3) {\r\n      effects.consume(code)\r\n      return wwwPrefixAfter\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /**\r\n   * After www prefix.\r\n   *\r\n   * ```markdown\r\n   * > | www.example.com\r\n   *         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function wwwPrefixAfter(code) {\r\n    // If there is *anything*, we can link.\r\n    return code === codes.eof ? nok(code) : ok(code)\r\n  }\r\n}\r\n\r\n/**\r\n * Domain.\r\n *\r\n * ```markdown\r\n * > | a https://example.org b\r\n *               ^^^^^^^^^^^\r\n * ```\r\n *\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeDomain(effects, ok, nok) {\r\n  /** @type {boolean | undefined} */\r\n  let underscoreInLastSegment\r\n  /** @type {boolean | undefined} */\r\n  let underscoreInLastLastSegment\r\n  /** @type {boolean | undefined} */\r\n  let seen\r\n\r\n  return domainInside\r\n\r\n  /**\r\n   * In domain.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a\r\n   *             ^^^^^^^^^^^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function domainInside(code) {\r\n    // Check whether this marker, which is a trailing punctuation\r\n    // marker, optionally followed by more trailing markers, and then\r\n    // followed by an end.\r\n    if (code === codes.dot || code === codes.underscore) {\r\n      return effects.check(trail, domainAfter, domainAtPunctuation)(code)\r\n    }\r\n\r\n    // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\r\n    // occur, which sounds like ASCII only, but they also support `www.點看.com`,\r\n    // so that’s Unicode.\r\n    // Instead of some new production for Unicode alphanumerics, markdown\r\n    // already has that for Unicode punctuation and whitespace, so use those.\r\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L12>.\r\n    if (\r\n      code === codes.eof ||\r\n      markdownLineEndingOrSpace(code) ||\r\n      unicodeWhitespace(code) ||\r\n      (code !== codes.dash && unicodePunctuation(code))\r\n    ) {\r\n      return domainAfter(code)\r\n    }\r\n\r\n    seen = true\r\n    effects.consume(code)\r\n    return domainInside\r\n  }\r\n\r\n  /**\r\n   * In domain, at potential trailing punctuation, that was not trailing.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com\r\n   *                    ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function domainAtPunctuation(code) {\r\n    // There is an underscore in the last segment of the domain\r\n    if (code === codes.underscore) {\r\n      underscoreInLastSegment = true\r\n    }\r\n    // Otherwise, it’s a `.`: save the last segment underscore in the\r\n    // penultimate segment slot.\r\n    else {\r\n      underscoreInLastLastSegment = underscoreInLastSegment\r\n      underscoreInLastSegment = undefined\r\n    }\r\n\r\n    effects.consume(code)\r\n    return domainInside\r\n  }\r\n\r\n  /**\r\n   * After domain.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a\r\n   *                        ^\r\n   * ```\r\n   *\r\n   * @type {State} */\r\n  function domainAfter(code) {\r\n    // Note: that’s GH says a dot is needed, but it’s not true:\r\n    // <https://github.com/github/cmark-gfm/issues/279>\r\n    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {\r\n      return nok(code)\r\n    }\r\n\r\n    return ok(code)\r\n  }\r\n}\r\n\r\n/**\r\n * Path.\r\n *\r\n * ```markdown\r\n * > | a https://example.org/stuff b\r\n *                          ^^^^^^\r\n * ```\r\n *\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizePath(effects, ok) {\r\n  let sizeOpen = 0\r\n  let sizeClose = 0\r\n\r\n  return pathInside\r\n\r\n  /**\r\n   * In path.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a\r\n   *                        ^^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function pathInside(code) {\r\n    if (code === codes.leftParenthesis) {\r\n      sizeOpen++\r\n      effects.consume(code)\r\n      return pathInside\r\n    }\r\n\r\n    // To do: `markdown-rs` also needs this.\r\n    // If this is a paren, and there are less closings than openings,\r\n    // we don’t check for a trail.\r\n    if (code === codes.rightParenthesis && sizeClose < sizeOpen) {\r\n      return pathAtPunctuation(code)\r\n    }\r\n\r\n    // Check whether this trailing punctuation marker is optionally\r\n    // followed by more trailing markers, and then followed\r\n    // by an end.\r\n    if (\r\n      code === codes.exclamationMark ||\r\n      code === codes.quotationMark ||\r\n      code === codes.ampersand ||\r\n      code === codes.apostrophe ||\r\n      code === codes.rightParenthesis ||\r\n      code === codes.asterisk ||\r\n      code === codes.comma ||\r\n      code === codes.dot ||\r\n      code === codes.colon ||\r\n      code === codes.semicolon ||\r\n      code === codes.lessThan ||\r\n      code === codes.questionMark ||\r\n      code === codes.rightSquareBracket ||\r\n      code === codes.underscore ||\r\n      code === codes.tilde\r\n    ) {\r\n      return effects.check(trail, ok, pathAtPunctuation)(code)\r\n    }\r\n\r\n    if (\r\n      code === codes.eof ||\r\n      markdownLineEndingOrSpace(code) ||\r\n      unicodeWhitespace(code)\r\n    ) {\r\n      return ok(code)\r\n    }\r\n\r\n    effects.consume(code)\r\n    return pathInside\r\n  }\r\n\r\n  /**\r\n   * In path, at potential trailing punctuation, that was not trailing.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com/a\"b\r\n   *                          ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function pathAtPunctuation(code) {\r\n    // Count closing parens.\r\n    if (code === codes.rightParenthesis) {\r\n      sizeClose++\r\n    }\r\n\r\n    effects.consume(code)\r\n    return pathInside\r\n  }\r\n}\r\n\r\n/**\r\n * Trail.\r\n *\r\n * This calls `ok` if this *is* the trail, followed by an end, which means\r\n * the entire trail is not part of the link.\r\n * It calls `nok` if this *is* part of the link.\r\n *\r\n * ```markdown\r\n * > | https://example.com\").\r\n *                        ^^^\r\n * ```\r\n *\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeTrail(effects, ok, nok) {\r\n  return trail\r\n\r\n  /**\r\n   * In trail of domain or path.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com\").\r\n   *                        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function trail(code) {\r\n    // Regular trailing punctuation.\r\n    if (\r\n      code === codes.exclamationMark ||\r\n      code === codes.quotationMark ||\r\n      code === codes.apostrophe ||\r\n      code === codes.rightParenthesis ||\r\n      code === codes.asterisk ||\r\n      code === codes.comma ||\r\n      code === codes.dot ||\r\n      code === codes.colon ||\r\n      code === codes.semicolon ||\r\n      code === codes.questionMark ||\r\n      code === codes.underscore ||\r\n      code === codes.tilde\r\n    ) {\r\n      effects.consume(code)\r\n      return trail\r\n    }\r\n\r\n    // `&` followed by one or more alphabeticals and then a `;`, is\r\n    // as a whole considered as trailing punctuation.\r\n    // In all other cases, it is considered as continuation of the URL.\r\n    if (code === codes.ampersand) {\r\n      effects.consume(code)\r\n      return trailCharacterReferenceStart\r\n    }\r\n\r\n    // Needed because we allow literals after `[`, as we fix:\r\n    // <https://github.com/github/cmark-gfm/issues/278>.\r\n    // Check that it is not followed by `(` or `[`.\r\n    if (code === codes.rightSquareBracket) {\r\n      effects.consume(code)\r\n      return trailBracketAfter\r\n    }\r\n\r\n    if (\r\n      // `<` is an end.\r\n      code === codes.lessThan ||\r\n      // So is whitespace.\r\n      code === codes.eof ||\r\n      markdownLineEndingOrSpace(code) ||\r\n      unicodeWhitespace(code)\r\n    ) {\r\n      return ok(code)\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /**\r\n   * In trail, after `]`.\r\n   *\r\n   * > 👉 **Note**: this deviates from `cmark-gfm` to fix a bug.\r\n   * > See end of <https://github.com/github/cmark-gfm/issues/278> for more.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com](\r\n   *                         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function trailBracketAfter(code) {\r\n    // Whitespace or something that could start a resource or reference is the end.\r\n    // Switch back to trail otherwise.\r\n    if (\r\n      code === codes.eof ||\r\n      code === codes.leftParenthesis ||\r\n      code === codes.leftSquareBracket ||\r\n      markdownLineEndingOrSpace(code) ||\r\n      unicodeWhitespace(code)\r\n    ) {\r\n      return ok(code)\r\n    }\r\n\r\n    return trail(code)\r\n  }\r\n\r\n  /**\r\n   * In character-reference like trail, after `&`.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com&amp;).\r\n   *                         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function trailCharacterReferenceStart(code) {\r\n    // When non-alpha, it’s not a trail.\r\n    return asciiAlpha(code) ? trailCharacterReferenceInside(code) : nok(code)\r\n  }\r\n\r\n  /**\r\n   * In character-reference like trail.\r\n   *\r\n   * ```markdown\r\n   * > | https://example.com&amp;).\r\n   *                         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function trailCharacterReferenceInside(code) {\r\n    // Switch back to trail if this is well-formed.\r\n    if (code === codes.semicolon) {\r\n      effects.consume(code)\r\n      return trail\r\n    }\r\n\r\n    if (asciiAlpha(code)) {\r\n      effects.consume(code)\r\n      return trailCharacterReferenceInside\r\n    }\r\n\r\n    // It’s not a trail.\r\n    return nok(code)\r\n  }\r\n}\r\n\r\n/**\r\n * Dot in email domain trail.\r\n *\r\n * This calls `ok` if this *is* the trail, followed by an end, which means\r\n * the trail is not part of the link.\r\n * It calls `nok` if this *is* part of the link.\r\n *\r\n * ```markdown\r\n * > | contact@example.org.\r\n *                        ^\r\n * ```\r\n *\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeEmailDomainDotTrail(effects, ok, nok) {\r\n  return start\r\n\r\n  /**\r\n   * Dot.\r\n   *\r\n   * ```markdown\r\n   * > | contact@example.org.\r\n   *                    ^   ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function start(code) {\r\n    // Must be dot.\r\n    effects.consume(code)\r\n    return after\r\n  }\r\n\r\n  /**\r\n   * After dot.\r\n   *\r\n   * ```markdown\r\n   * > | contact@example.org.\r\n   *                     ^   ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function after(code) {\r\n    // Not a trail if alphanumeric.\r\n    return asciiAlphanumeric(code) ? nok(code) : ok(code)\r\n  }\r\n}\r\n\r\n/**\r\n * See:\r\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L156>.\r\n *\r\n * @type {Previous}\r\n */\r\nfunction previousWww(code) {\r\n  return (\r\n    code === codes.eof ||\r\n    code === codes.leftParenthesis ||\r\n    code === codes.asterisk ||\r\n    code === codes.underscore ||\r\n    code === codes.leftSquareBracket ||\r\n    code === codes.rightSquareBracket ||\r\n    code === codes.tilde ||\r\n    markdownLineEndingOrSpace(code)\r\n  )\r\n}\r\n\r\n/**\r\n * See:\r\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L214>.\r\n *\r\n * @type {Previous}\r\n */\r\nfunction previousProtocol(code) {\r\n  return !asciiAlpha(code)\r\n}\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n * @type {Previous}\r\n */\r\nfunction previousEmail(code) {\r\n  // Do not allow a slash “inside” atext.\r\n  // The reference code is a bit weird, but that’s what it results in.\r\n  // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L307>.\r\n  // Other than slash, every preceding character is allowed.\r\n  return !(code === codes.slash || gfmAtext(code))\r\n}\r\n\r\n/**\r\n * @param {Code} code\r\n * @returns {boolean}\r\n */\r\nfunction gfmAtext(code) {\r\n  return (\r\n    code === codes.plusSign ||\r\n    code === codes.dash ||\r\n    code === codes.dot ||\r\n    code === codes.underscore ||\r\n    asciiAlphanumeric(code)\r\n  )\r\n}\r\n\r\n/**\r\n * @param {Array<Event>} events\r\n * @returns {boolean}\r\n */\r\nfunction previousUnbalanced(events) {\r\n  let index = events.length\r\n  let result = false\r\n\r\n  while (index--) {\r\n    const token = events[index][1]\r\n\r\n    if (\r\n      (token.type === 'labelLink' || token.type === 'labelImage') &&\r\n      !token._balanced\r\n    ) {\r\n      result = true\r\n      break\r\n    }\r\n\r\n    // If we’ve seen this token, and it was marked as not having any unbalanced\r\n    // bracket before it, we can exit.\r\n    if (token._gfmAutolinkLiteralWalkedInto) {\r\n      result = false\r\n      break\r\n    }\r\n  }\r\n\r\n  if (events.length > 0 && !result) {\r\n    // Mark the last token as “walked into” w/o finding\r\n    // anything.\r\n    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true\r\n  }\r\n\r\n  return result\r\n}\r\n", "/**\r\n * @import {Event, Exiter, Extension, Resolver, State, Token, TokenizeContext, Tokenizer} from 'micromark-util-types'\r\n */\r\n\r\nimport {ok as assert} from 'devlop'\r\nimport {blankLine} from 'micromark-core-commonmark'\r\nimport {factorySpace} from 'micromark-factory-space'\r\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\r\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\r\nimport {codes, constants, types} from 'micromark-util-symbol'\r\n\r\nconst indent = {tokenize: tokenizeIndent, partial: true}\r\n\r\n// To do: micromark should support a `_hiddenGfmFootnoteSupport`, which only\r\n// affects label start (image).\r\n// That will let us drop `tokenizePotentialGfmFootnote*`.\r\n// It currently has a `_hiddenFootnoteSupport`, which affects that and more.\r\n// That can be removed when `micromark-extension-footnote` is archived.\r\n\r\n/**\r\n * Create an extension for `micromark` to enable GFM footnote syntax.\r\n *\r\n * @returns {Extension}\r\n *   Extension for `micromark` that can be passed in `extensions` to\r\n *   enable GFM footnote syntax.\r\n */\r\nexport function gfmFootnote() {\r\n  /** @type {Extension} */\r\n  return {\r\n    document: {\r\n      [codes.leftSquareBracket]: {\r\n        name: 'gfmFootnoteDefinition',\r\n        tokenize: tokenizeDefinitionStart,\r\n        continuation: {tokenize: tokenizeDefinitionContinuation},\r\n        exit: gfmFootnoteDefinitionEnd\r\n      }\r\n    },\r\n    text: {\r\n      [codes.leftSquareBracket]: {\r\n        name: 'gfmFootnoteCall',\r\n        tokenize: tokenizeGfmFootnoteCall\r\n      },\r\n      [codes.rightSquareBracket]: {\r\n        name: 'gfmPotentialFootnoteCall',\r\n        add: 'after',\r\n        tokenize: tokenizePotentialGfmFootnoteCall,\r\n        resolveTo: resolveToPotentialGfmFootnoteCall\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// To do: remove after micromark update.\r\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizePotentialGfmFootnoteCall(effects, ok, nok) {\r\n  const self = this\r\n  let index = self.events.length\r\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\r\n  /** @type {Token} */\r\n  let labelStart\r\n\r\n  // Find an opening.\r\n  while (index--) {\r\n    const token = self.events[index][1]\r\n\r\n    if (token.type === types.labelImage) {\r\n      labelStart = token\r\n      break\r\n    }\r\n\r\n    // Exit if we’ve walked far enough.\r\n    if (\r\n      token.type === 'gfmFootnoteCall' ||\r\n      token.type === types.labelLink ||\r\n      token.type === types.label ||\r\n      token.type === types.image ||\r\n      token.type === types.link\r\n    ) {\r\n      break\r\n    }\r\n  }\r\n\r\n  return start\r\n\r\n  /**\r\n   * @type {State}\r\n   */\r\n  function start(code) {\r\n    assert(code === codes.rightSquareBracket, 'expected `]`')\r\n\r\n    if (!labelStart || !labelStart._balanced) {\r\n      return nok(code)\r\n    }\r\n\r\n    const id = normalizeIdentifier(\r\n      self.sliceSerialize({start: labelStart.end, end: self.now()})\r\n    )\r\n\r\n    if (id.codePointAt(0) !== codes.caret || !defined.includes(id.slice(1))) {\r\n      return nok(code)\r\n    }\r\n\r\n    effects.enter('gfmFootnoteCallLabelMarker')\r\n    effects.consume(code)\r\n    effects.exit('gfmFootnoteCallLabelMarker')\r\n    return ok(code)\r\n  }\r\n}\r\n\r\n// To do: remove after micromark update.\r\n/** @type {Resolver} */\r\nfunction resolveToPotentialGfmFootnoteCall(events, context) {\r\n  let index = events.length\r\n  /** @type {Token | undefined} */\r\n  let labelStart\r\n\r\n  // Find an opening.\r\n  while (index--) {\r\n    if (\r\n      events[index][1].type === types.labelImage &&\r\n      events[index][0] === 'enter'\r\n    ) {\r\n      labelStart = events[index][1]\r\n      break\r\n    }\r\n  }\r\n\r\n  assert(labelStart, 'expected `labelStart` to resolve')\r\n\r\n  // Change the `labelImageMarker` to a `data`.\r\n  events[index + 1][1].type = types.data\r\n  events[index + 3][1].type = 'gfmFootnoteCallLabelMarker'\r\n\r\n  // The whole (without `!`):\r\n  /** @type {Token} */\r\n  const call = {\r\n    type: 'gfmFootnoteCall',\r\n    start: Object.assign({}, events[index + 3][1].start),\r\n    end: Object.assign({}, events[events.length - 1][1].end)\r\n  }\r\n  // The `^` marker\r\n  /** @type {Token} */\r\n  const marker = {\r\n    type: 'gfmFootnoteCallMarker',\r\n    start: Object.assign({}, events[index + 3][1].end),\r\n    end: Object.assign({}, events[index + 3][1].end)\r\n  }\r\n  // Increment the end 1 character.\r\n  marker.end.column++\r\n  marker.end.offset++\r\n  marker.end._bufferIndex++\r\n  /** @type {Token} */\r\n  const string = {\r\n    type: 'gfmFootnoteCallString',\r\n    start: Object.assign({}, marker.end),\r\n    end: Object.assign({}, events[events.length - 1][1].start)\r\n  }\r\n  /** @type {Token} */\r\n  const chunk = {\r\n    type: types.chunkString,\r\n    contentType: 'string',\r\n    start: Object.assign({}, string.start),\r\n    end: Object.assign({}, string.end)\r\n  }\r\n\r\n  /** @type {Array<Event>} */\r\n  const replacement = [\r\n    // Take the `labelImageMarker` (now `data`, the `!`)\r\n    events[index + 1],\r\n    events[index + 2],\r\n    ['enter', call, context],\r\n    // The `[`\r\n    events[index + 3],\r\n    events[index + 4],\r\n    // The `^`.\r\n    ['enter', marker, context],\r\n    ['exit', marker, context],\r\n    // Everything in between.\r\n    ['enter', string, context],\r\n    ['enter', chunk, context],\r\n    ['exit', chunk, context],\r\n    ['exit', string, context],\r\n    // The ending (`]`, properly parsed and labelled).\r\n    events[events.length - 2],\r\n    events[events.length - 1],\r\n    ['exit', call, context]\r\n  ]\r\n\r\n  events.splice(index, events.length - index + 1, ...replacement)\r\n\r\n  return events\r\n}\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeGfmFootnoteCall(effects, ok, nok) {\r\n  const self = this\r\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\r\n  let size = 0\r\n  /** @type {boolean} */\r\n  let data\r\n\r\n  // Note: the implementation of `markdown-rs` is different, because it houses\r\n  // core *and* extensions in one project.\r\n  // Therefore, it can include footnote logic inside `label-end`.\r\n  // We can’t do that, but luckily, we can parse footnotes in a simpler way than\r\n  // needed for labels.\r\n  return start\r\n\r\n  /**\r\n   * Start of footnote label.\r\n   *\r\n   * ```markdown\r\n   * > | a [^b] c\r\n   *       ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function start(code) {\r\n    assert(code === codes.leftSquareBracket, 'expected `[`')\r\n    effects.enter('gfmFootnoteCall')\r\n    effects.enter('gfmFootnoteCallLabelMarker')\r\n    effects.consume(code)\r\n    effects.exit('gfmFootnoteCallLabelMarker')\r\n    return callStart\r\n  }\r\n\r\n  /**\r\n   * After `[`, at `^`.\r\n   *\r\n   * ```markdown\r\n   * > | a [^b] c\r\n   *        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function callStart(code) {\r\n    if (code !== codes.caret) return nok(code)\r\n\r\n    effects.enter('gfmFootnoteCallMarker')\r\n    effects.consume(code)\r\n    effects.exit('gfmFootnoteCallMarker')\r\n    effects.enter('gfmFootnoteCallString')\r\n    effects.enter('chunkString').contentType = 'string'\r\n    return callData\r\n  }\r\n\r\n  /**\r\n   * In label.\r\n   *\r\n   * ```markdown\r\n   * > | a [^b] c\r\n   *         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function callData(code) {\r\n    if (\r\n      // Too long.\r\n      size > constants.linkReferenceSizeMax ||\r\n      // Closing brace with nothing.\r\n      (code === codes.rightSquareBracket && !data) ||\r\n      // Space or tab is not supported by GFM for some reason.\r\n      // `\\n` and `[` not being supported makes sense.\r\n      code === codes.eof ||\r\n      code === codes.leftSquareBracket ||\r\n      markdownLineEndingOrSpace(code)\r\n    ) {\r\n      return nok(code)\r\n    }\r\n\r\n    if (code === codes.rightSquareBracket) {\r\n      effects.exit('chunkString')\r\n      const token = effects.exit('gfmFootnoteCallString')\r\n\r\n      if (!defined.includes(normalizeIdentifier(self.sliceSerialize(token)))) {\r\n        return nok(code)\r\n      }\r\n\r\n      effects.enter('gfmFootnoteCallLabelMarker')\r\n      effects.consume(code)\r\n      effects.exit('gfmFootnoteCallLabelMarker')\r\n      effects.exit('gfmFootnoteCall')\r\n      return ok\r\n    }\r\n\r\n    if (!markdownLineEndingOrSpace(code)) {\r\n      data = true\r\n    }\r\n\r\n    size++\r\n    effects.consume(code)\r\n    return code === codes.backslash ? callEscape : callData\r\n  }\r\n\r\n  /**\r\n   * On character after escape.\r\n   *\r\n   * ```markdown\r\n   * > | a [^b\\c] d\r\n   *           ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function callEscape(code) {\r\n    if (\r\n      code === codes.leftSquareBracket ||\r\n      code === codes.backslash ||\r\n      code === codes.rightSquareBracket\r\n    ) {\r\n      effects.consume(code)\r\n      size++\r\n      return callData\r\n    }\r\n\r\n    return callData(code)\r\n  }\r\n}\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeDefinitionStart(effects, ok, nok) {\r\n  const self = this\r\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\r\n  /** @type {string} */\r\n  let identifier\r\n  let size = 0\r\n  /** @type {boolean | undefined} */\r\n  let data\r\n\r\n  return start\r\n\r\n  /**\r\n   * Start of GFM footnote definition.\r\n   *\r\n   * ```markdown\r\n   * > | [^a]: b\r\n   *     ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function start(code) {\r\n    assert(code === codes.leftSquareBracket, 'expected `[`')\r\n    effects.enter('gfmFootnoteDefinition')._container = true\r\n    effects.enter('gfmFootnoteDefinitionLabel')\r\n    effects.enter('gfmFootnoteDefinitionLabelMarker')\r\n    effects.consume(code)\r\n    effects.exit('gfmFootnoteDefinitionLabelMarker')\r\n    return labelAtMarker\r\n  }\r\n\r\n  /**\r\n   * In label, at caret.\r\n   *\r\n   * ```markdown\r\n   * > | [^a]: b\r\n   *      ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function labelAtMarker(code) {\r\n    if (code === codes.caret) {\r\n      effects.enter('gfmFootnoteDefinitionMarker')\r\n      effects.consume(code)\r\n      effects.exit('gfmFootnoteDefinitionMarker')\r\n      effects.enter('gfmFootnoteDefinitionLabelString')\r\n      effects.enter('chunkString').contentType = 'string'\r\n      return labelInside\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /**\r\n   * In label.\r\n   *\r\n   * > 👉 **Note**: `cmark-gfm` prevents whitespace from occurring in footnote\r\n   * > definition labels.\r\n   *\r\n   * ```markdown\r\n   * > | [^a]: b\r\n   *       ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function labelInside(code) {\r\n    if (\r\n      // Too long.\r\n      size > constants.linkReferenceSizeMax ||\r\n      // Closing brace with nothing.\r\n      (code === codes.rightSquareBracket && !data) ||\r\n      // Space or tab is not supported by GFM for some reason.\r\n      // `\\n` and `[` not being supported makes sense.\r\n      code === codes.eof ||\r\n      code === codes.leftSquareBracket ||\r\n      markdownLineEndingOrSpace(code)\r\n    ) {\r\n      return nok(code)\r\n    }\r\n\r\n    if (code === codes.rightSquareBracket) {\r\n      effects.exit('chunkString')\r\n      const token = effects.exit('gfmFootnoteDefinitionLabelString')\r\n      identifier = normalizeIdentifier(self.sliceSerialize(token))\r\n      effects.enter('gfmFootnoteDefinitionLabelMarker')\r\n      effects.consume(code)\r\n      effects.exit('gfmFootnoteDefinitionLabelMarker')\r\n      effects.exit('gfmFootnoteDefinitionLabel')\r\n      return labelAfter\r\n    }\r\n\r\n    if (!markdownLineEndingOrSpace(code)) {\r\n      data = true\r\n    }\r\n\r\n    size++\r\n    effects.consume(code)\r\n    return code === codes.backslash ? labelEscape : labelInside\r\n  }\r\n\r\n  /**\r\n   * After `\\`, at a special character.\r\n   *\r\n   * > 👉 **Note**: `cmark-gfm` currently does not support escaped brackets:\r\n   * > <https://github.com/github/cmark-gfm/issues/240>\r\n   *\r\n   * ```markdown\r\n   * > | [^a\\*b]: c\r\n   *         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function labelEscape(code) {\r\n    if (\r\n      code === codes.leftSquareBracket ||\r\n      code === codes.backslash ||\r\n      code === codes.rightSquareBracket\r\n    ) {\r\n      effects.consume(code)\r\n      size++\r\n      return labelInside\r\n    }\r\n\r\n    return labelInside(code)\r\n  }\r\n\r\n  /**\r\n   * After definition label.\r\n   *\r\n   * ```markdown\r\n   * > | [^a]: b\r\n   *         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function labelAfter(code) {\r\n    if (code === codes.colon) {\r\n      effects.enter('definitionMarker')\r\n      effects.consume(code)\r\n      effects.exit('definitionMarker')\r\n\r\n      if (!defined.includes(identifier)) {\r\n        defined.push(identifier)\r\n      }\r\n\r\n      // Any whitespace after the marker is eaten, forming indented code\r\n      // is not possible.\r\n      // No space is also fine, just like a block quote marker.\r\n      return factorySpace(\r\n        effects,\r\n        whitespaceAfter,\r\n        'gfmFootnoteDefinitionWhitespace'\r\n      )\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /**\r\n   * After definition prefix.\r\n   *\r\n   * ```markdown\r\n   * > | [^a]: b\r\n   *           ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function whitespaceAfter(code) {\r\n    // `markdown-rs` has a wrapping token for the prefix that is closed here.\r\n    return ok(code)\r\n  }\r\n}\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeDefinitionContinuation(effects, ok, nok) {\r\n  /// Start of footnote definition continuation.\r\n  ///\r\n  /// ```markdown\r\n  ///   | [^a]: b\r\n  /// > |     c\r\n  ///     ^\r\n  /// ```\r\n  //\r\n  // Either a blank line, which is okay, or an indented thing.\r\n  return effects.check(blankLine, ok, effects.attempt(indent, ok, nok))\r\n}\r\n\r\n/** @type {Exiter} */\r\nfunction gfmFootnoteDefinitionEnd(effects) {\r\n  effects.exit('gfmFootnoteDefinition')\r\n}\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeIndent(effects, ok, nok) {\r\n  const self = this\r\n\r\n  return factorySpace(\r\n    effects,\r\n    afterPrefix,\r\n    'gfmFootnoteDefinitionIndent',\r\n    constants.tabSize + 1\r\n  )\r\n\r\n  /**\r\n   * @type {State}\r\n   */\r\n  function afterPrefix(code) {\r\n    const tail = self.events[self.events.length - 1]\r\n    return tail &&\r\n      tail[1].type === 'gfmFootnoteDefinitionIndent' &&\r\n      tail[2].sliceSerialize(tail[1], true).length === constants.tabSize\r\n      ? ok(code)\r\n      : nok(code)\r\n  }\r\n}\r\n", "/**\r\n * @import {HtmlOptions as Options} from 'micromark-extension-gfm-footnote'\r\n * @import {HtmlExtension} from 'micromark-util-types'\r\n */\r\n\r\nimport {ok as assert} from 'devlop'\r\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\r\nimport {sanitizeUri} from 'micromark-util-sanitize-uri'\r\n\r\nconst own = {}.hasOwnProperty\r\n\r\n/** @type {Options} */\r\nconst emptyOptions = {}\r\n\r\n/**\r\n * Generate the default label that GitHub uses on backreferences.\r\n *\r\n * @param {number} referenceIndex\r\n *   Index of the definition in the order that they are first referenced,\r\n *   0-indexed.\r\n * @param {number} rereferenceIndex\r\n *   Index of calls to the same definition, 0-indexed.\r\n * @returns {string}\r\n *   Default label.\r\n */\r\nexport function defaultBackLabel(referenceIndex, rereferenceIndex) {\r\n  return (\r\n    'Back to reference ' +\r\n    (referenceIndex + 1) +\r\n    (rereferenceIndex > 1 ? '-' + rereferenceIndex : '')\r\n  )\r\n}\r\n\r\n/**\r\n * Create an extension for `micromark` to support GFM footnotes when\r\n * serializing to HTML.\r\n *\r\n * @param {Options | null | undefined} [options={}]\r\n *   Configuration (optional).\r\n * @returns {HtmlExtension}\r\n *   Extension for `micromark` that can be passed in `htmlExtensions` to\r\n *   support GFM footnotes when serializing to HTML.\r\n */\r\nexport function gfmFootnoteHtml(options) {\r\n  const config = options || emptyOptions\r\n  const label = config.label || 'Footnotes'\r\n  const labelTagName = config.labelTagName || 'h2'\r\n  const labelAttributes =\r\n    config.labelAttributes === null || config.labelAttributes === undefined\r\n      ? 'class=\"sr-only\"'\r\n      : config.labelAttributes\r\n  const backLabel = config.backLabel || defaultBackLabel\r\n  const clobberPrefix =\r\n    config.clobberPrefix === null || config.clobberPrefix === undefined\r\n      ? 'user-content-'\r\n      : config.clobberPrefix\r\n  return {\r\n    enter: {\r\n      gfmFootnoteDefinition() {\r\n        const stack = this.getData('tightStack')\r\n        stack.push(false)\r\n      },\r\n      gfmFootnoteDefinitionLabelString() {\r\n        this.buffer()\r\n      },\r\n      gfmFootnoteCallString() {\r\n        this.buffer()\r\n      }\r\n    },\r\n    exit: {\r\n      gfmFootnoteDefinition() {\r\n        let definitions = this.getData('gfmFootnoteDefinitions')\r\n        const footnoteStack = this.getData('gfmFootnoteDefinitionStack')\r\n        assert(footnoteStack, 'expected `footnoteStack`')\r\n        const tightStack = this.getData('tightStack')\r\n        const current = footnoteStack.pop()\r\n        const value = this.resume()\r\n\r\n        assert(current, 'expected to be in a footnote')\r\n\r\n        if (!definitions) {\r\n          this.setData('gfmFootnoteDefinitions', (definitions = {}))\r\n        }\r\n\r\n        if (!own.call(definitions, current)) definitions[current] = value\r\n\r\n        tightStack.pop()\r\n        this.setData('slurpOneLineEnding', true)\r\n        // “Hack” to prevent a line ending from showing up if we’re in a definition in\r\n        // an empty list item.\r\n        this.setData('lastWasTag')\r\n      },\r\n      gfmFootnoteDefinitionLabelString(token) {\r\n        let footnoteStack = this.getData('gfmFootnoteDefinitionStack')\r\n\r\n        if (!footnoteStack) {\r\n          this.setData('gfmFootnoteDefinitionStack', (footnoteStack = []))\r\n        }\r\n\r\n        footnoteStack.push(normalizeIdentifier(this.sliceSerialize(token)))\r\n        this.resume() // Drop the label.\r\n        this.buffer() // Get ready for a value.\r\n      },\r\n      gfmFootnoteCallString(token) {\r\n        let calls = this.getData('gfmFootnoteCallOrder')\r\n        let counts = this.getData('gfmFootnoteCallCounts')\r\n        const id = normalizeIdentifier(this.sliceSerialize(token))\r\n        /** @type {number} */\r\n        let counter\r\n\r\n        this.resume()\r\n\r\n        if (!calls) this.setData('gfmFootnoteCallOrder', (calls = []))\r\n        if (!counts) this.setData('gfmFootnoteCallCounts', (counts = {}))\r\n\r\n        const index = calls.indexOf(id)\r\n        const safeId = sanitizeUri(id.toLowerCase())\r\n\r\n        if (index === -1) {\r\n          calls.push(id)\r\n          counts[id] = 1\r\n          counter = calls.length\r\n        } else {\r\n          counts[id]++\r\n          counter = index + 1\r\n        }\r\n\r\n        const reuseCounter = counts[id]\r\n\r\n        this.tag(\r\n          '<sup><a href=\"#' +\r\n            clobberPrefix +\r\n            'fn-' +\r\n            safeId +\r\n            '\" id=\"' +\r\n            clobberPrefix +\r\n            'fnref-' +\r\n            safeId +\r\n            (reuseCounter > 1 ? '-' + reuseCounter : '') +\r\n            '\" data-footnote-ref=\"\" aria-describedby=\"footnote-label\">' +\r\n            String(counter) +\r\n            '</a></sup>'\r\n        )\r\n      },\r\n      null() {\r\n        const calls = this.getData('gfmFootnoteCallOrder') || []\r\n        const counts = this.getData('gfmFootnoteCallCounts') || {}\r\n        const definitions = this.getData('gfmFootnoteDefinitions') || {}\r\n        let index = -1\r\n\r\n        if (calls.length > 0) {\r\n          this.lineEndingIfNeeded()\r\n          this.tag(\r\n            '<section data-footnotes=\"\" class=\"footnotes\"><' +\r\n              labelTagName +\r\n              ' id=\"footnote-label\"' +\r\n              (labelAttributes ? ' ' + labelAttributes : '') +\r\n              '>'\r\n          )\r\n          this.raw(this.encode(label))\r\n          this.tag('</' + labelTagName + '>')\r\n          this.lineEndingIfNeeded()\r\n          this.tag('<ol>')\r\n        }\r\n\r\n        while (++index < calls.length) {\r\n          // Called definitions are always defined.\r\n          const id = calls[index]\r\n          const safeId = sanitizeUri(id.toLowerCase())\r\n          let referenceIndex = 0\r\n          /** @type {Array<string>} */\r\n          const references = []\r\n\r\n          while (++referenceIndex <= counts[id]) {\r\n            references.push(\r\n              '<a href=\"#' +\r\n                clobberPrefix +\r\n                'fnref-' +\r\n                safeId +\r\n                (referenceIndex > 1 ? '-' + referenceIndex : '') +\r\n                '\" data-footnote-backref=\"\" aria-label=\"' +\r\n                this.encode(\r\n                  typeof backLabel === 'string'\r\n                    ? backLabel\r\n                    : backLabel(index, referenceIndex)\r\n                ) +\r\n                '\" class=\"data-footnote-backref\">↩' +\r\n                (referenceIndex > 1\r\n                  ? '<sup>' + referenceIndex + '</sup>'\r\n                  : '') +\r\n                '</a>'\r\n            )\r\n          }\r\n\r\n          const reference = references.join(' ')\r\n          let injected = false\r\n\r\n          this.lineEndingIfNeeded()\r\n          this.tag('<li id=\"' + clobberPrefix + 'fn-' + safeId + '\">')\r\n          this.lineEndingIfNeeded()\r\n          this.tag(\r\n            definitions[id].replace(/<\\/p>(?:\\r?\\n|\\r)?$/, function ($0) {\r\n              injected = true\r\n              return ' ' + reference + $0\r\n            })\r\n          )\r\n\r\n          if (!injected) {\r\n            this.lineEndingIfNeeded()\r\n            this.tag(reference)\r\n          }\r\n\r\n          this.lineEndingIfNeeded()\r\n          this.tag('</li>')\r\n        }\r\n\r\n        if (calls.length > 0) {\r\n          this.lineEndingIfNeeded()\r\n          this.tag('</ol>')\r\n          this.lineEndingIfNeeded()\r\n          this.tag('</section>')\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n", "/**\r\n * @import {Options} from 'micromark-extension-gfm-strikethrough'\r\n * @import {Event, Extension, Resolver, State, Token, TokenizeContext, Tokenizer} from 'micromark-util-types'\r\n */\r\n\r\nimport {ok as assert} from 'devlop'\r\nimport {splice} from 'micromark-util-chunked'\r\nimport {classifyCharacter} from 'micromark-util-classify-character'\r\nimport {resolveAll} from 'micromark-util-resolve-all'\r\nimport {codes, constants, types} from 'micromark-util-symbol'\r\n\r\n/**\r\n * Create an extension for `micromark` to enable GFM strikethrough syntax.\r\n *\r\n * @param {Options | null | undefined} [options={}]\r\n *   Configuration.\r\n * @returns {Extension}\r\n *   Extension for `micromark` that can be passed in `extensions`, to\r\n *   enable GFM strikethrough syntax.\r\n */\r\nexport function gfmStrikethrough(options) {\r\n  const options_ = options || {}\r\n  let single = options_.singleTilde\r\n  const tokenizer = {\r\n    name: 'strikethrough',\r\n    tokenize: tokenizeStrikethrough,\r\n    resolveAll: resolveAllStrikethrough\r\n  }\r\n\r\n  if (single === null || single === undefined) {\r\n    single = true\r\n  }\r\n\r\n  return {\r\n    text: {[codes.tilde]: tokenizer},\r\n    insideSpan: {null: [tokenizer]},\r\n    attentionMarkers: {null: [codes.tilde]}\r\n  }\r\n\r\n  /**\r\n   * Take events and resolve strikethrough.\r\n   *\r\n   * @type {Resolver}\r\n   */\r\n  function resolveAllStrikethrough(events, context) {\r\n    let index = -1\r\n\r\n    // Walk through all events.\r\n    while (++index < events.length) {\r\n      // Find a token that can close.\r\n      if (\r\n        events[index][0] === 'enter' &&\r\n        events[index][1].type === 'strikethroughSequenceTemporary' &&\r\n        events[index][1]._close\r\n      ) {\r\n        let open = index\r\n\r\n        // Now walk back to find an opener.\r\n        while (open--) {\r\n          // Find a token that can open the closer.\r\n          if (\r\n            events[open][0] === 'exit' &&\r\n            events[open][1].type === 'strikethroughSequenceTemporary' &&\r\n            events[open][1]._open &&\r\n            // If the sizes are the same:\r\n            events[index][1].end.offset - events[index][1].start.offset ===\r\n              events[open][1].end.offset - events[open][1].start.offset\r\n          ) {\r\n            events[index][1].type = 'strikethroughSequence'\r\n            events[open][1].type = 'strikethroughSequence'\r\n\r\n            /** @type {Token} */\r\n            const strikethrough = {\r\n              type: 'strikethrough',\r\n              start: Object.assign({}, events[open][1].start),\r\n              end: Object.assign({}, events[index][1].end)\r\n            }\r\n\r\n            /** @type {Token} */\r\n            const text = {\r\n              type: 'strikethroughText',\r\n              start: Object.assign({}, events[open][1].end),\r\n              end: Object.assign({}, events[index][1].start)\r\n            }\r\n\r\n            // Opening.\r\n            /** @type {Array<Event>} */\r\n            const nextEvents = [\r\n              ['enter', strikethrough, context],\r\n              ['enter', events[open][1], context],\r\n              ['exit', events[open][1], context],\r\n              ['enter', text, context]\r\n            ]\r\n\r\n            const insideSpan = context.parser.constructs.insideSpan.null\r\n\r\n            if (insideSpan) {\r\n              // Between.\r\n              splice(\r\n                nextEvents,\r\n                nextEvents.length,\r\n                0,\r\n                resolveAll(insideSpan, events.slice(open + 1, index), context)\r\n              )\r\n            }\r\n\r\n            // Closing.\r\n            splice(nextEvents, nextEvents.length, 0, [\r\n              ['exit', text, context],\r\n              ['enter', events[index][1], context],\r\n              ['exit', events[index][1], context],\r\n              ['exit', strikethrough, context]\r\n            ])\r\n\r\n            splice(events, open - 1, index - open + 3, nextEvents)\r\n\r\n            index = open + nextEvents.length - 2\r\n            break\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    index = -1\r\n\r\n    while (++index < events.length) {\r\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\r\n        events[index][1].type = types.data\r\n      }\r\n    }\r\n\r\n    return events\r\n  }\r\n\r\n  /**\r\n   * @this {TokenizeContext}\r\n   * @type {Tokenizer}\r\n   */\r\n  function tokenizeStrikethrough(effects, ok, nok) {\r\n    const previous = this.previous\r\n    const events = this.events\r\n    let size = 0\r\n\r\n    return start\r\n\r\n    /** @type {State} */\r\n    function start(code) {\r\n      assert(code === codes.tilde, 'expected `~`')\r\n\r\n      if (\r\n        previous === codes.tilde &&\r\n        events[events.length - 1][1].type !== types.characterEscape\r\n      ) {\r\n        return nok(code)\r\n      }\r\n\r\n      effects.enter('strikethroughSequenceTemporary')\r\n      return more(code)\r\n    }\r\n\r\n    /** @type {State} */\r\n    function more(code) {\r\n      const before = classifyCharacter(previous)\r\n\r\n      if (code === codes.tilde) {\r\n        // If this is the third marker, exit.\r\n        if (size > 1) return nok(code)\r\n        effects.consume(code)\r\n        size++\r\n        return more\r\n      }\r\n\r\n      if (size < 2 && !single) return nok(code)\r\n      const token = effects.exit('strikethroughSequenceTemporary')\r\n      const after = classifyCharacter(code)\r\n      token._open =\r\n        !after || (after === constants.attentionSideAfter && Boolean(before))\r\n      token._close =\r\n        !before || (before === constants.attentionSideAfter && Boolean(after))\r\n      return ok(code)\r\n    }\r\n  }\r\n}\r\n", "/**\r\n * @import {Event} from 'micromark-util-types'\r\n */\r\n\r\n// Port of `edit_map.rs` from `markdown-rs`.\r\n// This should move to `markdown-js` later.\r\n\r\n// Deal with several changes in events, batching them together.\r\n//\r\n// Preferably, changes should be kept to a minimum.\r\n// Sometimes, it’s needed to change the list of events, because parsing can be\r\n// messy, and it helps to expose a cleaner interface of events to the compiler\r\n// and other users.\r\n// It can also help to merge many adjacent similar events.\r\n// And, in other cases, it’s needed to parse subcontent: pass some events\r\n// through another tokenizer and inject the result.\r\n\r\n/**\r\n * @typedef {[number, number, Array<Event>]} Change\r\n * @typedef {[number, number, number]} Jump\r\n */\r\n\r\n/**\r\n * Tracks a bunch of edits.\r\n */\r\nexport class EditMap {\r\n  /**\r\n   * Create a new edit map.\r\n   */\r\n  constructor() {\r\n    /**\r\n     * Record of changes.\r\n     *\r\n     * @type {Array<Change>}\r\n     */\r\n    this.map = []\r\n  }\r\n\r\n  /**\r\n   * Create an edit: a remove and/or add at a certain place.\r\n   *\r\n   * @param {number} index\r\n   * @param {number} remove\r\n   * @param {Array<Event>} add\r\n   * @returns {undefined}\r\n   */\r\n  add(index, remove, add) {\r\n    addImplementation(this, index, remove, add)\r\n  }\r\n\r\n  // To do: add this when moving to `micromark`.\r\n  // /**\r\n  //  * Create an edit: but insert `add` before existing additions.\r\n  //  *\r\n  //  * @param {number} index\r\n  //  * @param {number} remove\r\n  //  * @param {Array<Event>} add\r\n  //  * @returns {undefined}\r\n  //  */\r\n  // addBefore(index, remove, add) {\r\n  //   addImplementation(this, index, remove, add, true)\r\n  // }\r\n\r\n  /**\r\n   * Done, change the events.\r\n   *\r\n   * @param {Array<Event>} events\r\n   * @returns {undefined}\r\n   */\r\n  consume(events) {\r\n    this.map.sort(function (a, b) {\r\n      return a[0] - b[0]\r\n    })\r\n\r\n    /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */\r\n    if (this.map.length === 0) {\r\n      return\r\n    }\r\n\r\n    // To do: if links are added in events, like they are in `markdown-rs`,\r\n    // this is needed.\r\n    // // Calculate jumps: where items in the current list move to.\r\n    // /** @type {Array<Jump>} */\r\n    // const jumps = []\r\n    // let index = 0\r\n    // let addAcc = 0\r\n    // let removeAcc = 0\r\n    // while (index < this.map.length) {\r\n    //   const [at, remove, add] = this.map[index]\r\n    //   removeAcc += remove\r\n    //   addAcc += add.length\r\n    //   jumps.push([at, removeAcc, addAcc])\r\n    //   index += 1\r\n    // }\r\n    //\r\n    // . shiftLinks(events, jumps)\r\n\r\n    let index = this.map.length\r\n    /** @type {Array<Array<Event>>} */\r\n    const vecs = []\r\n    while (index > 0) {\r\n      index -= 1\r\n      vecs.push(\r\n        events.slice(this.map[index][0] + this.map[index][1]),\r\n        this.map[index][2]\r\n      )\r\n\r\n      // Truncate rest.\r\n      events.length = this.map[index][0]\r\n    }\r\n\r\n    vecs.push([...events])\r\n    events.length = 0\r\n\r\n    let slice = vecs.pop()\r\n\r\n    while (slice) {\r\n      events.push(...slice)\r\n      slice = vecs.pop()\r\n    }\r\n\r\n    // Truncate everything.\r\n    this.map.length = 0\r\n  }\r\n}\r\n\r\n/**\r\n * Create an edit.\r\n *\r\n * @param {EditMap} editMap\r\n * @param {number} at\r\n * @param {number} remove\r\n * @param {Array<Event>} add\r\n * @returns {undefined}\r\n */\r\nfunction addImplementation(editMap, at, remove, add) {\r\n  let index = 0\r\n\r\n  /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */\r\n  if (remove === 0 && add.length === 0) {\r\n    return\r\n  }\r\n\r\n  while (index < editMap.map.length) {\r\n    if (editMap.map[index][0] === at) {\r\n      editMap.map[index][1] += remove\r\n\r\n      // To do: before not used by tables, use when moving to micromark.\r\n      // if (before) {\r\n      //   add.push(...editMap.map[index][2])\r\n      //   editMap.map[index][2] = add\r\n      // } else {\r\n      editMap.map[index][2].push(...add)\r\n      // }\r\n\r\n      return\r\n    }\r\n\r\n    index += 1\r\n  }\r\n\r\n  editMap.map.push([at, remove, add])\r\n}\r\n\r\n// /**\r\n//  * Shift `previous` and `next` links according to `jumps`.\r\n//  *\r\n//  * This fixes links in case there are events removed or added between them.\r\n//  *\r\n//  * @param {Array<Event>} events\r\n//  * @param {Array<Jump>} jumps\r\n//  */\r\n// function shiftLinks(events, jumps) {\r\n//   let jumpIndex = 0\r\n//   let index = 0\r\n//   let add = 0\r\n//   let rm = 0\r\n\r\n//   while (index < events.length) {\r\n//     const rmCurr = rm\r\n\r\n//     while (jumpIndex < jumps.length && jumps[jumpIndex][0] <= index) {\r\n//       add = jumps[jumpIndex][2]\r\n//       rm = jumps[jumpIndex][1]\r\n//       jumpIndex += 1\r\n//     }\r\n\r\n//     // Ignore items that will be removed.\r\n//     if (rm > rmCurr) {\r\n//       index += rm - rmCurr\r\n//     } else {\r\n//       // ?\r\n//       // if let Some(link) = &events[index].link {\r\n//       //     if let Some(next) = link.next {\r\n//       //         events[next].link.as_mut().unwrap().previous = Some(index + add - rm);\r\n//       //         while jumpIndex < jumps.len() && jumps[jumpIndex].0 <= next {\r\n//       //             add = jumps[jumpIndex].2;\r\n//       //             rm = jumps[jumpIndex].1;\r\n//       //             jumpIndex += 1;\r\n//       //         }\r\n//       //         events[index].link.as_mut().unwrap().next = Some(next + add - rm);\r\n//       //         index = next;\r\n//       //         continue;\r\n//       //     }\r\n//       // }\r\n//       index += 1\r\n//     }\r\n//   }\r\n// }\r\n", "/**\r\n * @import {Event} from 'micromark-util-types'\r\n */\r\n\r\n/**\r\n * @typedef {'center' | 'left' | 'none' | 'right'} Align\r\n */\r\n\r\nimport {ok as assert} from 'devlop'\r\n\r\n/**\r\n * Figure out the alignment of a GFM table.\r\n *\r\n * @param {Readonly<Array<Event>>} events\r\n *   List of events.\r\n * @param {number} index\r\n *   Table enter event.\r\n * @returns {Array<Align>}\r\n *   List of aligns.\r\n */\r\nexport function gfmTableAlign(events, index) {\r\n  assert(events[index][1].type === 'table', 'expected table')\r\n  let inDelimiterRow = false\r\n  /** @type {Array<Align>} */\r\n  const align = []\r\n\r\n  while (index < events.length) {\r\n    const event = events[index]\r\n\r\n    if (inDelimiterRow) {\r\n      if (event[0] === 'enter') {\r\n        // Start of alignment value: set a new column.\r\n        // To do: `markdown-rs` uses `tableDelimiterCellValue`.\r\n        if (event[1].type === 'tableContent') {\r\n          align.push(\r\n            events[index + 1][1].type === 'tableDelimiterMarker'\r\n              ? 'left'\r\n              : 'none'\r\n          )\r\n        }\r\n      }\r\n      // Exits:\r\n      // End of alignment value: change the column.\r\n      // To do: `markdown-rs` uses `tableDelimiterCellValue`.\r\n      else if (event[1].type === 'tableContent') {\r\n        if (events[index - 1][1].type === 'tableDelimiterMarker') {\r\n          const alignIndex = align.length - 1\r\n\r\n          align[alignIndex] = align[alignIndex] === 'left' ? 'center' : 'right'\r\n        }\r\n      }\r\n      // Done!\r\n      else if (event[1].type === 'tableDelimiterRow') {\r\n        break\r\n      }\r\n    } else if (event[0] === 'enter' && event[1].type === 'tableDelimiterRow') {\r\n      inDelimiterRow = true\r\n    }\r\n\r\n    index += 1\r\n  }\r\n\r\n  return align\r\n}\r\n", "/**\r\n * @import {Event, Extension, Point, Resolver, State, Token, TokenizeContext, Tokenizer} from 'micromark-util-types'\r\n */\r\n\r\n/**\r\n * @typedef {[number, number, number, number]} Range\r\n *   Cell info.\r\n *\r\n * @typedef {0 | 1 | 2 | 3} RowKind\r\n *   Where we are: `1` for head row, `2` for delimiter row, `3` for body row.\r\n */\r\n\r\nimport {ok as assert} from 'devlop'\r\nimport {factorySpace} from 'micromark-factory-space'\r\nimport {\r\n  markdownLineEnding,\r\n  markdownLineEndingOrSpace,\r\n  markdownSpace\r\n} from 'micromark-util-character'\r\nimport {codes, constants, types} from 'micromark-util-symbol'\r\nimport {EditMap} from './edit-map.js'\r\nimport {gfmTableAlign} from './infer.js'\r\n\r\n/**\r\n * Create an HTML extension for `micromark` to support GitHub tables syntax.\r\n *\r\n * @returns {Extension}\r\n *   Extension for `micromark` that can be passed in `extensions` to enable GFM\r\n *   table syntax.\r\n */\r\nexport function gfmTable() {\r\n  return {\r\n    flow: {\r\n      null: {name: 'table', tokenize: tokenizeTable, resolveAll: resolveTable}\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeTable(effects, ok, nok) {\r\n  const self = this\r\n  let size = 0\r\n  let sizeB = 0\r\n  /** @type {boolean | undefined} */\r\n  let seen\r\n\r\n  return start\r\n\r\n  /**\r\n   * Start of a GFM table.\r\n   *\r\n   * If there is a valid table row or table head before, then we try to parse\r\n   * another row.\r\n   * Otherwise, we try to parse a head.\r\n   *\r\n   * ```markdown\r\n   * > | | a |\r\n   *     ^\r\n   *   | | - |\r\n   * > | | b |\r\n   *     ^\r\n   * ```\r\n   * @type {State}\r\n   */\r\n  function start(code) {\r\n    let index = self.events.length - 1\r\n\r\n    while (index > -1) {\r\n      const type = self.events[index][1].type\r\n      if (\r\n        type === types.lineEnding ||\r\n        // Note: markdown-rs uses `whitespace` instead of `linePrefix`\r\n        type === types.linePrefix\r\n      )\r\n        index--\r\n      else break\r\n    }\r\n\r\n    const tail = index > -1 ? self.events[index][1].type : null\r\n\r\n    const next =\r\n      tail === 'tableHead' || tail === 'tableRow' ? bodyRowStart : headRowBefore\r\n\r\n    // Don’t allow lazy body rows.\r\n    if (next === bodyRowStart && self.parser.lazy[self.now().line]) {\r\n      return nok(code)\r\n    }\r\n\r\n    return next(code)\r\n  }\r\n\r\n  /**\r\n   * Before table head row.\r\n   *\r\n   * ```markdown\r\n   * > | | a |\r\n   *     ^\r\n   *   | | - |\r\n   *   | | b |\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function headRowBefore(code) {\r\n    effects.enter('tableHead')\r\n    effects.enter('tableRow')\r\n    return headRowStart(code)\r\n  }\r\n\r\n  /**\r\n   * Before table head row, after whitespace.\r\n   *\r\n   * ```markdown\r\n   * > | | a |\r\n   *     ^\r\n   *   | | - |\r\n   *   | | b |\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function headRowStart(code) {\r\n    if (code === codes.verticalBar) {\r\n      return headRowBreak(code)\r\n    }\r\n\r\n    // To do: micromark-js should let us parse our own whitespace in extensions,\r\n    // like `markdown-rs`:\r\n    //\r\n    // ```js\r\n    // // 4+ spaces.\r\n    // if (markdownSpace(code)) {\r\n    //   return nok(code)\r\n    // }\r\n    // ```\r\n\r\n    seen = true\r\n    // Count the first character, that isn’t a pipe, double.\r\n    sizeB += 1\r\n    return headRowBreak(code)\r\n  }\r\n\r\n  /**\r\n   * At break in table head row.\r\n   *\r\n   * ```markdown\r\n   * > | | a |\r\n   *     ^\r\n   *       ^\r\n   *         ^\r\n   *   | | - |\r\n   *   | | b |\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function headRowBreak(code) {\r\n    if (code === codes.eof) {\r\n      // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.\r\n      return nok(code)\r\n    }\r\n\r\n    if (markdownLineEnding(code)) {\r\n      // If anything other than one pipe (ignoring whitespace) was used, it’s fine.\r\n      if (sizeB > 1) {\r\n        sizeB = 0\r\n        // To do: check if this works.\r\n        // Feel free to interrupt:\r\n        self.interrupt = true\r\n        effects.exit('tableRow')\r\n        effects.enter(types.lineEnding)\r\n        effects.consume(code)\r\n        effects.exit(types.lineEnding)\r\n        return headDelimiterStart\r\n      }\r\n\r\n      // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.\r\n      return nok(code)\r\n    }\r\n\r\n    if (markdownSpace(code)) {\r\n      // To do: check if this is fine.\r\n      // effects.attempt(State::Next(StateName::GfmTableHeadRowBreak), State::Nok)\r\n      // State::Retry(space_or_tab(tokenizer))\r\n      return factorySpace(effects, headRowBreak, types.whitespace)(code)\r\n    }\r\n\r\n    sizeB += 1\r\n\r\n    if (seen) {\r\n      seen = false\r\n      // Header cell count.\r\n      size += 1\r\n    }\r\n\r\n    if (code === codes.verticalBar) {\r\n      effects.enter('tableCellDivider')\r\n      effects.consume(code)\r\n      effects.exit('tableCellDivider')\r\n      // Whether a delimiter was seen.\r\n      seen = true\r\n      return headRowBreak\r\n    }\r\n\r\n    // Anything else is cell data.\r\n    effects.enter(types.data)\r\n    return headRowData(code)\r\n  }\r\n\r\n  /**\r\n   * In table head row data.\r\n   *\r\n   * ```markdown\r\n   * > | | a |\r\n   *       ^\r\n   *   | | - |\r\n   *   | | b |\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function headRowData(code) {\r\n    if (\r\n      code === codes.eof ||\r\n      code === codes.verticalBar ||\r\n      markdownLineEndingOrSpace(code)\r\n    ) {\r\n      effects.exit(types.data)\r\n      return headRowBreak(code)\r\n    }\r\n\r\n    effects.consume(code)\r\n    return code === codes.backslash ? headRowEscape : headRowData\r\n  }\r\n\r\n  /**\r\n   * In table head row escape.\r\n   *\r\n   * ```markdown\r\n   * > | | a\\-b |\r\n   *         ^\r\n   *   | | ---- |\r\n   *   | | c    |\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function headRowEscape(code) {\r\n    if (code === codes.backslash || code === codes.verticalBar) {\r\n      effects.consume(code)\r\n      return headRowData\r\n    }\r\n\r\n    return headRowData(code)\r\n  }\r\n\r\n  /**\r\n   * Before delimiter row.\r\n   *\r\n   * ```markdown\r\n   *   | | a |\r\n   * > | | - |\r\n   *     ^\r\n   *   | | b |\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function headDelimiterStart(code) {\r\n    // Reset `interrupt`.\r\n    self.interrupt = false\r\n\r\n    // Note: in `markdown-rs`, we need to handle piercing here too.\r\n    if (self.parser.lazy[self.now().line]) {\r\n      return nok(code)\r\n    }\r\n\r\n    effects.enter('tableDelimiterRow')\r\n    // Track if we’ve seen a `:` or `|`.\r\n    seen = false\r\n\r\n    if (markdownSpace(code)) {\r\n      assert(self.parser.constructs.disable.null, 'expected `disabled.null`')\r\n      return factorySpace(\r\n        effects,\r\n        headDelimiterBefore,\r\n        types.linePrefix,\r\n        self.parser.constructs.disable.null.includes('codeIndented')\r\n          ? undefined\r\n          : constants.tabSize\r\n      )(code)\r\n    }\r\n\r\n    return headDelimiterBefore(code)\r\n  }\r\n\r\n  /**\r\n   * Before delimiter row, after optional whitespace.\r\n   *\r\n   * Reused when a `|` is found later, to parse another cell.\r\n   *\r\n   * ```markdown\r\n   *   | | a |\r\n   * > | | - |\r\n   *     ^\r\n   *   | | b |\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function headDelimiterBefore(code) {\r\n    if (code === codes.dash || code === codes.colon) {\r\n      return headDelimiterValueBefore(code)\r\n    }\r\n\r\n    if (code === codes.verticalBar) {\r\n      seen = true\r\n      // If we start with a pipe, we open a cell marker.\r\n      effects.enter('tableCellDivider')\r\n      effects.consume(code)\r\n      effects.exit('tableCellDivider')\r\n      return headDelimiterCellBefore\r\n    }\r\n\r\n    // More whitespace / empty row not allowed at start.\r\n    return headDelimiterNok(code)\r\n  }\r\n\r\n  /**\r\n   * After `|`, before delimiter cell.\r\n   *\r\n   * ```markdown\r\n   *   | | a |\r\n   * > | | - |\r\n   *      ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function headDelimiterCellBefore(code) {\r\n    if (markdownSpace(code)) {\r\n      return factorySpace(\r\n        effects,\r\n        headDelimiterValueBefore,\r\n        types.whitespace\r\n      )(code)\r\n    }\r\n\r\n    return headDelimiterValueBefore(code)\r\n  }\r\n\r\n  /**\r\n   * Before delimiter cell value.\r\n   *\r\n   * ```markdown\r\n   *   | | a |\r\n   * > | | - |\r\n   *       ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function headDelimiterValueBefore(code) {\r\n    // Align: left.\r\n    if (code === codes.colon) {\r\n      sizeB += 1\r\n      seen = true\r\n\r\n      effects.enter('tableDelimiterMarker')\r\n      effects.consume(code)\r\n      effects.exit('tableDelimiterMarker')\r\n      return headDelimiterLeftAlignmentAfter\r\n    }\r\n\r\n    // Align: none.\r\n    if (code === codes.dash) {\r\n      sizeB += 1\r\n      // To do: seems weird that this *isn’t* left aligned, but that state is used?\r\n      return headDelimiterLeftAlignmentAfter(code)\r\n    }\r\n\r\n    if (code === codes.eof || markdownLineEnding(code)) {\r\n      return headDelimiterCellAfter(code)\r\n    }\r\n\r\n    return headDelimiterNok(code)\r\n  }\r\n\r\n  /**\r\n   * After delimiter cell left alignment marker.\r\n   *\r\n   * ```markdown\r\n   *   | | a  |\r\n   * > | | :- |\r\n   *        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function headDelimiterLeftAlignmentAfter(code) {\r\n    if (code === codes.dash) {\r\n      effects.enter('tableDelimiterFiller')\r\n      return headDelimiterFiller(code)\r\n    }\r\n\r\n    // Anything else is not ok after the left-align colon.\r\n    return headDelimiterNok(code)\r\n  }\r\n\r\n  /**\r\n   * In delimiter cell filler.\r\n   *\r\n   * ```markdown\r\n   *   | | a |\r\n   * > | | - |\r\n   *       ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function headDelimiterFiller(code) {\r\n    if (code === codes.dash) {\r\n      effects.consume(code)\r\n      return headDelimiterFiller\r\n    }\r\n\r\n    // Align is `center` if it was `left`, `right` otherwise.\r\n    if (code === codes.colon) {\r\n      seen = true\r\n      effects.exit('tableDelimiterFiller')\r\n      effects.enter('tableDelimiterMarker')\r\n      effects.consume(code)\r\n      effects.exit('tableDelimiterMarker')\r\n      return headDelimiterRightAlignmentAfter\r\n    }\r\n\r\n    effects.exit('tableDelimiterFiller')\r\n    return headDelimiterRightAlignmentAfter(code)\r\n  }\r\n\r\n  /**\r\n   * After delimiter cell right alignment marker.\r\n   *\r\n   * ```markdown\r\n   *   | |  a |\r\n   * > | | -: |\r\n   *         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function headDelimiterRightAlignmentAfter(code) {\r\n    if (markdownSpace(code)) {\r\n      return factorySpace(\r\n        effects,\r\n        headDelimiterCellAfter,\r\n        types.whitespace\r\n      )(code)\r\n    }\r\n\r\n    return headDelimiterCellAfter(code)\r\n  }\r\n\r\n  /**\r\n   * After delimiter cell.\r\n   *\r\n   * ```markdown\r\n   *   | |  a |\r\n   * > | | -: |\r\n   *          ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function headDelimiterCellAfter(code) {\r\n    if (code === codes.verticalBar) {\r\n      return headDelimiterBefore(code)\r\n    }\r\n\r\n    if (code === codes.eof || markdownLineEnding(code)) {\r\n      // Exit when:\r\n      // * there was no `:` or `|` at all (it’s a thematic break or setext\r\n      //   underline instead)\r\n      // * the header cell count is not the delimiter cell count\r\n      if (!seen || size !== sizeB) {\r\n        return headDelimiterNok(code)\r\n      }\r\n\r\n      // Note: in markdown-rs`, a reset is needed here.\r\n      effects.exit('tableDelimiterRow')\r\n      effects.exit('tableHead')\r\n      // To do: in `markdown-rs`, resolvers need to be registered manually.\r\n      // effects.register_resolver(ResolveName::GfmTable)\r\n      return ok(code)\r\n    }\r\n\r\n    return headDelimiterNok(code)\r\n  }\r\n\r\n  /**\r\n   * In delimiter row, at a disallowed byte.\r\n   *\r\n   * ```markdown\r\n   *   | | a |\r\n   * > | | x |\r\n   *       ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function headDelimiterNok(code) {\r\n    // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.\r\n    return nok(code)\r\n  }\r\n\r\n  /**\r\n   * Before table body row.\r\n   *\r\n   * ```markdown\r\n   *   | | a |\r\n   *   | | - |\r\n   * > | | b |\r\n   *     ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function bodyRowStart(code) {\r\n    // Note: in `markdown-rs` we need to manually take care of a prefix,\r\n    // but in `micromark-js` that is done for us, so if we’re here, we’re\r\n    // never at whitespace.\r\n    effects.enter('tableRow')\r\n    return bodyRowBreak(code)\r\n  }\r\n\r\n  /**\r\n   * At break in table body row.\r\n   *\r\n   * ```markdown\r\n   *   | | a |\r\n   *   | | - |\r\n   * > | | b |\r\n   *     ^\r\n   *       ^\r\n   *         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function bodyRowBreak(code) {\r\n    if (code === codes.verticalBar) {\r\n      effects.enter('tableCellDivider')\r\n      effects.consume(code)\r\n      effects.exit('tableCellDivider')\r\n      return bodyRowBreak\r\n    }\r\n\r\n    if (code === codes.eof || markdownLineEnding(code)) {\r\n      effects.exit('tableRow')\r\n      return ok(code)\r\n    }\r\n\r\n    if (markdownSpace(code)) {\r\n      return factorySpace(effects, bodyRowBreak, types.whitespace)(code)\r\n    }\r\n\r\n    // Anything else is cell content.\r\n    effects.enter(types.data)\r\n    return bodyRowData(code)\r\n  }\r\n\r\n  /**\r\n   * In table body row data.\r\n   *\r\n   * ```markdown\r\n   *   | | a |\r\n   *   | | - |\r\n   * > | | b |\r\n   *       ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function bodyRowData(code) {\r\n    if (\r\n      code === codes.eof ||\r\n      code === codes.verticalBar ||\r\n      markdownLineEndingOrSpace(code)\r\n    ) {\r\n      effects.exit(types.data)\r\n      return bodyRowBreak(code)\r\n    }\r\n\r\n    effects.consume(code)\r\n    return code === codes.backslash ? bodyRowEscape : bodyRowData\r\n  }\r\n\r\n  /**\r\n   * In table body row escape.\r\n   *\r\n   * ```markdown\r\n   *   | | a    |\r\n   *   | | ---- |\r\n   * > | | b\\-c |\r\n   *         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function bodyRowEscape(code) {\r\n    if (code === codes.backslash || code === codes.verticalBar) {\r\n      effects.consume(code)\r\n      return bodyRowData\r\n    }\r\n\r\n    return bodyRowData(code)\r\n  }\r\n}\r\n\r\n/** @type {Resolver} */\r\n\r\nfunction resolveTable(events, context) {\r\n  let index = -1\r\n  let inFirstCellAwaitingPipe = true\r\n  /** @type {RowKind} */\r\n  let rowKind = 0\r\n  /** @type {Range} */\r\n  let lastCell = [0, 0, 0, 0]\r\n  /** @type {Range} */\r\n  let cell = [0, 0, 0, 0]\r\n  let afterHeadAwaitingFirstBodyRow = false\r\n  let lastTableEnd = 0\r\n  /** @type {Token | undefined} */\r\n  let currentTable\r\n  /** @type {Token | undefined} */\r\n  let currentBody\r\n  /** @type {Token | undefined} */\r\n  let currentCell\r\n\r\n  const map = new EditMap()\r\n\r\n  while (++index < events.length) {\r\n    const event = events[index]\r\n    const token = event[1]\r\n\r\n    if (event[0] === 'enter') {\r\n      // Start of head.\r\n      if (token.type === 'tableHead') {\r\n        afterHeadAwaitingFirstBodyRow = false\r\n\r\n        // Inject previous (body end and) table end.\r\n        if (lastTableEnd !== 0) {\r\n          assert(currentTable, 'there should be a table opening')\r\n          flushTableEnd(map, context, lastTableEnd, currentTable, currentBody)\r\n          currentBody = undefined\r\n          lastTableEnd = 0\r\n        }\r\n\r\n        // Inject table start.\r\n        currentTable = {\r\n          type: 'table',\r\n          start: Object.assign({}, token.start),\r\n          // Note: correct end is set later.\r\n          end: Object.assign({}, token.end)\r\n        }\r\n        map.add(index, 0, [['enter', currentTable, context]])\r\n      } else if (\r\n        token.type === 'tableRow' ||\r\n        token.type === 'tableDelimiterRow'\r\n      ) {\r\n        inFirstCellAwaitingPipe = true\r\n        currentCell = undefined\r\n        lastCell = [0, 0, 0, 0]\r\n        cell = [0, index + 1, 0, 0]\r\n\r\n        // Inject table body start.\r\n        if (afterHeadAwaitingFirstBodyRow) {\r\n          afterHeadAwaitingFirstBodyRow = false\r\n          currentBody = {\r\n            type: 'tableBody',\r\n            start: Object.assign({}, token.start),\r\n            // Note: correct end is set later.\r\n            end: Object.assign({}, token.end)\r\n          }\r\n          map.add(index, 0, [['enter', currentBody, context]])\r\n        }\r\n\r\n        rowKind = token.type === 'tableDelimiterRow' ? 2 : currentBody ? 3 : 1\r\n      }\r\n      // Cell data.\r\n      else if (\r\n        rowKind &&\r\n        (token.type === types.data ||\r\n          token.type === 'tableDelimiterMarker' ||\r\n          token.type === 'tableDelimiterFiller')\r\n      ) {\r\n        inFirstCellAwaitingPipe = false\r\n\r\n        // First value in cell.\r\n        if (cell[2] === 0) {\r\n          if (lastCell[1] !== 0) {\r\n            cell[0] = cell[1]\r\n            currentCell = flushCell(\r\n              map,\r\n              context,\r\n              lastCell,\r\n              rowKind,\r\n              undefined,\r\n              currentCell\r\n            )\r\n            lastCell = [0, 0, 0, 0]\r\n          }\r\n\r\n          cell[2] = index\r\n        }\r\n      } else if (token.type === 'tableCellDivider') {\r\n        if (inFirstCellAwaitingPipe) {\r\n          inFirstCellAwaitingPipe = false\r\n        } else {\r\n          if (lastCell[1] !== 0) {\r\n            cell[0] = cell[1]\r\n            currentCell = flushCell(\r\n              map,\r\n              context,\r\n              lastCell,\r\n              rowKind,\r\n              undefined,\r\n              currentCell\r\n            )\r\n          }\r\n\r\n          lastCell = cell\r\n          cell = [lastCell[1], index, 0, 0]\r\n        }\r\n      }\r\n    }\r\n    // Exit events.\r\n    else if (token.type === 'tableHead') {\r\n      afterHeadAwaitingFirstBodyRow = true\r\n      lastTableEnd = index\r\n    } else if (\r\n      token.type === 'tableRow' ||\r\n      token.type === 'tableDelimiterRow'\r\n    ) {\r\n      lastTableEnd = index\r\n\r\n      if (lastCell[1] !== 0) {\r\n        cell[0] = cell[1]\r\n        currentCell = flushCell(\r\n          map,\r\n          context,\r\n          lastCell,\r\n          rowKind,\r\n          index,\r\n          currentCell\r\n        )\r\n      } else if (cell[1] !== 0) {\r\n        currentCell = flushCell(map, context, cell, rowKind, index, currentCell)\r\n      }\r\n\r\n      rowKind = 0\r\n    } else if (\r\n      rowKind &&\r\n      (token.type === types.data ||\r\n        token.type === 'tableDelimiterMarker' ||\r\n        token.type === 'tableDelimiterFiller')\r\n    ) {\r\n      cell[3] = index\r\n    }\r\n  }\r\n\r\n  if (lastTableEnd !== 0) {\r\n    assert(currentTable, 'expected table opening')\r\n    flushTableEnd(map, context, lastTableEnd, currentTable, currentBody)\r\n  }\r\n\r\n  map.consume(context.events)\r\n\r\n  // To do: move this into `html`, when events are exposed there.\r\n  // That’s what `markdown-rs` does.\r\n  // That needs updates to `mdast-util-gfm-table`.\r\n  index = -1\r\n  while (++index < context.events.length) {\r\n    const event = context.events[index]\r\n    if (event[0] === 'enter' && event[1].type === 'table') {\r\n      event[1]._align = gfmTableAlign(context.events, index)\r\n    }\r\n  }\r\n\r\n  return events\r\n}\r\n\r\n/**\r\n * Generate a cell.\r\n *\r\n * @param {EditMap} map\r\n * @param {Readonly<TokenizeContext>} context\r\n * @param {Readonly<Range>} range\r\n * @param {RowKind} rowKind\r\n * @param {number | undefined} rowEnd\r\n * @param {Token | undefined} previousCell\r\n * @returns {Token | undefined}\r\n */\r\n// eslint-disable-next-line max-params\r\nfunction flushCell(map, context, range, rowKind, rowEnd, previousCell) {\r\n  // `markdown-rs` uses:\r\n  // rowKind === 2 ? 'tableDelimiterCell' : 'tableCell'\r\n  const groupName =\r\n    rowKind === 1\r\n      ? 'tableHeader'\r\n      : rowKind === 2\r\n        ? 'tableDelimiter'\r\n        : 'tableData'\r\n  // `markdown-rs` uses:\r\n  // rowKind === 2 ? 'tableDelimiterCellValue' : 'tableCellText'\r\n  const valueName = 'tableContent'\r\n\r\n  // Insert an exit for the previous cell, if there is one.\r\n  //\r\n  // ```markdown\r\n  // > | | aa | bb | cc |\r\n  //          ^-- exit\r\n  //           ^^^^-- this cell\r\n  // ```\r\n  if (range[0] !== 0) {\r\n    assert(previousCell, 'expected previous cell enter')\r\n    previousCell.end = Object.assign({}, getPoint(context.events, range[0]))\r\n    map.add(range[0], 0, [['exit', previousCell, context]])\r\n  }\r\n\r\n  // Insert enter of this cell.\r\n  //\r\n  // ```markdown\r\n  // > | | aa | bb | cc |\r\n  //           ^-- enter\r\n  //           ^^^^-- this cell\r\n  // ```\r\n  const now = getPoint(context.events, range[1])\r\n  previousCell = {\r\n    type: groupName,\r\n    start: Object.assign({}, now),\r\n    // Note: correct end is set later.\r\n    end: Object.assign({}, now)\r\n  }\r\n  map.add(range[1], 0, [['enter', previousCell, context]])\r\n\r\n  // Insert text start at first data start and end at last data end, and\r\n  // remove events between.\r\n  //\r\n  // ```markdown\r\n  // > | | aa | bb | cc |\r\n  //            ^-- enter\r\n  //             ^-- exit\r\n  //           ^^^^-- this cell\r\n  // ```\r\n  if (range[2] !== 0) {\r\n    const relatedStart = getPoint(context.events, range[2])\r\n    const relatedEnd = getPoint(context.events, range[3])\r\n    /** @type {Token} */\r\n    const valueToken = {\r\n      type: valueName,\r\n      start: Object.assign({}, relatedStart),\r\n      end: Object.assign({}, relatedEnd)\r\n    }\r\n    map.add(range[2], 0, [['enter', valueToken, context]])\r\n    assert(range[3] !== 0)\r\n\r\n    if (rowKind !== 2) {\r\n      // Fix positional info on remaining events\r\n      const start = context.events[range[2]]\r\n      const end = context.events[range[3]]\r\n      start[1].end = Object.assign({}, end[1].end)\r\n      start[1].type = types.chunkText\r\n      start[1].contentType = constants.contentTypeText\r\n\r\n      // Remove if needed.\r\n      if (range[3] > range[2] + 1) {\r\n        const a = range[2] + 1\r\n        const b = range[3] - range[2] - 1\r\n        map.add(a, b, [])\r\n      }\r\n    }\r\n\r\n    map.add(range[3] + 1, 0, [['exit', valueToken, context]])\r\n  }\r\n\r\n  // Insert an exit for the last cell, if at the row end.\r\n  //\r\n  // ```markdown\r\n  // > | | aa | bb | cc |\r\n  //                    ^-- exit\r\n  //               ^^^^^^-- this cell (the last one contains two “between” parts)\r\n  // ```\r\n  if (rowEnd !== undefined) {\r\n    previousCell.end = Object.assign({}, getPoint(context.events, rowEnd))\r\n    map.add(rowEnd, 0, [['exit', previousCell, context]])\r\n    previousCell = undefined\r\n  }\r\n\r\n  return previousCell\r\n}\r\n\r\n/**\r\n * Generate table end (and table body end).\r\n *\r\n * @param {Readonly<EditMap>} map\r\n * @param {Readonly<TokenizeContext>} context\r\n * @param {number} index\r\n * @param {Token} table\r\n * @param {Token | undefined} tableBody\r\n */\r\n// eslint-disable-next-line max-params\r\nfunction flushTableEnd(map, context, index, table, tableBody) {\r\n  /** @type {Array<Event>} */\r\n  const exits = []\r\n  const related = getPoint(context.events, index)\r\n\r\n  if (tableBody) {\r\n    tableBody.end = Object.assign({}, related)\r\n    exits.push(['exit', tableBody, context])\r\n  }\r\n\r\n  table.end = Object.assign({}, related)\r\n  exits.push(['exit', table, context])\r\n\r\n  map.add(index + 1, 0, exits)\r\n}\r\n\r\n/**\r\n * @param {Readonly<Array<Event>>} events\r\n * @param {number} index\r\n * @returns {Readonly<Point>}\r\n */\r\nfunction getPoint(events, index) {\r\n  const event = events[index]\r\n  const side = event[0] === 'enter' ? 'start' : 'end'\r\n  return event[1][side]\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').CompileContext} CompileContext\r\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\r\n * @typedef {import('micromark-util-types').Token} Token\r\n */\r\n\r\n// An opening or closing tag start, followed by a case-insensitive specific tag name,\r\n// followed by HTML whitespace, a greater than, or a slash.\r\nconst reFlow =\r\n  /<(\\/?)(iframe|noembed|noframes|plaintext|script|style|title|textarea|xmp)(?=[\\t\\n\\f\\r />])/gi\r\n\r\n// As HTML (text) parses tags separately (and very strictly), we don’t need to be\r\n// global.\r\nconst reText = new RegExp('^' + reFlow.source, 'i')\r\n\r\n/**\r\n * Create an HTML extension for `micromark` to support GitHubs weird and\r\n * useless tagfilter when serializing to HTML.\r\n *\r\n * @returns {HtmlExtension}\r\n *   Extension for `micromark` that can be passed in `htmlExtensions` to support\r\n *   GitHubs weird and useless tagfilter when serializing to HTML.\r\n */\r\nexport function gfmTagfilterHtml() {\r\n  return {\r\n    exit: {\r\n      htmlFlowData(token) {\r\n        exitHtmlData.call(this, token, reFlow)\r\n      },\r\n      htmlTextData(token) {\r\n        exitHtmlData.call(this, token, reText)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @this {CompileContext}\r\n * @param {Token} token\r\n * @param {RegExp} filter\r\n * @returns {undefined}\r\n */\r\nfunction exitHtmlData(token, filter) {\r\n  let value = this.sliceSerialize(token)\r\n\r\n  if (this.options.allowDangerousHtml) {\r\n    value = value.replace(filter, '&lt;$1$2')\r\n  }\r\n\r\n  this.raw(this.encode(value))\r\n}\r\n", "/**\r\n * @import {Extension, State, TokenizeContext, Tokenizer} from 'micromark-util-types'\r\n */\r\n\r\nimport {ok as assert} from 'devlop'\r\nimport {factorySpace} from 'micromark-factory-space'\r\nimport {\r\n  markdownLineEnding,\r\n  markdownLineEndingOrSpace,\r\n  markdownSpace\r\n} from 'micromark-util-character'\r\nimport {codes, types} from 'micromark-util-symbol'\r\n\r\nconst tasklistCheck = {name: 'tasklistCheck', tokenize: tokenizeTasklistCheck}\r\n\r\n/**\r\n * Create an HTML extension for `micromark` to support GFM task list items\r\n * syntax.\r\n *\r\n * @returns {Extension}\r\n *   Extension for `micromark` that can be passed in `htmlExtensions` to\r\n *   support GFM task list items when serializing to HTML.\r\n */\r\nexport function gfmTaskListItem() {\r\n  return {\r\n    text: {[codes.leftSquareBracket]: tasklistCheck}\r\n  }\r\n}\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeTasklistCheck(effects, ok, nok) {\r\n  const self = this\r\n\r\n  return open\r\n\r\n  /**\r\n   * At start of task list item check.\r\n   *\r\n   * ```markdown\r\n   * > | * [x] y.\r\n   *       ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function open(code) {\r\n    assert(code === codes.leftSquareBracket, 'expected `[`')\r\n\r\n    if (\r\n      // Exit if there’s stuff before.\r\n      self.previous !== codes.eof ||\r\n      // Exit if not in the first content that is the first child of a list\r\n      // item.\r\n      !self._gfmTasklistFirstContentOfListItem\r\n    ) {\r\n      return nok(code)\r\n    }\r\n\r\n    effects.enter('taskListCheck')\r\n    effects.enter('taskListCheckMarker')\r\n    effects.consume(code)\r\n    effects.exit('taskListCheckMarker')\r\n    return inside\r\n  }\r\n\r\n  /**\r\n   * In task list item check.\r\n   *\r\n   * ```markdown\r\n   * > | * [x] y.\r\n   *        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function inside(code) {\r\n    // Currently we match how GH works in files.\r\n    // To match how GH works in comments, use `markdownSpace` (`[\\t ]`) instead\r\n    // of `markdownLineEndingOrSpace` (`[\\t\\n\\r ]`).\r\n    if (markdownLineEndingOrSpace(code)) {\r\n      effects.enter('taskListCheckValueUnchecked')\r\n      effects.consume(code)\r\n      effects.exit('taskListCheckValueUnchecked')\r\n      return close\r\n    }\r\n\r\n    if (code === codes.uppercaseX || code === codes.lowercaseX) {\r\n      effects.enter('taskListCheckValueChecked')\r\n      effects.consume(code)\r\n      effects.exit('taskListCheckValueChecked')\r\n      return close\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /**\r\n   * At close of task list item check.\r\n   *\r\n   * ```markdown\r\n   * > | * [x] y.\r\n   *         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function close(code) {\r\n    if (code === codes.rightSquareBracket) {\r\n      effects.enter('taskListCheckMarker')\r\n      effects.consume(code)\r\n      effects.exit('taskListCheckMarker')\r\n      effects.exit('taskListCheck')\r\n      return after\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /**\r\n   * @type {State}\r\n   */\r\n  function after(code) {\r\n    // EOL in paragraph means there must be something else after it.\r\n    if (markdownLineEnding(code)) {\r\n      return ok(code)\r\n    }\r\n\r\n    // Space or tab?\r\n    // Check what comes after.\r\n    if (markdownSpace(code)) {\r\n      return effects.check({tokenize: spaceThenNonSpace}, ok, nok)(code)\r\n    }\r\n\r\n    // EOF, or non-whitespace, both wrong.\r\n    return nok(code)\r\n  }\r\n}\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction spaceThenNonSpace(effects, ok, nok) {\r\n  return factorySpace(effects, after, types.whitespace)\r\n\r\n  /**\r\n   * After whitespace, after task list item check.\r\n   *\r\n   * ```markdown\r\n   * > | * [x] y.\r\n   *           ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function after(code) {\r\n    // EOF means there was nothing, so bad.\r\n    // EOL means there’s content after it, so good.\r\n    // Impossible to have more spaces.\r\n    // Anything else is good.\r\n    return code === codes.eof ? nok(code) : ok(code)\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('micromark-extension-gfm-footnote').HtmlOptions} HtmlOptions\r\n * @typedef {import('micromark-extension-gfm-strikethrough').Options} Options\r\n * @typedef {import('micromark-util-types').Extension} Extension\r\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\r\n */\r\n\r\nimport {\r\n  combineExtensions,\r\n  combineHtmlExtensions\r\n} from 'micromark-util-combine-extensions'\r\nimport {\r\n  gfmAutolinkLiteral,\r\n  gfmAutolinkLiteralHtml\r\n} from 'micromark-extension-gfm-autolink-literal'\r\nimport {gfmFootnote, gfmFootnoteHtml} from 'micromark-extension-gfm-footnote'\r\nimport {\r\n  gfmStrikethrough,\r\n  gfmStrikethroughHtml\r\n} from 'micromark-extension-gfm-strikethrough'\r\nimport {gfmTable, gfmTableHtml} from 'micromark-extension-gfm-table'\r\nimport {gfmTagfilterHtml} from 'micromark-extension-gfm-tagfilter'\r\nimport {\r\n  gfmTaskListItem,\r\n  gfmTaskListItemHtml\r\n} from 'micromark-extension-gfm-task-list-item'\r\n\r\n/**\r\n * Create an extension for `micromark` to enable GFM syntax.\r\n *\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration (optional).\r\n *\r\n *   Passed to `micromark-extens-gfm-strikethrough`.\r\n * @returns {Extension}\r\n *   Extension for `micromark` that can be passed in `extensions` to enable GFM\r\n *   syntax.\r\n */\r\nexport function gfm(options) {\r\n  return combineExtensions([\r\n    gfmAutolinkLiteral(),\r\n    gfmFootnote(),\r\n    gfmStrikethrough(options),\r\n    gfmTable(),\r\n    gfmTaskListItem()\r\n  ])\r\n}\r\n\r\n/**\r\n * Create an extension for `micromark` to support GFM when serializing to HTML.\r\n *\r\n * @param {HtmlOptions | null | undefined} [options]\r\n *   Configuration (optional).\r\n *\r\n *   Passed to `micromark-extens-gfm-footnote`.\r\n * @returns {HtmlExtension}\r\n *   Extension for `micromark` that can be passed in `htmlExtensions` to\r\n *   support GFM when serializing to HTML.\r\n */\r\nexport function gfmHtml(options) {\r\n  return combineHtmlExtensions([\r\n    gfmAutolinkLiteralHtml(),\r\n    gfmFootnoteHtml(options),\r\n    gfmStrikethroughHtml(),\r\n    gfmTableHtml(),\r\n    gfmTagfilterHtml(),\r\n    gfmTaskListItemHtml()\r\n  ])\r\n}\r\n", "/// <reference types=\"remark-parse\" />\r\n/// <reference types=\"remark-stringify\" />\r\n\r\n/**\r\n * @typedef {import('mdast').Root} Root\r\n * @typedef {import('mdast-util-gfm').Options} MdastOptions\r\n * @typedef {import('micromark-extension-gfm').Options} MicromarkOptions\r\n * @typedef {import('unified').Processor<Root>} Processor\r\n */\r\n\r\n/**\r\n * @typedef {MicromarkOptions & MdastOptions} Options\r\n *   Configuration.\r\n */\r\n\r\nimport {gfmFromMarkdown, gfmToMarkdown} from 'mdast-util-gfm'\r\nimport {gfm} from 'micromark-extension-gfm'\r\n\r\n/** @type {Options} */\r\nconst emptyOptions = {}\r\n\r\n/**\r\n * Add support GFM (autolink literals, footnotes, strikethrough, tables,\r\n * tasklists).\r\n *\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration (optional).\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nexport default function remarkGfm(options) {\r\n  // @ts-expect-error: TS is wrong about `this`.\r\n  // eslint-disable-next-line unicorn/no-this-assignment\r\n  const self = /** @type {Processor} */ (this)\r\n  const settings = options || emptyOptions\r\n  const data = self.data()\r\n\r\n  const micromarkExtensions =\r\n    data.micromarkExtensions || (data.micromarkExtensions = [])\r\n  const fromMarkdownExtensions =\r\n    data.fromMarkdownExtensions || (data.fromMarkdownExtensions = [])\r\n  const toMarkdownExtensions =\r\n    data.toMarkdownExtensions || (data.toMarkdownExtensions = [])\r\n\r\n  micromarkExtensions.push(gfm(settings))\r\n  fromMarkdownExtensions.push(gfmFromMarkdown())\r\n  toMarkdownExtensions.push(gfmToMarkdown(settings))\r\n}\r\n", "import type { Meta, MilkdownPlugin } from '@milkdown/ctx'\n\nexport function withMeta<T extends MilkdownPlugin>(plugin: T, meta: Partial<Meta> & Pick<Meta, 'displayName'>): T {\n  Object.assign(plugin, {\n    meta: {\n      package: '@milkdown/preset-gfm',\n      ...meta,\n    },\n  })\n\n  return plugin\n}\n", "import { commandsCtx } from '@milkdown/core'\nimport { $command, $inputRule, $markAttr, $markSchema, $useKeymap } from '@milkdown/utils'\nimport { toggleMark } from '@milkdown/prose/commands'\nimport { markRule } from '@milkdown/prose'\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for the strikethrough mark.\nexport const strikethroughAttr = $markAttr('strike_through')\n\nwithMeta(strikethroughAttr, {\n  displayName: 'Attr<strikethrough>',\n  group: 'Strikethrough',\n})\n\n/// Strikethrough mark schema.\nexport const strikethroughSchema = $markSchema('strike_through', ctx => ({\n  parseDOM: [\n    { tag: 'del' },\n    { style: 'text-decoration', getAttrs: value => (value === 'line-through') as false },\n  ],\n  toDOM: mark => ['del', ctx.get(strikethroughAttr.key)(mark)],\n  parseMarkdown: {\n    match: node => node.type === 'delete',\n    runner: (state, node, markType) => {\n      state.openMark(markType)\n      state.next(node.children)\n      state.closeMark(markType)\n    },\n  },\n  toMarkdown: {\n    match: mark => mark.type.name === 'strike_through',\n    runner: (state, mark) => {\n      state.withMark(mark, 'delete')\n    },\n  },\n}))\n\nwithMeta(strikethroughSchema.mark, {\n  displayName: 'MarkSchema<strikethrough>',\n  group: 'Strikethrough',\n})\n\nwithMeta(strikethroughSchema.ctx, {\n  displayName: 'MarkSchemaCtx<strikethrough>',\n  group: 'Strikethrough',\n})\n\n/// A command to toggle the strikethrough mark.\nexport const toggleStrikethroughCommand = $command('ToggleStrikeThrough', ctx => () => {\n  return toggleMark(strikethroughSchema.type(ctx))\n})\n\nwithMeta(toggleStrikethroughCommand, {\n  displayName: 'Command<ToggleStrikethrough>',\n  group: 'Strikethrough',\n})\n\n/// Input rule to create the strikethrough mark.\nexport const strikethroughInputRule = $inputRule((ctx) => {\n  return markRule(/~([^~]+)~$/, strikethroughSchema.type(ctx))\n})\n\nwithMeta(strikethroughInputRule, {\n  displayName: 'InputRule<strikethrough>',\n  group: 'Strikethrough',\n})\n\n/// Keymap for the strikethrough mark.\n/// - `Mod-Alt-x` - Toggle the strikethrough mark.\nexport const strikethroughKeymap = $useKeymap('strikeThroughKeymap', {\n  ToggleStrikethrough: {\n    shortcuts: 'Mod-Alt-x',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(toggleStrikethroughCommand.key)\n    },\n  },\n})\n\nwithMeta(strikethroughKeymap.ctx, {\n  displayName: 'KeymapCtx<strikethrough>',\n  group: 'Strikethrough',\n})\n\nwithMeta(strikethroughKeymap.shortcuts, {\n  displayName: 'Keymap<strikethrough>',\n  group: 'Strikethrough',\n})\n", "import { tableNodes } from '@milkdown/prose/tables'\nimport { $nodeSchema } from '@milkdown/utils'\nimport type { MarkdownNode } from '@milkdown/transformer'\nimport type { NodeType } from '@milkdown/prose/model'\nimport { withMeta } from '../../__internal__'\n\nconst originalSchema = tableNodes({\n  tableGroup: 'block',\n  cellContent: 'paragraph',\n  cellAttributes: {\n    alignment: {\n      default: 'left',\n      getFromDOM: dom => (dom).style.textAlign || 'left',\n      setDOMAttr: (value, attrs) => {\n        attrs.style = `text-align: ${value || 'left'}`\n      },\n    },\n  },\n})\n\n/// Schema for table node.\nexport const tableSchema = $nodeSchema('table', () => ({\n  ...originalSchema.table,\n  content: 'table_header_row table_row+',\n  disableDropCursor: true,\n  parseMarkdown: {\n    match: node => node.type === 'table',\n    runner: (state, node, type) => {\n      const align = node.align as (string | null)[]\n      const children = (node.children as MarkdownNode[]).map((x, i) => ({\n        ...x,\n        align,\n        isHeader: i === 0,\n      }))\n      state.openNode(type)\n      state.next(children)\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === 'table',\n    runner: (state, node) => {\n      const firstLine = node.content.firstChild?.content\n      if (!firstLine)\n        return\n\n      const align: (string | null)[] = []\n      firstLine.forEach((cell) => {\n        align.push(cell.attrs.alignment)\n      })\n      state.openNode('table', undefined, { align })\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableSchema.node, {\n  displayName: 'NodeSchema<table>',\n  group: 'Table',\n})\n\nwithMeta(tableSchema.ctx, {\n  displayName: 'NodeSchemaCtx<table>',\n  group: 'Table',\n})\n\n/// Schema for table header row node.\nexport const tableHeaderRowSchema = $nodeSchema('table_header_row', () => ({\n  ...originalSchema.table_row,\n  disableDropCursor: true,\n  content: '(table_header)*',\n  parseDOM: [{ tag: 'tr[data-is-header]' }],\n  toDOM() {\n    return ['tr', { 'data-is-header': true }, 0]\n  },\n  parseMarkdown: {\n    match: node => Boolean(node.type === 'tableRow' && node.isHeader),\n    runner: (state, node, type) => {\n      const align = node.align as (string | null)[]\n      const children = (node.children as MarkdownNode[]).map((x, i) => ({\n        ...x,\n        align: align[i],\n        isHeader: node.isHeader,\n      }))\n      state.openNode(type)\n      state.next(children)\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === 'table_header_row',\n    runner: (state, node) => {\n      state.openNode('tableRow', undefined, { isHeader: true })\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableHeaderRowSchema.node, {\n  displayName: 'NodeSchema<tableHeaderRow>',\n  group: 'Table',\n})\n\nwithMeta(tableHeaderRowSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableHeaderRow>',\n  group: 'Table',\n})\n\n/// Schema for table row node.\nexport const tableRowSchema = $nodeSchema('table_row', () => ({\n  ...originalSchema.table_row,\n  disableDropCursor: true,\n  content: '(table_cell)*',\n  parseMarkdown: {\n    match: node => node.type === 'tableRow',\n    runner: (state, node, type) => {\n      const align = node.align as (string | null)[]\n      const children = (node.children as MarkdownNode[]).map((x, i) => ({\n        ...x,\n        align: align[i],\n      }))\n      state.openNode(type)\n      state.next(children)\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === 'table_row',\n    runner: (state, node) => {\n      state.openNode('tableRow')\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableRowSchema.node, {\n  displayName: 'NodeSchema<tableRow>',\n  group: 'Table',\n})\n\nwithMeta(tableRowSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableRow>',\n  group: 'Table',\n})\n\n/// Schema for table cell node.\nexport const tableCellSchema = $nodeSchema('table_cell', () => ({\n  ...originalSchema.table_cell,\n  disableDropCursor: true,\n  parseMarkdown: {\n    match: node => node.type === 'tableCell' && !node.isHeader,\n    runner: (state, node, type) => {\n      const align = node.align as string\n      state\n        .openNode(type, { alignment: align })\n        .openNode(state.schema.nodes.paragraph as NodeType)\n        .next(node.children)\n        .closeNode()\n        .closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === 'table_cell',\n    runner: (state, node) => {\n      state.openNode('tableCell').next(node.content).closeNode()\n    },\n  },\n}))\n\nwithMeta(tableCellSchema.node, {\n  displayName: 'NodeSchema<tableCell>',\n  group: 'Table',\n})\n\nwithMeta(tableCellSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableCell>',\n  group: 'Table',\n})\n\n/// Schema for table header node.\nexport const tableHeaderSchema = $nodeSchema('table_header', () => ({\n  ...originalSchema.table_header,\n  disableDropCursor: true,\n  parseMarkdown: {\n    match: node => node.type === 'tableCell' && !!node.isHeader,\n    runner: (state, node, type) => {\n      const align = node.align as string\n      state.openNode(type, { alignment: align })\n      state.openNode(state.schema.nodes.paragraph as NodeType)\n      state.next(node.children)\n      state.closeNode()\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === 'table_header',\n    runner: (state, node) => {\n      state.openNode('tableCell')\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableHeaderSchema.node, {\n  displayName: 'NodeSchema<tableHeader>',\n  group: 'Table',\n})\n\nwithMeta(tableHeaderSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableHeader>',\n  group: 'Table',\n})\n", "import type { ContentNodeWithPos } from '@milkdown/prose'\nimport { cloneTr, findParentNodeClosestToPos } from '@milkdown/prose'\nimport type { Node, ResolvedPos } from '@milkdown/prose/model'\nimport type { Selection, Transaction } from '@milkdown/prose/state'\nimport type { TableRect } from '@milkdown/prose/tables'\nimport { CellSelection, TableMap } from '@milkdown/prose/tables'\n\nimport type { Ctx } from '@milkdown/ctx'\nimport { tableCellSchema, tableHeaderRowSchema, tableHeaderSchema, tableRowSchema, tableSchema } from './schema'\n\n/// @internal\nexport interface CellPos {\n  pos: number\n  start: number\n  node: Node\n}\n\n/// @internal\nexport function createTable(ctx: Ctx, rowsCount = 3, colsCount = 3): Node {\n  const cells = Array(colsCount)\n    .fill(0)\n    .map(() => tableCellSchema.type(ctx).createAndFill()!)\n\n  const headerCells = Array(colsCount)\n    .fill(0)\n    .map(() => tableHeaderSchema.type(ctx).createAndFill()!)\n\n  const rows = Array(rowsCount)\n    .fill(0)\n    .map((_, i) => i === 0\n      ? tableHeaderRowSchema.type(ctx).create(null, headerCells)\n      : tableRowSchema.type(ctx).create(null, cells))\n\n  return tableSchema.type(ctx).create(null, rows)\n}\n\n/// Find the table node with position information for target pos.\nexport function findTable($pos: ResolvedPos) {\n  return findParentNodeClosestToPos(node => node.type.spec.tableRole === 'table')($pos)\n}\n\n/// Get cells in a column of a table.\nexport function getCellsInCol(columnIndex: number, selection: Selection): CellPos[] | undefined {\n  const table = findTable(selection.$from)\n  if (!table)\n    return undefined\n  const map = TableMap.get(table.node)\n  if (columnIndex < 0 || columnIndex >= map.width)\n    return undefined\n\n  return map\n    .cellsInRect({ left: columnIndex, right: columnIndex + 1, top: 0, bottom: map.height })\n    .map((pos) => {\n      const node = table.node.nodeAt(pos)\n      if (!node)\n        return undefined\n      const start = pos + table.start\n      return {\n        pos: start,\n        start: start + 1,\n        node,\n      }\n    })\n    .filter((x): x is CellPos => x != null)\n}\n\n/// Get cells in a row of a table.\nexport function getCellsInRow(rowIndex: number, selection: Selection): CellPos[] | undefined {\n  const table = findTable(selection.$from)\n  if (!table)\n    return undefined\n  const map = TableMap.get(table.node)\n  if (rowIndex < 0 || rowIndex >= map.height)\n    return undefined\n\n  return map\n    .cellsInRect({ left: 0, right: map.width, top: rowIndex, bottom: rowIndex + 1 })\n    .map((pos) => {\n      const node = table.node.nodeAt(pos)\n      if (!node)\n        return undefined\n      const start = pos + table.start\n      return {\n        pos: start,\n        start: start + 1,\n        node,\n      }\n    })\n    .filter((x): x is CellPos => x != null)\n}\n\n/// Get all cells in a table.\nexport function getAllCellsInTable(selection: Selection) {\n  const table = findTable(selection.$from)\n  if (!table)\n    return\n\n  const map = TableMap.get(table.node)\n  const cells = map.cellsInRect({\n    left: 0,\n    right: map.width,\n    top: 0,\n    bottom: map.height,\n  })\n  return cells.map((nodePos) => {\n    const node = table.node.nodeAt(nodePos)\n    const pos = nodePos + table.start\n    return { pos, start: pos + 1, node }\n  })\n}\n\n/// Select a possible table in current selection.\nexport function selectTable(tr: Transaction) {\n  const cells = getAllCellsInTable(tr.selection)\n  if (cells && cells[0]) {\n    const $firstCell = tr.doc.resolve(cells[0].pos)\n    const last = cells[cells.length - 1]\n    if (last) {\n      const $lastCell = tr.doc.resolve(last.pos)\n      return cloneTr(tr.setSelection(new CellSelection($lastCell, $firstCell)))\n    }\n  }\n  return tr\n}\n\n/// @internal\nexport function addRowWithAlignment(ctx: Ctx, tr: Transaction, { map, tableStart, table }: TableRect, row: number) {\n  const rowPos = Array(row)\n    .fill(0)\n    .reduce((acc, _, i) => {\n      return acc + table.child(i).nodeSize\n    }, tableStart)\n\n  const cells = Array(map.width)\n    .fill(0)\n    .map((_, col) => {\n      const headerCol = table.nodeAt(map.map[col] as number)\n      return tableCellSchema.type(ctx).createAndFill({ alignment: headerCol?.attrs.alignment }) as Node\n    })\n\n  tr.insert(rowPos, tableRowSchema.type(ctx).create(null, cells))\n  return tr\n}\n\n/// @internal\nexport function selectLine(type: 'row' | 'col') {\n  return (index: number, pos?: number) => (tr: Transaction) => {\n    pos = pos ?? tr.selection.from\n    const $pos = tr.doc.resolve(pos)\n    const $node = findParentNodeClosestToPos(node => node.type.name === 'table')($pos)\n    const table = $node\n      ? {\n          node: $node.node,\n          from: $node.start,\n        }\n      : undefined\n\n    const isRowSelection = type === 'row'\n    if (table) {\n      const map = TableMap.get(table.node)\n\n      // Check if the index is valid\n      if (index >= 0 && index < (isRowSelection ? map.height : map.width)) {\n        const lastCell = map.positionAt(\n          isRowSelection ? index : map.height - 1,\n          isRowSelection ? map.width - 1 : index,\n          table.node,\n        )\n        const $lastCell = tr.doc.resolve(table.from + lastCell)\n\n        const createCellSelection = isRowSelection ? CellSelection.rowSelection : CellSelection.colSelection\n\n        const firstCell = map.positionAt(isRowSelection ? index : 0, isRowSelection ? 0 : index, table.node)\n        const $firstCell = tr.doc.resolve(table.from + firstCell)\n        return cloneTr(tr.setSelection(createCellSelection($lastCell, $firstCell) as unknown as Selection))\n      }\n    }\n    return tr\n  }\n}\n\n/// If the selection is in a table,\n/// select the {index} row.\nexport const selectRow = selectLine('row')\n\n/// If the selection is in a table,\n/// select the {index} column.\nexport const selectCol = selectLine('col')\n\nfunction transpose<T>(array: T[][]) {\n  return array[0]!.map((_, i) => {\n    return array.map(column => column[i])\n  }) as T[][]\n}\n\nfunction convertArrayOfRowsToTableNode(tableNode: Node, arrayOfNodes: (Node | null)[][]) {\n  const rowsPM = []\n  const map = TableMap.get(tableNode)\n  for (let rowIndex = 0; rowIndex < map.height; rowIndex++) {\n    const row = tableNode.child(rowIndex)\n    const rowCells = []\n\n    for (let colIndex = 0; colIndex < map.width; colIndex++) {\n      if (!arrayOfNodes[rowIndex]![colIndex])\n        continue\n\n      const cellPos = map.map[rowIndex * map.width + colIndex]!\n\n      const cell = arrayOfNodes[rowIndex]![colIndex]!\n      const oldCell = tableNode.nodeAt(cellPos)!\n      const newCell = oldCell.type.createChecked(\n        Object.assign({}, cell.attrs),\n        cell.content,\n        cell.marks,\n      )\n      rowCells.push(newCell)\n    }\n\n    rowsPM.push(row.type.createChecked(row.attrs, rowCells, row.marks))\n  }\n\n  const newTable = tableNode.type.createChecked(\n    tableNode.attrs,\n    rowsPM,\n    tableNode.marks,\n  )\n\n  return newTable\n}\n\nfunction convertTableNodeToArrayOfRows(tableNode: Node) {\n  const map = TableMap.get(tableNode)\n  const rows: (Node | null)[][] = []\n  for (let rowIndex = 0; rowIndex < map.height; rowIndex++) {\n    const rowCells: (Node | null)[] = []\n    const seen: Record<number, boolean> = {}\n\n    for (let colIndex = 0; colIndex < map.width; colIndex++) {\n      const cellPos = map.map[rowIndex * map.width + colIndex]!\n      const cell = tableNode.nodeAt(cellPos)\n      const rect = map.findCell(cellPos)\n      if (seen[cellPos] || rect.top !== rowIndex) {\n        rowCells.push(null)\n        continue\n      }\n      seen[cellPos] = true\n\n      rowCells.push(cell)\n    }\n\n    rows.push(rowCells)\n  }\n\n  return rows\n}\n\nfunction moveRowInArrayOfRows(rows: (Node | null)[][], indexesOrigin: number[], indexesTarget: number[], directionOverride: -1 | 1 | 0) {\n  const direction = indexesOrigin[0]! > indexesTarget[0]! ? -1 : 1\n\n  const rowsExtracted = rows.splice(indexesOrigin[0]!, indexesOrigin.length)\n  const positionOffset = rowsExtracted.length % 2 === 0 ? 1 : 0\n  let target: number\n\n  if (directionOverride === -1 && direction === 1) {\n    target = indexesTarget[0]! - 1\n  }\n  else if (directionOverride === 1 && direction === -1) {\n    target = indexesTarget[indexesTarget.length - 1]! - positionOffset + 1\n  }\n  else {\n    target\n      = direction === -1\n        ? indexesTarget[0]!\n        : indexesTarget[indexesTarget.length - 1]! - positionOffset\n  }\n\n  rows.splice(target, 0, ...rowsExtracted)\n  return rows\n}\n\nfunction moveTableColumn(table: ContentNodeWithPos, indexesOrigin: number[], indexesTarget: number[], direction: -1 | 1 | 0) {\n  let rows = transpose(convertTableNodeToArrayOfRows(table.node))\n\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction)\n  rows = transpose(rows)\n\n  return convertArrayOfRowsToTableNode(table.node, rows)\n}\n\nfunction moveTableRow(table: ContentNodeWithPos, indexesOrigin: number[], indexesTarget: number[], direction: -1 | 1 | 0) {\n  let rows = convertTableNodeToArrayOfRows(table.node)\n\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction)\n\n  return convertArrayOfRowsToTableNode(table.node, rows)\n}\n\nfunction getSelectionRangeInColumn(columnIndex: number, tr: Transaction) {\n  let startIndex = columnIndex\n  let endIndex = columnIndex\n\n  // looking for selection start column (startIndex)\n  for (let i = columnIndex; i >= 0; i--) {\n    const cells = getCellsInCol(i, tr.selection)\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.colspan + i - 1\n        if (maybeEndIndex >= startIndex)\n          startIndex = i\n\n        if (maybeEndIndex > endIndex)\n          endIndex = maybeEndIndex\n      })\n    }\n  }\n  // looking for selection end column (endIndex)\n  for (let i = columnIndex; i <= endIndex; i++) {\n    const cells = getCellsInCol(i, tr.selection)\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.colspan + i - 1\n        if (cell.node.attrs.colspan > 1 && maybeEndIndex > endIndex)\n          endIndex = maybeEndIndex\n      })\n    }\n  }\n\n  // filter out columns without cells (where all rows have colspan > 1 in the same column)\n  const indexes = []\n  for (let i = startIndex; i <= endIndex; i++) {\n    const maybeCells = getCellsInCol(i, tr.selection)\n    if (maybeCells && maybeCells.length)\n      indexes.push(i)\n  }\n  startIndex = indexes[0]!\n  endIndex = indexes[indexes.length - 1]!\n\n  const firstSelectedColumnCells = getCellsInCol(startIndex, tr.selection)!\n  const firstRowCells = getCellsInRow(0, tr.selection)!\n  const $anchor = tr.doc.resolve(\n    firstSelectedColumnCells[firstSelectedColumnCells.length - 1]!.pos,\n  )\n\n  let headCell: CellPos | undefined\n  for (let i = endIndex; i >= startIndex; i--) {\n    const columnCells = getCellsInCol(i, tr.selection)\n    if (columnCells && columnCells.length) {\n      for (let j = firstRowCells.length - 1; j >= 0; j--) {\n        if (firstRowCells[j]!.pos === columnCells[0]!.pos) {\n          headCell = columnCells[0]\n          break\n        }\n      }\n      if (headCell)\n        break\n    }\n  }\n\n  const $head = tr.doc.resolve(headCell!.pos)\n  return { $anchor, $head, indexes }\n}\n\nfunction getSelectionRangeInRow(rowIndex: number, tr: Transaction) {\n  let startIndex = rowIndex\n  let endIndex = rowIndex\n  // looking for selection start row (startIndex)\n  for (let i = rowIndex; i >= 0; i--) {\n    const cells = getCellsInRow(i, tr.selection)\n    cells!.forEach((cell) => {\n      const maybeEndIndex = cell.node.attrs.rowspan + i - 1\n      if (maybeEndIndex >= startIndex)\n        startIndex = i\n\n      if (maybeEndIndex > endIndex)\n        endIndex = maybeEndIndex\n    })\n  }\n  // looking for selection end row (endIndex)\n  for (let i = rowIndex; i <= endIndex; i++) {\n    const cells = getCellsInRow(i, tr.selection)\n    cells!.forEach((cell) => {\n      const maybeEndIndex = cell.node.attrs.rowspan + i - 1\n      if (cell.node.attrs.rowspan > 1 && maybeEndIndex > endIndex)\n        endIndex = maybeEndIndex\n    })\n  }\n\n  // filter out rows without cells (where all columns have rowspan > 1 in the same row)\n  const indexes = []\n  for (let i = startIndex; i <= endIndex; i++) {\n    const maybeCells = getCellsInRow(i, tr.selection)\n    if (maybeCells && maybeCells.length)\n      indexes.push(i)\n  }\n  startIndex = indexes[0]!\n  endIndex = indexes[indexes.length - 1]!\n\n  const firstSelectedRowCells = getCellsInRow(startIndex, tr.selection)!\n  const firstColumnCells = getCellsInCol(0, tr.selection)!\n  const $anchor = tr.doc.resolve(firstSelectedRowCells[firstSelectedRowCells.length - 1]!.pos)\n\n  let headCell: CellPos | undefined\n  for (let i = endIndex; i >= startIndex; i--) {\n    const rowCells = getCellsInRow(i, tr.selection)\n    if (rowCells && rowCells.length) {\n      for (let j = firstColumnCells.length - 1; j >= 0; j--) {\n        if (firstColumnCells[j]!.pos === rowCells[0]!.pos) {\n          headCell = rowCells[0]!\n          break\n        }\n      }\n      if (headCell)\n        break\n    }\n  }\n\n  const $head = tr.doc.resolve(headCell!.pos)\n  return { $anchor, $head, indexes }\n}\n\nexport interface MoveColParams {\n  tr: Transaction\n  origin: number\n  target: number\n  select?: boolean\n  pos?: number\n}\n\n/// If the selection is in a table,\n/// Move the columns at `origin` to `target` in current table.\n/// The `select` is true by default, which means the selection will be set to the moved column.\nexport function moveCol(moveColParams: MoveColParams) {\n  const { tr, origin, target, select = true, pos } = moveColParams\n  const $pos = pos != null ? tr.doc.resolve(pos) : tr.selection.$from\n  const table = findTable($pos)\n  if (!table)\n    return tr\n\n  const { indexes: indexesOriginColumn } = getSelectionRangeInColumn(origin, tr)\n  const { indexes: indexesTargetColumn } = getSelectionRangeInColumn(target, tr)\n\n  if (indexesOriginColumn.includes(target))\n    return tr\n\n  const newTable = moveTableColumn(\n    table,\n    indexesOriginColumn,\n    indexesTargetColumn,\n    0,\n  )\n\n  const _tr = cloneTr(tr).replaceWith(\n    table.pos,\n    table.pos + table.node.nodeSize,\n    newTable,\n  )\n\n  if (!select)\n    return _tr\n\n  const map = TableMap.get(newTable)\n  const start = table.start\n  const index = target\n  const lastCell = map.positionAt(map.height - 1, index, newTable)\n  const $lastCell = _tr.doc.resolve(start + lastCell)\n\n  const createCellSelection = CellSelection.colSelection\n\n  const firstCell = map.positionAt(0, index, newTable)\n  const $firstCell = _tr.doc.resolve(start + firstCell)\n\n  return _tr.setSelection(createCellSelection($lastCell, $firstCell))\n}\n\nexport interface MoveRowParams {\n  tr: Transaction\n  origin: number\n  target: number\n  select?: boolean\n  pos?: number\n}\n\n/// If the selection is in a table,\n/// Move the rows at `origin` and `target` in current table.\n/// The `select` is true by default, which means the selection will be set to the moved row.\nexport function moveRow(moveRowParams: MoveRowParams) {\n  const { tr, origin, target, select = true, pos } = moveRowParams\n  const $pos = pos != null ? tr.doc.resolve(pos) : tr.selection.$from\n  const table = findTable($pos)\n  if (!table)\n    return tr\n\n  const { indexes: indexesOriginRow } = getSelectionRangeInRow(origin, tr)\n  const { indexes: indexesTargetRow } = getSelectionRangeInRow(target, tr)\n\n  if (indexesOriginRow.includes(target))\n    return tr\n\n  const newTable = moveTableRow(\n    table,\n    indexesOriginRow,\n    indexesTargetRow,\n    0,\n  )\n\n  const _tr = cloneTr(tr).replaceWith(\n    table.pos,\n    table.pos + table.node.nodeSize,\n    newTable,\n  )\n\n  if (!select)\n    return _tr\n\n  const map = TableMap.get(newTable)\n  const start = table.start\n  const index = target\n  const lastCell = map.positionAt(index, map.width - 1, newTable)\n  const $lastCell = _tr.doc.resolve(start + lastCell)\n\n  const createCellSelection = CellSelection.rowSelection\n\n  const firstCell = map.positionAt(index, 0, newTable)\n  const $firstCell = _tr.doc.resolve(start + firstCell)\n\n  return _tr.setSelection(createCellSelection($lastCell, $firstCell))\n}\n", "import { paragraphSchema } from '@milkdown/preset-commonmark'\nimport { Selection } from '@milkdown/prose/state'\nimport { CellSelection, addColumnAfter, addColumnBefore, deleteColumn, deleteRow, deleteTable, goToNextCell, isInTable, selectedRect, setCellAttr } from '@milkdown/prose/tables'\nimport { $command } from '@milkdown/utils'\nimport { findParentNodeType } from '@milkdown/prose'\nimport { withMeta } from '../../__internal__'\nimport { addRowWithAlignment, createTable, moveCol, moveRow, selectCol, selectRow, selectTable } from './utils'\nimport { tableSchema } from './schema'\n\n/// A command for moving cursor to previous cell.\nexport const goToPrevTableCellCommand = $command('GoToPrevTableCell', () => () => goToNextCell(-1))\n\nwithMeta(goToPrevTableCellCommand, {\n  displayName: 'Command<goToPrevTableCellCommand>',\n  group: 'Table',\n})\n\n/// A command for moving cursor to next cell.\nexport const goToNextTableCellCommand = $command('GoToNextTableCell', () => () => goToNextCell(1))\n\nwithMeta(goToNextTableCellCommand, {\n  displayName: 'Command<goToNextTableCellCommand>',\n  group: 'Table',\n})\n\n/// A command for quitting current table and insert a new paragraph node.\nexport const exitTable = $command('ExitTable', ctx => () => (state, dispatch) => {\n  if (!isInTable(state))\n    return false\n\n  const { $head } = state.selection\n  const table = findParentNodeType($head, tableSchema.type(ctx))\n  if (!table)\n    return false\n\n  const { to } = table\n\n  const tr = state.tr\n    .replaceWith(to, to, paragraphSchema.type(ctx).createAndFill()!)\n\n  tr.setSelection(Selection.near(tr.doc.resolve(to), 1)).scrollIntoView()\n  dispatch?.(tr)\n  return true\n})\n\nwithMeta(exitTable, {\n  displayName: 'Command<breakTableCommand>',\n  group: 'Table',\n})\n\n/// A command for inserting a table.\n/// You can specify the number of rows and columns.\n/// By default, it will insert a 3x3 table.\nexport const insertTableCommand = $command('InsertTable', ctx => ({ row, col }: { row?: number, col?: number } = {}) => (state, dispatch) => {\n  const { selection, tr } = state\n  const { from } = selection\n  const table = createTable(ctx, row, col)\n  const _tr = tr.replaceSelectionWith(table)\n  const sel = Selection.findFrom(_tr.doc.resolve(from), 1, true)\n  if (sel)\n    _tr.setSelection(sel)\n\n  dispatch?.(_tr)\n\n  return true\n})\n\nwithMeta(insertTableCommand, {\n  displayName: 'Command<insertTableCommand>',\n  group: 'Table',\n})\n\n/// A command for moving a row in a table.\n/// You should specify the `from` and `to` index.\nexport const moveRowCommand = $command('MoveRow', () =>\n  ({ from, to, pos }: { from?: number, to?: number, pos?: number } = {}) =>\n    (state, dispatch) => {\n      const { tr } = state\n      const result = dispatch?.(moveRow({ tr, origin: from ?? 0, target: to ?? 0, pos, select: true }))\n\n      return Boolean(result)\n    })\n\nwithMeta(moveRowCommand, {\n  displayName: 'Command<moveRowCommand>',\n  group: 'Table',\n})\n\n/// A command for moving a column in a table.\n/// You should specify the `from` and `to` index.\nexport const moveColCommand = $command('MoveCol', () =>\n  ({ from, to, pos }: { from?: number, to?: number, pos?: number } = {}) =>\n    (state, dispatch) => {\n      const { tr } = state\n      const result = dispatch?.(moveCol({ tr, origin: from ?? 0, target: to ?? 0, pos, select: true }))\n\n      return Boolean(result)\n    })\n\nwithMeta(moveColCommand, {\n  displayName: 'Command<moveColCommand>',\n  group: 'Table',\n})\n\n/// A command for selecting a row.\nexport const selectRowCommand = $command<{ index: number, pos?: number }, 'SelectRow'>('SelectRow', () =>\n  (payload: { index: number, pos?: number } = { index: 0 }) => (state, dispatch) => {\n    const { tr } = state\n    const result = dispatch?.(selectRow(payload.index, payload.pos)(tr))\n\n    return Boolean(result)\n  })\n\nwithMeta(selectRowCommand, {\n  displayName: 'Command<selectRowCommand>',\n  group: 'Table',\n})\n\n/// A command for selecting a column.\nexport const selectColCommand = $command<{ index: number, pos?: number }, 'SelectCol'>('SelectCol', () =>\n  (payload: { index: number, pos?: number } = { index: 0 }) => (state, dispatch) => {\n    const { tr } = state\n    const result = dispatch?.(selectCol(payload.index, payload.pos)(tr))\n\n    return Boolean(result)\n  })\n\nwithMeta(selectColCommand, {\n  displayName: 'Command<selectColCommand>',\n  group: 'Table',\n})\n\n/// A command for selecting a table.\nexport const selectTableCommand = $command('SelectTable', () => () => (state, dispatch) => {\n  const { tr } = state\n  const result = dispatch?.(selectTable(tr))\n\n  return Boolean(result)\n})\n\nwithMeta(selectTableCommand, {\n  displayName: 'Command<selectTableCommand>',\n  group: 'Table',\n})\n\n/// A command for deleting selected cells.\n/// If the selection is a row or column, the row or column will be deleted.\n/// If all cells are selected, the table will be deleted.\nexport const deleteSelectedCellsCommand = $command('DeleteSelectedCells', () => () => (state, dispatch) => {\n  const { selection } = state\n  if (!(selection instanceof CellSelection))\n    return false\n\n  const isRow = selection.isRowSelection()\n  const isCol = selection.isColSelection()\n\n  if (isRow && isCol)\n    return deleteTable(state, dispatch)\n\n  if (isCol)\n    return deleteColumn(state, dispatch)\n\n  else\n    return deleteRow(state, dispatch)\n})\n\nwithMeta(deleteSelectedCellsCommand, {\n  displayName: 'Command<deleteSelectedCellsCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a column before the current column.\nexport const addColBeforeCommand = $command('AddColBefore', () => () => addColumnBefore)\n\nwithMeta(addColBeforeCommand, {\n  displayName: 'Command<addColBeforeCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a column after the current column.\nexport const addColAfterCommand = $command('AddColAfter', () => () => addColumnAfter)\n\nwithMeta(addColAfterCommand, {\n  displayName: 'Command<addColAfterCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a row before the current row.\nexport const addRowBeforeCommand = $command('AddRowBefore', ctx => () => (state, dispatch) => {\n  if (!isInTable(state))\n    return false\n  if (dispatch) {\n    const rect = selectedRect(state)\n    dispatch(addRowWithAlignment(ctx, state.tr, rect, rect.top))\n  }\n  return true\n})\n\nwithMeta(addRowBeforeCommand, {\n  displayName: 'Command<addRowBeforeCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a row after the current row.\nexport const addRowAfterCommand = $command('AddRowAfter', ctx => () => (state, dispatch) => {\n  if (!isInTable(state))\n    return false\n  if (dispatch) {\n    const rect = selectedRect(state)\n    dispatch(addRowWithAlignment(ctx, state.tr, rect, rect.bottom))\n  }\n  return true\n})\n\nwithMeta(addRowAfterCommand, {\n  displayName: 'Command<addRowAfterCommand>',\n  group: 'Table',\n})\n\n/// A command for setting alignment property for selected cells.\n/// You can specify the alignment as `left`, `center`, or `right`.\n/// It's `left` by default.\nexport const setAlignCommand = $command<'left' | 'center' | 'right', 'SetAlign'>('SetAlign', () => (alignment = 'left') => setCellAttr('alignment', alignment))\n\nwithMeta(setAlignCommand, {\n  displayName: 'Command<setAlignCommand>',\n  group: 'Table',\n})\n", "import { commandsCtx } from '@milkdown/core'\nimport { InputRule } from '@milkdown/prose/inputrules'\nimport { TextSelection } from '@milkdown/prose/state'\nimport { $inputRule, $useKeymap } from '@milkdown/utils'\nimport { withMeta } from '../../__internal__'\nimport { createTable } from './utils'\nimport { tableSchema } from './schema'\nimport { exitTable, goToNextTableCellCommand, goToPrevTableCellCommand } from './command'\n\n/// A input rule for creating table.\n/// For example, `|2x2|` will create a 2x2 table.\nexport const insertTableInputRule = $inputRule(ctx => new InputRule(\n  /^\\|(?<col>\\d+)[xX](?<row>\\d+)\\|\\s$/,\n  (state, match, start, end) => {\n    const $start = state.doc.resolve(start)\n    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), tableSchema.type(ctx)))\n      return null\n\n    const tableNode = createTable(\n      ctx,\n      Number(match.groups?.row),\n      Number(match.groups?.col),\n    )\n    const tr = state.tr.replaceRangeWith(start, end, tableNode)\n    return tr.setSelection(TextSelection.create(tr.doc, start + 3)).scrollIntoView()\n  },\n))\n\nwithMeta(insertTableInputRule, {\n  displayName: 'InputRule<insertTableInputRule>',\n  group: 'Table',\n})\n\n/// Keymap for table commands.\n/// - `<Mod-]>`/`<Tab>`: Move to the next cell.\n/// - `<Mod-[>`/`<Shift-Tab>`: Move to the previous cell.\n/// - `<Mod-Enter>`: Exit the table, and break it if possible.\nexport const tableKeymap = $useKeymap('tableKeymap', {\n  NextCell: {\n    shortcuts: ['Mod-]', 'Tab'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n\n      return () => commands.call(goToNextTableCellCommand.key)\n    },\n  },\n  PrevCell: {\n    shortcuts: ['Mod-[', 'Shift-Tab'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n\n      return () => commands.call(goToPrevTableCellCommand.key)\n    },\n  },\n  ExitTable: {\n    shortcuts: ['Mod-Enter'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n\n      return () => commands.call(exitTable.key)\n    },\n  },\n})\n\nwithMeta(tableKeymap.ctx, {\n  displayName: 'KeymapCtx<table>',\n  group: 'Table',\n})\n\nwithMeta(tableKeymap.shortcuts, {\n  displayName: 'Keymap<table>',\n  group: 'Table',\n})\n", "import { expectDomTypeError } from '@milkdown/exception'\nimport { $nodeSchema } from '@milkdown/utils'\nimport { withMeta } from '../../__internal__'\n\nconst id = 'footnote_definition'\nconst markdownId = 'footnoteDefinition'\n\n/// Footnote definition node schema.\nexport const footnoteDefinitionSchema = $nodeSchema('footnote_definition', () => ({\n  group: 'block',\n  content: 'block+',\n  defining: true,\n  attrs: {\n    label: {\n      default: '',\n    },\n  },\n  parseDOM: [\n    {\n      tag: `dl[data-type=\"${id}\"]`,\n      getAttrs: (dom) => {\n        if (!(dom instanceof HTMLElement))\n          throw expectDomTypeError(dom)\n\n        return {\n          label: dom.dataset.label,\n        }\n      },\n      contentElement: 'dd',\n    },\n  ],\n  toDOM: (node) => {\n    const label = node.attrs.label\n\n    return [\n      'dl',\n      {\n        // TODO: add a prosemirror plugin to sync label on change\n        'data-label': label,\n        'data-type': id,\n      },\n      ['dt', label],\n      ['dd', 0],\n    ]\n  },\n  parseMarkdown: {\n    match: ({ type }) => type === markdownId,\n    runner: (state, node, type) => {\n      state\n        .openNode(type, {\n          label: node.label as string,\n        })\n        .next(node.children)\n        .closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === id,\n    runner: (state, node) => {\n      state\n        .openNode(markdownId, undefined, {\n          label: node.attrs.label,\n          identifier: node.attrs.label,\n        })\n        .next(node.content)\n        .closeNode()\n    },\n  },\n}))\n\nwithMeta(footnoteDefinitionSchema.ctx, {\n  displayName: 'NodeSchemaCtx<footnodeDef>',\n  group: 'footnote',\n})\n\nwithMeta(footnoteDefinitionSchema.node, {\n  displayName: 'NodeSchema<footnodeDef>',\n  group: 'footnote',\n})\n", "import { expectDomTypeError } from '@milkdown/exception'\nimport { $nodeSchema } from '@milkdown/utils'\nimport { withMeta } from '../../__internal__'\n\nconst id = 'footnote_reference'\n\n/// Footnote reference node schema.\nexport const footnoteReferenceSchema = $nodeSchema('footnote_reference', () => ({\n  group: 'inline',\n  inline: true,\n  atom: true,\n  attrs: {\n    label: {\n      default: '',\n    },\n  },\n  parseDOM: [\n    {\n      tag: `sup[data-type=\"${id}\"]`,\n      getAttrs: (dom) => {\n        if (!(dom instanceof HTMLElement))\n          throw expectDomTypeError(dom)\n\n        return {\n          label: dom.dataset.label,\n        }\n      },\n    },\n  ],\n  toDOM: (node) => {\n    const label = node.attrs.label\n    return [\n      'sup',\n      {\n        // TODO: add a prosemirror plugin to sync label on change\n        'data-label': label,\n        'data-type': id,\n      },\n      label,\n    ]\n  },\n  parseMarkdown: {\n    match: ({ type }) => type === 'footnoteReference',\n    runner: (state, node, type) => {\n      state.addNode(type, {\n        label: node.label as string,\n      })\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === id,\n    runner: (state, node) => {\n      state.addNode('footnoteReference', undefined, undefined, {\n        label: node.attrs.label,\n        identifier: node.attrs.label,\n      })\n    },\n  },\n}))\n\nwithMeta(footnoteReferenceSchema.ctx, {\n  displayName: 'NodeSchemaCtx<footnodeRef>',\n  group: 'footnote',\n})\n\nwithMeta(footnoteReferenceSchema.node, {\n  displayName: 'NodeSchema<footnodeRef>',\n  group: 'footnote',\n})\n", "import { expectDomTypeError } from '@milkdown/exception'\nimport { listItemSchema } from '@milkdown/preset-commonmark'\nimport { InputRule } from '@milkdown/prose/inputrules'\nimport { $inputRule } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// This schema extends the [list item](/preset-commonmark#list-item) schema and add task list support for it.\nexport const extendListItemSchemaForTask = listItemSchema.extendSchema((prev) => {\n  return (ctx) => {\n    const baseSchema = prev(ctx)\n    return {\n      ...baseSchema,\n      attrs: {\n        ...baseSchema.attrs,\n        checked: {\n          default: null,\n        },\n      },\n      parseDOM: [\n        {\n          tag: 'li[data-item-type=\"task\"]',\n          getAttrs: (dom) => {\n            if (!(dom instanceof HTMLElement))\n              throw expectDomTypeError(dom)\n\n            return {\n              label: dom.dataset.label,\n              listType: dom.dataset.listType,\n              spread: dom.dataset.spread,\n              checked: dom.dataset.checked ? dom.dataset.checked === 'true' : null,\n            }\n          },\n        },\n        ...baseSchema?.parseDOM || [],\n      ],\n      toDOM: (node) => {\n        if (baseSchema.toDOM && node.attrs.checked == null)\n          return baseSchema.toDOM(node)\n\n        return [\n          'li',\n          {\n            'data-item-type': 'task',\n            'data-label': node.attrs.label,\n            'data-list-type': node.attrs.listType,\n            'data-spread': node.attrs.spread,\n            'data-checked': node.attrs.checked,\n          },\n          0,\n        ]\n      },\n      parseMarkdown: {\n        match: ({ type }) => type === 'listItem',\n        runner: (state, node, type) => {\n          if (node.checked == null) {\n            baseSchema.parseMarkdown.runner(state, node, type)\n            return\n          }\n\n          const label = node.label != null ? `${node.label}.` : '•'\n          const checked = node.checked != null ? Boolean(node.checked) : null\n          const listType = node.label != null ? 'ordered' : 'bullet'\n          const spread = node.spread != null ? `${node.spread}` : 'true'\n\n          state.openNode(type, { label, listType, spread, checked })\n          state.next(node.children)\n          state.closeNode()\n        },\n      },\n      toMarkdown: {\n        match: node => node.type.name === 'list_item',\n        runner: (state, node) => {\n          if (node.attrs.checked == null) {\n            baseSchema.toMarkdown.runner(state, node)\n            return\n          }\n\n          const label = node.attrs.label\n          const listType = node.attrs.listType\n          const spread = node.attrs.spread === 'true'\n          const checked = node.attrs.checked\n\n          state.openNode('listItem', undefined, { label, listType, spread, checked })\n          state.next(node.content)\n          state.closeNode()\n        },\n      },\n    }\n  }\n})\n\nwithMeta(extendListItemSchemaForTask, {\n  displayName: 'NodeSchema<listItem>',\n  group: 'ListItem',\n})\n\n/// Input rule for wrapping a block in task list node.\n/// Users can type `[ ] ` or `[x] ` to wrap the block in task list node with checked status.\nexport const wrapInTaskListInputRule = $inputRule(() => {\n  return new InputRule(/^\\[(?<checked>\\s|x)\\]\\s$/, (state, match, start, end) => {\n    const pos = state.doc.resolve(start)\n    let depth = 0\n    let node = pos.node(depth)\n    while (node && node.type.name !== 'list_item') {\n      depth--\n      node = pos.node(depth)\n    }\n\n    if (!node || node.attrs.checked != null)\n      return null\n\n    const checked = Boolean(match.groups?.checked === 'x')\n\n    const finPos = pos.before(depth)\n    const tr = state.tr\n\n    tr.deleteRange(start, end)\n      .setNodeMarkup(finPos, undefined, { ...node.attrs, checked })\n\n    return tr\n  })\n})\n\nwithMeta(wrapInTaskListInputRule, {\n  displayName: 'InputRule<wrapInTaskListInputRule>',\n  group: 'ListItem',\n})\n", "import type { MilkdownPlugin } from '@milkdown/ctx'\nimport { strikethroughKeymap } from '../mark'\nimport { tableKeymap } from '../node'\n\n/// @internal\nexport const keymap: MilkdownPlugin[] = [\n  strikethroughKeymap,\n  tableKeymap,\n].flat()\n", "import type { MilkdownPlugin } from '@milkdown/ctx'\nimport { insertTableInputRule, wrapInTaskListInputRule } from '../node'\nimport { strikethroughInputRule } from '../mark'\n\n/// @internal\nexport const inputRules: MilkdownPlugin[] = [\n  insertTableInputRule,\n  wrapInTaskListInputRule,\n]\n\nexport const markInputRules: MilkdownPlugin[] = [\n  strikethroughInputRule,\n]\n", "import { $prose } from '@milkdown/utils'\nimport { imeSpan } from 'prosemirror-safari-ime-span'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is used to fix the bug of IME composing in table in Safari browser.\n/// original discussion in https://discuss.prosemirror.net/t/ime-composing-problems-on-td-or-th-element-in-safari-browser/4501\nexport const autoInsertSpanPlugin = $prose(() => imeSpan)\n\nwithMeta(autoInsertSpanPlugin, {\n  displayName: 'Prose<autoInsertSpanPlugin>',\n  group: 'Prose',\n})\n", "import { columnResizing } from '@milkdown/prose/tables'\nimport { $prose } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is wrapping the `columnResizing` plugin from [prosemirror-tables](https://github.com/ProseMirror/prosemirror-tables).\nexport const columnResizingPlugin = $prose(() => columnResizing({}))\n\nwithMeta(columnResizingPlugin, {\n  displayName: 'Prose<columnResizingPlugin>',\n  group: 'Prose',\n})\n", "import { tableEditing } from '@milkdown/prose/tables'\nimport { $prose } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is wrapping the `tableEditing` plugin from [prosemirror-tables](https://github.com/ProseMirror/prosemirror-tables).\nexport const tableEditingPlugin = $prose(() => tableEditing({ allowTableNodeSelection: true }))\n\nwithMeta(tableEditingPlugin, {\n  displayName: 'Prose<tableEditingPlugin>',\n  group: 'Prose',\n})\n", "import type { $Remark } from '@milkdown/utils'\nimport { $remark } from '@milkdown/utils'\nimport type { Options } from 'remark-gfm'\nimport remarkGFM from 'remark-gfm'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is wrapping the [remark-gfm](https://github.com/remarkjs/remark-gfm).\nexport const remarkGFMPlugin: $Remark<'remarkGFM', Options | null | undefined> = $remark('remarkGFM', () => remarkGFM)\n\nwithMeta(remarkGFMPlugin.plugin, {\n  displayName: 'Remark<remarkGFMPlugin>',\n  group: 'Remark',\n})\n\nwithMeta(remarkGFMPlugin.options, {\n  displayName: 'RemarkConfig<remarkGFMPlugin>',\n  group: 'Remark',\n})\n", "import type { Transaction } from '@milkdown/prose/state'\nimport { Plugin, PluginKey } from '@milkdown/prose/state'\nimport type { Node } from '@milkdown/prose/model'\nimport { $prose } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\nconst pluginKey = new PluginKey('MILKDOWN_KEEP_TABLE_ALIGN_PLUGIN')\n\nfunction getChildIndex(node: Node, parent: Node) {\n  let index = 0\n  parent.forEach((child, _offset, i) => {\n    if (child === node)\n      index = i\n  })\n  return index\n}\n\nexport const keepTableAlignPlugin = $prose(() => {\n  return new Plugin({\n    key: pluginKey,\n    appendTransaction: (_tr, oldState, state) => {\n      let tr: Transaction | undefined\n      const check = (node: Node, pos: number) => {\n        if (!tr)\n          tr = state.tr\n\n        if (node.type.name !== 'table_cell')\n          return\n\n        const $pos = state.doc.resolve(pos)\n        const tableRow = $pos.node($pos.depth)\n        const table = $pos.node($pos.depth - 1)\n        const tableHeaderRow = table.firstChild\n        // TODO: maybe consider add a header row\n        if (!tableHeaderRow)\n          return\n\n        const index = getChildIndex(node, tableRow)\n        const headerCell = tableHeaderRow.maybeChild(index)\n        if (!headerCell)\n          return\n        const align = headerCell.attrs.alignment\n        const currentAlign = node.attrs.alignment\n        if (align === currentAlign)\n          return\n\n        tr.setNodeMarkup(pos, undefined, { ...node.attrs, alignment: align })\n      }\n      if (oldState.doc !== state.doc)\n        state.doc.descendants(check)\n\n      return tr\n    },\n  })\n})\n\nwithMeta(keepTableAlignPlugin, {\n  displayName: 'Prose<keepTableAlignPlugin>',\n  group: 'Prose',\n})\n", "import type { MilkdownPlugin } from '@milkdown/ctx'\nimport {\n  autoInsertSpanPlugin,\n  keepTableAlignPlugin,\n  remarkGFMPlugin,\n  tableEditingPlugin,\n} from '../plugin'\n\n/// @internal\nexport const plugins: MilkdownPlugin[] = [\n  keepTableAlignPlugin,\n  autoInsertSpanPlugin,\n  remarkGFMPlugin,\n  tableEditingPlugin,\n].flat()\n", "import type { MilkdownPlugin } from '@milkdown/ctx'\nimport { strikethroughAttr, strikethroughSchema } from '../mark'\nimport {\n  extendListItemSchemaForTask,\n  footnoteDefinitionSchema,\n  footnoteReferenceSchema,\n  tableCellSchema,\n  tableHeaderRowSchema,\n  tableHeaderSchema,\n  tableRowSchema,\n  tableSchema,\n} from '../node'\n\n/// @internal\nexport const schema: MilkdownPlugin[] = [\n  extendListItemSchemaForTask,\n\n  tableSchema,\n  tableHeaderRowSchema,\n  tableRowSchema,\n  tableHeaderSchema,\n  tableCellSchema,\n\n  footnoteDefinitionSchema,\n  footnoteReferenceSchema,\n\n  strikethroughAttr,\n  strikethroughSchema,\n].flat()\n", "import { toggleStrikethroughCommand } from '../mark'\nimport { addColAfterCommand, addColBeforeCommand, addRowAfterCommand, addRowBeforeCommand, deleteSelectedCellsCommand, exitTable, goToNextTableCellCommand, goToPrevTableCellCommand, insertTableCommand, moveColCommand, moveRowCommand, selectColCommand, selectRowCommand, selectTableCommand, setAlignCommand } from '../node'\n\n/// @internal\nexport const commands = [\n  goToNextTableCellCommand,\n  goToPrevTableCellCommand,\n  exitTable,\n  insertTableCommand,\n  moveRowCommand,\n  moveColCommand,\n  selectRowCommand,\n  selectColCommand,\n  selectTableCommand,\n  deleteSelectedCellsCommand,\n  addRowBeforeCommand,\n  addRowAfterCommand,\n  addColBeforeCommand,\n  addColAfterCommand,\n  setAlignCommand,\n\n  toggleStrikethroughCommand,\n]\n", "import { commands, inputRules, keymap, markInputRules, plugins, schema } from './composed'\n\nexport * from './node'\nexport * from './mark'\nexport * from './plugin'\nexport * from './composed'\n\n/// The GFM preset, includes all the plugins.\nexport const gfm = [schema, inputRules, markInputRules, keymap, commands, plugins].flat()\n"],
  "mappings": "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",
  "names": ["key", "i", "map", "j", "w", "map", "w", "i", "j", "map", "i", "types", "i", "j", "map", "handle", "replace", "domain", "path", "trail", "code", "exit", "exit", "row", "sizes", "columnIndex", "code", "exit", "ok", "code", "trail", "ok", "code", "text", "ok", "previous", "code", "at", "ok", "code", "map", "ok", "code", "withMeta", "plugin", "meta", "strikethroughAttr", "$markAttr", "strikethroughSchema", "$markSchema", "ctx", "value", "mark", "node", "state", "markType", "toggleStrikethroughCommand", "$command", "toggleMark", "strikethroughInputRule", "$inputRule", "markRule", "strikethroughKeymap", "$useKeymap", "commands", "commandsCtx", "originalSchema", "tableNodes", "dom", "attrs", "tableSchema", "$nodeSchema", "type", "align", "children", "x", "i", "firstLine", "_a", "cell", "tableHeaderRowSchema", "tableRowSchema", "tableCellSchema", "tableHeaderSchema", "createTable", "rowsCount", "colsCount", "cells", "headerCells", "rows", "_", "findTable", "$pos", "findParentNodeClosestToPos", "getCellsInCol", "columnIndex", "selection", "table", "map", "TableMap", "pos", "start", "getCellsInRow", "rowIndex", "getAllCellsInTable", "nodePos", "selectTable", "tr", "$firstCell", "last", "$lastCell", "cloneTr", "CellSelection", "addRowWithAlignment", "tableStart", "row", "rowPos", "acc", "col", "headerCol", "selectLine", "index", "$node", "isRowSelection", "lastCell", "createCellSelection", "firstCell", "selectRow", "selectCol", "transpose", "array", "column", "convertArrayOfRowsToTableNode", "tableNode", "arrayOfNodes", "rowsPM", "rowCells", "colIndex", "cellPos", "newCell", "convertTableNodeToArrayOfRows", "seen", "rect", "moveRowInArrayOfRows", "indexesOrigin", "indexesTarget", "directionOverride", "direction", "rowsExtracted", "positionOffset", "target", "moveTableColumn", "moveTableRow", "getSelectionRangeInColumn", "startIndex", "endIndex", "maybeEndIndex", "indexes", "maybeCells", "firstSelectedColumnCells", "firstRowCells", "$anchor", "headCell", "columnCells", "j", "$head", "getSelectionRangeInRow", "firstSelectedRowCells", "firstColumnCells", "moveCol", "moveColParams", "origin", "select", "indexesOriginColumn", "indexesTargetColumn", "newTable", "_tr", "moveRow", "moveRowParams", "indexesOriginRow", "indexesTargetRow", "goToPrevTableCellCommand", "goToNextCell", "goToNextTableCellCommand", "exitTable", "dispatch", "isInTable", "findParentNodeType", "to", "paragraphSchema", "Selection", "insertTableCommand", "from", "sel", "moveRowCommand", "moveColCommand", "selectRowCommand", "payload", "selectColCommand", "selectTableCommand", "deleteSelectedCellsCommand", "isRow", "isCol", "deleteTable", "deleteColumn", "deleteRow", "addColBeforeCommand", "addColumnBefore", "addColAfterCommand", "addColumnAfter", "addRowBeforeCommand", "selectedRect", "addRowAfterCommand", "setAlignCommand", "alignment", "setCellAttr", "insertTableInputRule", "InputRule", "match", "end", "$start", "_b", "TextSelection", "tableKeymap", "id", "markdownId", "footnoteDefinitionSchema", "expectDomTypeError", "label", "footnoteReferenceSchema", "extendListItemSchemaForTask", "listItemSchema", "prev", "baseSchema", "checked", "listType", "spread", "wrapInTaskListInputRule", "depth", "finPos", "keymap", "inputRules", "markInputRules", "autoInsertSpanPlugin", "$prose", "imeSpan", "columnResizingPlugin", "columnResizing", "tableEditingPlugin", "tableEditing", "remarkGFMPlugin", "$remark", "remarkGFM", "pluginKey", "PluginKey", "getChildIndex", "parent", "child", "_offset", "keepTableAlignPlugin", "Plugin", "oldState", "check", "tableRow", "tableHeaderRow", "headerCell", "currentAlign", "plugins", "schema", "gfm"]
}

import {
  c,
  h,
  html,
  useEffect,
  useHost,
  useLayoutEffect,
  useMemo,
  useRef,
  useState
} from "./chunk-6V3WYRAC.js";
import {
  W
} from "./chunk-GY6PBQCW.js";
import {
  h as h2,
  le
} from "./chunk-KJ6QXBW5.js";
import {
  exitCode
} from "./chunk-ICFNTP7Z.js";
import "./chunk-6PP7FW5N.js";
import "./chunk-KB7SXD3B.js";
import {
  Mapping,
  PluginKey,
  TextSelection
} from "./chunk-JD2NWN4W.js";
import {
  clsx_default
} from "./chunk-VEB3A3D5.js";
import {
  computePosition
} from "./chunk-6Z2PECDR.js";
import {
  Compartment,
  EditorState,
  EditorView,
  keymap
} from "./chunk-S2GIR3LS.js";
import "./chunk-S2LDZEAK.js";
import "./chunk-DP4XHQAG.js";

// node_modules/rope-sequence/dist/index.js
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {
};
RopeSequence.prototype.append = function append(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice(from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  if (from2 >= to) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from2), Math.min(this.length, to));
};
RopeSequence.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) {
    return void 0;
  }
  return this.getInner(i);
};
RopeSequence.prototype.forEach = function forEach(f, from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  if (from2 <= to) {
    this.forEachInner(f, from2, to, 0);
  } else {
    this.forEachInvertedInner(f, from2, to, 0);
  }
};
RopeSequence.prototype.map = function map(f, from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  var result = [];
  this.forEach(function(elt, i) {
    return result.push(f(elt, i));
  }, from2, to);
  return result;
};
RopeSequence.from = function from(values) {
  if (values instanceof RopeSequence) {
    return values;
  }
  return values && values.length ? new Leaf(values) : RopeSequence.empty;
};
var Leaf = function(RopeSequence3) {
  function Leaf2(values) {
    RopeSequence3.call(this);
    this.values = values;
  }
  if (RopeSequence3) Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
  Leaf2.prototype.flatten = function flatten() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from2, to));
  };
  Leaf2.prototype.getInner = function getInner(i) {
    return this.values[i];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f, from2, to, start) {
    for (var i = from2; i < to; i++) {
      if (f(this.values[i], start + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {
    for (var i = from2 - 1; i >= to; i--) {
      if (f(this.values[i], start + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors);
  return Leaf2;
}(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = function(RopeSequence3) {
  function Append2(left, right) {
    RopeSequence3.call(this);
    this.left = left;
    this.right = right;
    this.length = left.length + right.length;
    this.depth = Math.max(left.depth, right.depth) + 1;
  }
  if (RopeSequence3) Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f, from2, to, start) {
    var leftLen = this.left.length;
    if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {
    var leftLen = this.left.length;
    if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from2, to);
    }
    if (from2 >= leftLen) {
      return this.right.slice(from2 - leftLen, to - leftLen);
    }
    return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
}(RopeSequence);
var dist_default = RopeSequence;

// node_modules/prosemirror-history/dist/index.js
var max_empty_items = 500;
var Branch = class _Branch {
  constructor(items, eventCount) {
    this.items = items;
    this.eventCount = eventCount;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(state, preserveItems) {
    if (this.eventCount == 0)
      return null;
    let end = this.items.length;
    for (; ; end--) {
      let next = this.items.get(end - 1);
      if (next.selection) {
        --end;
        break;
      }
    }
    let remap, mapFrom;
    if (preserveItems) {
      remap = this.remapping(end, this.items.length);
      mapFrom = remap.maps.length;
    }
    let transform = state.tr;
    let selection, remaining;
    let addAfter = [], addBefore = [];
    this.items.forEach((item, i) => {
      if (!item.step) {
        if (!remap) {
          remap = this.remapping(end, i + 1);
          mapFrom = remap.maps.length;
        }
        mapFrom--;
        addBefore.push(item);
        return;
      }
      if (remap) {
        addBefore.push(new Item(item.map));
        let step = item.step.map(remap.slice(mapFrom)), map2;
        if (step && transform.maybeStep(step).doc) {
          map2 = transform.mapping.maps[transform.mapping.maps.length - 1];
          addAfter.push(new Item(map2, void 0, void 0, addAfter.length + addBefore.length));
        }
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
      } else {
        transform.maybeStep(item.step);
      }
      if (item.selection) {
        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
        remaining = new _Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
        return false;
      }
    }, this.items.length, 0);
    return { remaining, transform, selection };
  }
  // Create a new branch with the given transform added.
  addTransform(transform, selection, histOptions, preserveItems) {
    let newItems = [], eventCount = this.eventCount;
    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
    for (let i = 0; i < transform.steps.length; i++) {
      let step = transform.steps[i].invert(transform.docs[i]);
      let item = new Item(transform.mapping.maps[i], step, selection), merged;
      if (merged = lastItem && lastItem.merge(item)) {
        item = merged;
        if (i)
          newItems.pop();
        else
          oldItems = oldItems.slice(0, oldItems.length - 1);
      }
      newItems.push(item);
      if (selection) {
        eventCount++;
        selection = void 0;
      }
      if (!preserveItems)
        lastItem = item;
    }
    let overflow = eventCount - histOptions.depth;
    if (overflow > DEPTH_OVERFLOW) {
      oldItems = cutOffEvents(oldItems, overflow);
      eventCount -= overflow;
    }
    return new _Branch(oldItems.append(newItems), eventCount);
  }
  remapping(from2, to) {
    let maps = new Mapping();
    this.items.forEach((item, i) => {
      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : void 0;
      maps.appendMap(item.map, mirrorPos);
    }, from2, to);
    return maps;
  }
  addMaps(array) {
    if (this.eventCount == 0)
      return this;
    return new _Branch(this.items.append(array.map((map2) => new Item(map2))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(rebasedTransform, rebasedCount) {
    if (!this.eventCount)
      return this;
    let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);
    let mapping = rebasedTransform.mapping;
    let newUntil = rebasedTransform.steps.length;
    let eventCount = this.eventCount;
    this.items.forEach((item) => {
      if (item.selection)
        eventCount--;
    }, start);
    let iRebased = rebasedCount;
    this.items.forEach((item) => {
      let pos = mapping.getMirror(--iRebased);
      if (pos == null)
        return;
      newUntil = Math.min(newUntil, pos);
      let map2 = mapping.maps[pos];
      if (item.step) {
        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
        if (selection)
          eventCount++;
        rebasedItems.push(new Item(map2, step, selection));
      } else {
        rebasedItems.push(new Item(map2));
      }
    }, start);
    let newMaps = [];
    for (let i = rebasedCount; i < newUntil; i++)
      newMaps.push(new Item(mapping.maps[i]));
    let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
    let branch = new _Branch(items, eventCount);
    if (branch.emptyItemCount() > max_empty_items)
      branch = branch.compress(this.items.length - rebasedItems.length);
    return branch;
  }
  emptyItemCount() {
    let count = 0;
    this.items.forEach((item) => {
      if (!item.step)
        count++;
    });
    return count;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(upto = this.items.length) {
    let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
    let items = [], events = 0;
    this.items.forEach((item, i) => {
      if (i >= upto) {
        items.push(item);
        if (item.selection)
          events++;
      } else if (item.step) {
        let step = item.step.map(remap.slice(mapFrom)), map2 = step && step.getMap();
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
        if (step) {
          let selection = item.selection && item.selection.map(remap.slice(mapFrom));
          if (selection)
            events++;
          let newItem = new Item(map2.invert(), step, selection), merged, last = items.length - 1;
          if (merged = items.length && items[last].merge(newItem))
            items[last] = merged;
          else
            items.push(newItem);
        }
      } else if (item.map) {
        mapFrom--;
      }
    }, this.items.length, 0);
    return new _Branch(dist_default.from(items.reverse()), events);
  }
};
Branch.empty = new Branch(dist_default.empty, 0);
function cutOffEvents(items, n) {
  let cutPoint;
  items.forEach((item, i) => {
    if (item.selection && n-- == 0) {
      cutPoint = i;
      return false;
    }
  });
  return items.slice(cutPoint);
}
var Item = class _Item {
  constructor(map2, step, selection, mirrorOffset) {
    this.map = map2;
    this.step = step;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  }
  merge(other) {
    if (this.step && other.step && !other.selection) {
      let step = other.step.merge(this.step);
      if (step)
        return new _Item(step.getMap().invert(), step, this.selection);
    }
  }
};
var HistoryState = class {
  constructor(done, undone, prevRanges, prevTime, prevComposition) {
    this.done = done;
    this.undone = undone;
    this.prevRanges = prevRanges;
    this.prevTime = prevTime;
    this.prevComposition = prevComposition;
  }
};
var DEPTH_OVERFLOW = 20;
function histTransaction(history, state, redo2) {
  let preserveItems = mustPreserveItems(state);
  let histOptions = historyKey.get(state).spec.config;
  let pop = (redo2 ? history.undone : history.done).popEvent(state, preserveItems);
  if (!pop)
    return null;
  let selection = pop.selection.resolve(pop.transform.doc);
  let added = (redo2 ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
  return pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist });
}
var cachedPreserveItems = false;
var cachedPreserveItemsPlugins = null;
function mustPreserveItems(state) {
  let plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (let i = 0; i < plugins.length; i++)
      if (plugins[i].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
  }
  return cachedPreserveItems;
}
var historyKey = new PluginKey("history");
var closeHistoryKey = new PluginKey("closeHistory");
function buildCommand(redo2, scroll) {
  return (state, dispatch) => {
    let hist = historyKey.getState(state);
    if (!hist || (redo2 ? hist.undone : hist.done).eventCount == 0)
      return false;
    if (dispatch) {
      let tr = histTransaction(hist, state, redo2);
      if (tr)
        dispatch(scroll ? tr.scrollIntoView() : tr);
    }
    return true;
  };
}
var undo = buildCommand(false, true);
var redo = buildCommand(true, true);
var undoNoScroll = buildCommand(false, false);
var redoNoScroll = buildCommand(true, false);

// node_modules/@milkdown/components/lib/code-block/index.es.js
var __defProp = Object.defineProperty;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
function withMeta(plugin, meta) {
  Object.assign(plugin, {
    meta: __spreadValues({
      package: "@milkdown/components"
    }, meta)
  });
  return plugin;
}
var defaultConfig = {
  extensions: [],
  languages: [],
  expandIcon: () => "⬇",
  searchIcon: () => "🔍",
  clearSearchIcon: () => "⌫",
  searchPlaceholder: "Search language",
  noResultText: "No result",
  renderLanguage: (language) => html`${language}`
};
var codeBlockConfig = h2(defaultConfig, "codeBlockConfigCtx");
withMeta(codeBlockConfig, {
  displayName: "Config<code-block>",
  group: "CodeBlock"
});
function defIfNotExists(tagName, element) {
  const current = customElements.get(tagName);
  if (current == null) {
    customElements.define(tagName, element);
    return;
  }
  if (current === element)
    return;
  console.warn(`Custom element ${tagName} has been defined before.`);
}
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var CodeMirrorBlock = class {
  constructor(node, view, getPos, loader, config) {
    this.node = node;
    this.view = view;
    this.getPos = getPos;
    this.loader = loader;
    this.config = config;
    this.updating = false;
    this.languageName = "";
    this.forwardUpdate = (update) => {
      var _a;
      if (this.updating || !this.cm.hasFocus)
        return;
      let offset = ((_a = this.getPos()) != null ? _a : 0) + 1;
      const { main } = update.state.selection;
      const selFrom = offset + main.from;
      const selTo = offset + main.to;
      const pmSel = this.view.state.selection;
      if (update.docChanged || pmSel.from !== selFrom || pmSel.to !== selTo) {
        const tr = this.view.state.tr;
        update.changes.iterChanges((fromA, toA, fromB, toB, text) => {
          if (text.length)
            tr.replaceWith(offset + fromA, offset + toA, this.view.state.schema.text(text.toString()));
          else tr.delete(offset + fromA, offset + toA);
          offset += toB - fromB - (toA - fromA);
        });
        tr.setSelection(TextSelection.create(tr.doc, selFrom, selTo));
        this.view.dispatch(tr);
      }
    };
    this.codeMirrorKeymap = () => {
      const view2 = this.view;
      return [
        { key: "ArrowUp", run: () => this.maybeEscape("line", -1) },
        { key: "ArrowLeft", run: () => this.maybeEscape("char", -1) },
        { key: "ArrowDown", run: () => this.maybeEscape("line", 1) },
        { key: "ArrowRight", run: () => this.maybeEscape("char", 1) },
        {
          key: "Mod-Enter",
          run: () => {
            if (!exitCode(view2.state, view2.dispatch))
              return false;
            view2.focus();
            return true;
          }
        },
        { key: "Mod-z", run: () => undo(view2.state, view2.dispatch) },
        { key: "Shift-Mod-z", run: () => redo(view2.state, view2.dispatch) },
        { key: "Mod-y", run: () => redo(view2.state, view2.dispatch) },
        {
          key: "Backspace",
          run: () => {
            var _a;
            const ranges = this.cm.state.selection.ranges;
            if (ranges.length > 1)
              return false;
            const selection = ranges[0];
            if (selection && (!selection.empty || selection.anchor > 0))
              return false;
            if (this.cm.state.doc.lines >= 2)
              return false;
            const state = this.view.state;
            const pos = (_a = this.getPos()) != null ? _a : 0;
            const tr = state.tr.replaceWith(pos, pos + this.node.nodeSize, state.schema.nodes.paragraph.createChecked({}, this.node.content));
            tr.setSelection(TextSelection.near(tr.doc.resolve(pos)));
            this.view.dispatch(tr);
            this.view.focus();
            return true;
          }
        }
      ];
    };
    this.maybeEscape = (unit, dir) => {
      var _a;
      const { state } = this.cm;
      let main = state.selection.main;
      if (!main.empty)
        return false;
      if (unit === "line")
        main = state.doc.lineAt(main.head);
      if (dir < 0 ? main.from > 0 : main.to < state.doc.length)
        return false;
      const targetPos = ((_a = this.getPos()) != null ? _a : 0) + (dir < 0 ? 0 : this.node.nodeSize);
      const selection = TextSelection.near(this.view.state.doc.resolve(targetPos), dir);
      const tr = this.view.state.tr.setSelection(selection).scrollIntoView();
      this.view.dispatch(tr);
      this.view.focus();
      return true;
    };
    this.setLanguage = (language) => {
      var _a;
      this.view.dispatch(
        this.view.state.tr.setNodeAttribute((_a = this.getPos()) != null ? _a : 0, "language", language)
      );
    };
    this.getAllLanguages = () => {
      return this.loader.getAll();
    };
    this.languageConf = new Compartment();
    this.readOnlyConf = new Compartment();
    this.cm = new EditorView({
      doc: this.node.textContent,
      root: this.view.root,
      extensions: [
        this.readOnlyConf.of(EditorState.readOnly.of(!this.view.editable)),
        keymap.of(this.codeMirrorKeymap()),
        this.languageConf.of([]),
        ...config.extensions,
        EditorView.updateListener.of(this.forwardUpdate)
      ]
    });
    this.dom = this.createDom();
    this.updateLanguage();
  }
  createDom() {
    const dom = document.createElement("milkdown-code-block");
    dom.codemirror = this.cm;
    dom.getAllLanguages = this.getAllLanguages;
    dom.setLanguage = this.setLanguage;
    dom.isEditorReadonly = () => !this.view.editable;
    const _a = this.config, viewConfig = __objRest(_a, [
      "languages",
      "extensions"
    ]);
    dom.config = viewConfig;
    return dom;
  }
  updateLanguage() {
    const languageName = this.node.attrs.language;
    if (languageName === this.languageName)
      return;
    this.dom.language = languageName;
    const language = this.loader.load(languageName != null ? languageName : "");
    language.then((lang) => {
      if (lang) {
        this.cm.dispatch({
          effects: this.languageConf.reconfigure(lang)
        });
        this.languageName = languageName;
      }
    });
  }
  setSelection(anchor, head) {
    if (!this.cm.dom.isConnected)
      return;
    this.cm.focus();
    this.updating = true;
    this.cm.dispatch({ selection: { anchor, head } });
    this.updating = false;
  }
  update(node) {
    if (node.type !== this.node.type)
      return false;
    if (this.updating)
      return true;
    this.node = node;
    this.updateLanguage();
    if (this.view.editable === this.cm.state.readOnly) {
      this.cm.dispatch({
        effects: this.readOnlyConf.reconfigure(EditorState.readOnly.of(!this.view.editable))
      });
    }
    const change = computeChange(this.cm.state.doc.toString(), node.textContent);
    if (change) {
      this.updating = true;
      this.cm.dispatch({
        changes: { from: change.from, to: change.to, insert: change.text }
      });
      this.updating = false;
    }
    return true;
  }
  selectNode() {
    this.dom.selected = true;
    this.cm.focus();
  }
  deselectNode() {
    this.dom.selected = false;
  }
  stopEvent() {
    return true;
  }
  destroy() {
    this.cm.destroy();
  }
};
function computeChange(oldVal, newVal) {
  if (oldVal === newVal)
    return null;
  let start = 0;
  let oldEnd = oldVal.length;
  let newEnd = newVal.length;
  while (start < oldEnd && oldVal.charCodeAt(start) === newVal.charCodeAt(start))
    ++start;
  while (oldEnd > start && newEnd > start && oldVal.charCodeAt(oldEnd - 1) === newVal.charCodeAt(newEnd - 1)) {
    oldEnd--;
    newEnd--;
  }
  return { from: start, to: oldEnd, text: newVal.slice(start, newEnd) };
}
var LanguageLoader = class {
  constructor(languages) {
    this.languages = languages;
    this.map = {};
    languages.forEach((language) => {
      language.alias.forEach((alias) => {
        this.map[alias] = language;
      });
    });
  }
  getAll() {
    return this.languages.map((language) => {
      return {
        name: language.name,
        alias: language.alias
      };
    });
  }
  load(languageName) {
    const languageMap = this.map;
    const language = languageMap[languageName.toLowerCase()];
    if (!language)
      return Promise.resolve(void 0);
    if (language.support)
      return Promise.resolve(language.support);
    return language.load();
  }
};
var codeComponent = ({
  selected = false,
  codemirror,
  getAllLanguages,
  setLanguage,
  language,
  config,
  isEditorReadonly
}) => {
  var _a, _b, _c;
  const host = useHost();
  const triggerRef = useRef();
  const pickerRef = useRef();
  const [filter, setFilter] = useState("");
  const [showPicker, setShowPicker] = useState(false);
  const root = useMemo(() => host.current.getRootNode(), [host]);
  useEffect(() => {
    var _a2;
    const lang = (_a2 = getAllLanguages == null ? void 0 : getAllLanguages()) == null ? void 0 : _a2.find((languageInfo) => languageInfo.alias.some((alias) => alias.toLowerCase() === (language == null ? void 0 : language.toLowerCase())));
    if (lang && lang.name !== language)
      setLanguage == null ? void 0 : setLanguage(lang.name);
  }, [language]);
  useEffect(() => {
    setShowPicker(false);
  }, [language]);
  useEffect(() => {
    const clickHandler = (e) => {
      const target = e.target;
      if (triggerRef.current && triggerRef.current.contains(target))
        return;
      const picker = pickerRef.current;
      if (!picker)
        return;
      if (picker.dataset.expanded !== "true")
        return;
      if (!picker.contains(target))
        setShowPicker(false);
    };
    root.addEventListener("click", clickHandler);
    return () => {
      root.removeEventListener("click", clickHandler);
    };
  }, []);
  useLayoutEffect(() => {
    setFilter("");
    const picker = triggerRef.current;
    const languageList = pickerRef.current;
    if (!picker || !languageList)
      return;
    computePosition(picker, languageList, {
      placement: "bottom-start"
    }).then(({ x, y }) => {
      Object.assign(languageList.style, {
        left: `${x}px`,
        top: `${y}px`
      });
    });
  }, [showPicker]);
  const languages = useMemo(() => {
    var _a2;
    if (!showPicker)
      return [];
    const all = (_a2 = getAllLanguages == null ? void 0 : getAllLanguages()) != null ? _a2 : [];
    const selected2 = all.find((languageInfo) => languageInfo.name.toLowerCase() === (language == null ? void 0 : language.toLowerCase()));
    const filtered = all.filter((languageInfo) => {
      return (languageInfo.name.toLowerCase().includes(filter.toLowerCase()) || languageInfo.alias.some((alias) => alias.toLowerCase().includes(filter.toLowerCase()))) && languageInfo !== selected2;
    });
    if (filtered.length === 0)
      return [];
    if (!selected2)
      return filtered;
    return [selected2, ...filtered];
  }, [filter, showPicker, language]);
  const changeFilter = (e) => {
    const target = e.target;
    setFilter(target.value);
  };
  const onTogglePicker = (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (isEditorReadonly == null ? void 0 : isEditorReadonly())
      return;
    setShowPicker((show) => {
      return !show;
    });
  };
  const onClear = (e) => {
    e.preventDefault();
    setFilter("");
  };
  const onSearchKeydown = (e) => {
    if (e.key === "Escape")
      setFilter("");
  };
  const onListKeydown = (e) => {
    if (e.key === "Enter") {
      const active = document.activeElement;
      if (active instanceof HTMLElement && active.dataset.language)
        setLanguage == null ? void 0 : setLanguage(active.dataset.language);
    }
  };
  const renderedLanguageList = useMemo(() => {
    if (!(languages == null ? void 0 : languages.length))
      return html`<li class="language-list-item no-result">${config == null ? void 0 : config.noResultText}</li>`;
    return languages.map(
      (languageInfo) => {
        var _a2;
        return html`<li
        role="listitem"
        tabindex="0"
        class="language-list-item"
        aria-selected=${languageInfo.name.toLowerCase() === (language == null ? void 0 : language.toLowerCase())}
        data-language=${languageInfo.name}
        onclick=${() => setLanguage == null ? void 0 : setLanguage(languageInfo.name)}
      >
        ${(_a2 = config == null ? void 0 : config.renderLanguage) == null ? void 0 : _a2.call(config, languageInfo.name, languageInfo.name.toLowerCase() === (language == null ? void 0 : language.toLowerCase()))}
      </li>`;
      }
    );
  }, [languages]);
  return html`<host class=${clsx_default(selected && "selected")}>
    <div class="tools">
      <button
        ref=${triggerRef}
        class="language-button"
        onpointerdown=${onTogglePicker}
        data-expanded=${showPicker}
      >
        ${language || "Text"}
        <div class="expand-icon">
          ${(_a = config == null ? void 0 : config.expandIcon) == null ? void 0 : _a.call(config)}
        </div>
      </button>
      <div ref=${pickerRef} data-expanded=${showPicker} class=${clsx_default("language-picker", showPicker && "show")}>
        <div class="list-wrapper">
          <div class="search-box">
            <div class="search-icon">
              ${(_b = config == null ? void 0 : config.searchIcon) == null ? void 0 : _b.call(config)}
            </div>
            <input
              class="search-input"
              placeholder=${config == null ? void 0 : config.searchPlaceholder}
              value=${filter}
              oninput=${changeFilter}
              onkeydown=${onSearchKeydown}
            />
            <div class=${clsx_default("clear-icon", filter.length === 0 && "hidden")} onmousedown=${onClear}>
              ${(_c = config == null ? void 0 : config.clearSearchIcon) == null ? void 0 : _c.call(config)}
            </div>
          </div>
          <ul class="language-list" role="listbox" onkeydown=${onListKeydown}>
            ${renderedLanguageList}
          </ul>
        </div>
      </div>
    </div>
    <div class="codemirror-host">${h(codemirror == null ? void 0 : codemirror.dom, {})}</div>
  </host>`;
};
codeComponent.props = {
  selected: Boolean,
  codemirror: Object,
  language: String,
  getAllLanguages: Function,
  setLanguage: Function,
  isEditorReadonly: Function,
  config: Object
};
var CodeElement = c(codeComponent);
defIfNotExists("milkdown-code-block", CodeElement);
var codeBlockView = le(W.node, (ctx) => {
  const config = ctx.get(codeBlockConfig.key);
  const languageLoader = new LanguageLoader(config.languages);
  return (node, view, getPos) => new CodeMirrorBlock(
    node,
    view,
    getPos,
    languageLoader,
    config
  );
});
withMeta(codeBlockView, {
  displayName: "NodeView<code-block>",
  group: "CodeBlock"
});
var codeBlockComponent = [
  codeBlockView,
  codeBlockConfig
];
export {
  codeBlockComponent,
  codeBlockConfig,
  codeBlockView,
  defaultConfig
};
//# sourceMappingURL=@milkdown_kit_component_code-block.js.map

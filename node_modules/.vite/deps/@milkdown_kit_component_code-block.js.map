{
  "version": 3,
  "sources": ["../../rope-sequence/dist/index.js", "../../prosemirror-history/dist/index.js", "../../@milkdown/components/src/__internal__/meta.ts", "../../@milkdown/components/src/code-block/config.ts", "../../@milkdown/components/src/__internal__/helper.ts", "../../@milkdown/components/src/code-block/view/node-view.ts", "../../@milkdown/components/src/code-block/view/loader.ts", "../../@milkdown/components/src/code-block/view/component.ts", "../../@milkdown/components/src/code-block/view/index.ts", "../../@milkdown/components/src/code-block/index.ts"],
  "sourcesContent": ["var GOOD_LEAF_SIZE = 200;\n\n// :: class<T> A rope sequence is a persistent sequence data structure\n// that supports appending, prepending, and slicing without doing a\n// full copy. It is represented as a mostly-balanced tree.\nvar RopeSequence = function RopeSequence () {};\n\nRopeSequence.prototype.append = function append (other) {\n  if (!other.length) { return this }\n  other = RopeSequence.from(other);\n\n  return (!this.length && other) ||\n    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||\n    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||\n    this.appendInner(other)\n};\n\n// :: (union<[T], RopeSequence<T>>) â†’ RopeSequence<T>\n// Prepend an array or other rope to this one, returning a new rope.\nRopeSequence.prototype.prepend = function prepend (other) {\n  if (!other.length) { return this }\n  return RopeSequence.from(other).append(this)\n};\n\nRopeSequence.prototype.appendInner = function appendInner (other) {\n  return new Append(this, other)\n};\n\n// :: (?number, ?number) â†’ RopeSequence<T>\n// Create a rope repesenting a sub-sequence of this rope.\nRopeSequence.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from >= to) { return RopeSequence.empty }\n  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))\n};\n\n// :: (number) â†’ T\n// Retrieve the element at the given position from this rope.\nRopeSequence.prototype.get = function get (i) {\n  if (i < 0 || i >= this.length) { return undefined }\n  return this.getInner(i)\n};\n\n// :: ((element: T, index: number) â†’ ?bool, ?number, ?number)\n// Call the given function for each element between the given\n// indices. This tends to be more efficient than looping over the\n// indices and calling `get`, because it doesn't have to descend the\n// tree for every element.\nRopeSequence.prototype.forEach = function forEach (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from <= to)\n    { this.forEachInner(f, from, to, 0); }\n  else\n    { this.forEachInvertedInner(f, from, to, 0); }\n};\n\n// :: ((element: T, index: number) â†’ U, ?number, ?number) â†’ [U]\n// Map the given functions over the elements of the rope, producing\n// a flat array.\nRopeSequence.prototype.map = function map (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  var result = [];\n  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);\n  return result\n};\n\n// :: (?union<[T], RopeSequence<T>>) â†’ RopeSequence<T>\n// Create a rope representing the given array, or return the rope\n// itself if a rope was given.\nRopeSequence.from = function from (values) {\n  if (values instanceof RopeSequence) { return values }\n  return values && values.length ? new Leaf(values) : RopeSequence.empty\n};\n\nvar Leaf = /*@__PURE__*/(function (RopeSequence) {\n  function Leaf(values) {\n    RopeSequence.call(this);\n    this.values = values;\n  }\n\n  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;\n  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Leaf.prototype.constructor = Leaf;\n\n  var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };\n\n  Leaf.prototype.flatten = function flatten () {\n    return this.values\n  };\n\n  Leaf.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    return new Leaf(this.values.slice(from, to))\n  };\n\n  Leaf.prototype.getInner = function getInner (i) {\n    return this.values[i]\n  };\n\n  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    for (var i = from; i < to; i++)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    for (var i = from - 1; i >= to; i--)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.leafAppend = function leafAppend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(this.values.concat(other.flatten())) }\n  };\n\n  Leaf.prototype.leafPrepend = function leafPrepend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(other.flatten().concat(this.values)) }\n  };\n\n  prototypeAccessors.length.get = function () { return this.values.length };\n\n  prototypeAccessors.depth.get = function () { return 0 };\n\n  Object.defineProperties( Leaf.prototype, prototypeAccessors );\n\n  return Leaf;\n}(RopeSequence));\n\n// :: RopeSequence\n// The empty rope sequence.\nRopeSequence.empty = new Leaf([]);\n\nvar Append = /*@__PURE__*/(function (RopeSequence) {\n  function Append(left, right) {\n    RopeSequence.call(this);\n    this.left = left;\n    this.right = right;\n    this.length = left.length + right.length;\n    this.depth = Math.max(left.depth, right.depth) + 1;\n  }\n\n  if ( RopeSequence ) Append.__proto__ = RopeSequence;\n  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Append.prototype.constructor = Append;\n\n  Append.prototype.flatten = function flatten () {\n    return this.left.flatten().concat(this.right.flatten())\n  };\n\n  Append.prototype.getInner = function getInner (i) {\n    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)\n  };\n\n  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from < leftLen &&\n        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)\n      { return false }\n    if (to > leftLen &&\n        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)\n      { return false }\n  };\n\n  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from > leftLen &&\n        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)\n      { return false }\n    if (to < leftLen &&\n        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)\n      { return false }\n  };\n\n  Append.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    var leftLen = this.left.length;\n    if (to <= leftLen) { return this.left.slice(from, to) }\n    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }\n    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))\n  };\n\n  Append.prototype.leafAppend = function leafAppend (other) {\n    var inner = this.right.leafAppend(other);\n    if (inner) { return new Append(this.left, inner) }\n  };\n\n  Append.prototype.leafPrepend = function leafPrepend (other) {\n    var inner = this.left.leafPrepend(other);\n    if (inner) { return new Append(inner, this.right) }\n  };\n\n  Append.prototype.appendInner = function appendInner (other) {\n    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)\n      { return new Append(this.left, new Append(this.right, other)) }\n    return new Append(this, other)\n  };\n\n  return Append;\n}(RopeSequence));\n\nexport default RopeSequence;\n", "import RopeSequence from 'rope-sequence';\nimport { Mapping } from 'prosemirror-transform';\nimport { PluginKey, Plugin } from 'prosemirror-state';\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' â€” a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\nconst max_empty_items = 500;\nclass Branch {\n    constructor(items, eventCount) {\n        this.items = items;\n        this.eventCount = eventCount;\n    }\n    // Pop the latest event off the branch's history and apply it\n    // to a document transform.\n    popEvent(state, preserveItems) {\n        if (this.eventCount == 0)\n            return null;\n        let end = this.items.length;\n        for (;; end--) {\n            let next = this.items.get(end - 1);\n            if (next.selection) {\n                --end;\n                break;\n            }\n        }\n        let remap, mapFrom;\n        if (preserveItems) {\n            remap = this.remapping(end, this.items.length);\n            mapFrom = remap.maps.length;\n        }\n        let transform = state.tr;\n        let selection, remaining;\n        let addAfter = [], addBefore = [];\n        this.items.forEach((item, i) => {\n            if (!item.step) {\n                if (!remap) {\n                    remap = this.remapping(end, i + 1);\n                    mapFrom = remap.maps.length;\n                }\n                mapFrom--;\n                addBefore.push(item);\n                return;\n            }\n            if (remap) {\n                addBefore.push(new Item(item.map));\n                let step = item.step.map(remap.slice(mapFrom)), map;\n                if (step && transform.maybeStep(step).doc) {\n                    map = transform.mapping.maps[transform.mapping.maps.length - 1];\n                    addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));\n                }\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n            }\n            else {\n                transform.maybeStep(item.step);\n            }\n            if (item.selection) {\n                selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n                remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n                return false;\n            }\n        }, this.items.length, 0);\n        return { remaining: remaining, transform, selection: selection };\n    }\n    // Create a new branch with the given transform added.\n    addTransform(transform, selection, histOptions, preserveItems) {\n        let newItems = [], eventCount = this.eventCount;\n        let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n        for (let i = 0; i < transform.steps.length; i++) {\n            let step = transform.steps[i].invert(transform.docs[i]);\n            let item = new Item(transform.mapping.maps[i], step, selection), merged;\n            if (merged = lastItem && lastItem.merge(item)) {\n                item = merged;\n                if (i)\n                    newItems.pop();\n                else\n                    oldItems = oldItems.slice(0, oldItems.length - 1);\n            }\n            newItems.push(item);\n            if (selection) {\n                eventCount++;\n                selection = undefined;\n            }\n            if (!preserveItems)\n                lastItem = item;\n        }\n        let overflow = eventCount - histOptions.depth;\n        if (overflow > DEPTH_OVERFLOW) {\n            oldItems = cutOffEvents(oldItems, overflow);\n            eventCount -= overflow;\n        }\n        return new Branch(oldItems.append(newItems), eventCount);\n    }\n    remapping(from, to) {\n        let maps = new Mapping;\n        this.items.forEach((item, i) => {\n            let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\n                ? maps.maps.length - item.mirrorOffset : undefined;\n            maps.appendMap(item.map, mirrorPos);\n        }, from, to);\n        return maps;\n    }\n    addMaps(array) {\n        if (this.eventCount == 0)\n            return this;\n        return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount);\n    }\n    // When the collab module receives remote changes, the history has\n    // to know about those, so that it can adjust the steps that were\n    // rebased on top of the remote changes, and include the position\n    // maps for the remote changes in its array of items.\n    rebased(rebasedTransform, rebasedCount) {\n        if (!this.eventCount)\n            return this;\n        let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);\n        let mapping = rebasedTransform.mapping;\n        let newUntil = rebasedTransform.steps.length;\n        let eventCount = this.eventCount;\n        this.items.forEach(item => { if (item.selection)\n            eventCount--; }, start);\n        let iRebased = rebasedCount;\n        this.items.forEach(item => {\n            let pos = mapping.getMirror(--iRebased);\n            if (pos == null)\n                return;\n            newUntil = Math.min(newUntil, pos);\n            let map = mapping.maps[pos];\n            if (item.step) {\n                let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n                let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n                if (selection)\n                    eventCount++;\n                rebasedItems.push(new Item(map, step, selection));\n            }\n            else {\n                rebasedItems.push(new Item(map));\n            }\n        }, start);\n        let newMaps = [];\n        for (let i = rebasedCount; i < newUntil; i++)\n            newMaps.push(new Item(mapping.maps[i]));\n        let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n        let branch = new Branch(items, eventCount);\n        if (branch.emptyItemCount() > max_empty_items)\n            branch = branch.compress(this.items.length - rebasedItems.length);\n        return branch;\n    }\n    emptyItemCount() {\n        let count = 0;\n        this.items.forEach(item => { if (!item.step)\n            count++; });\n        return count;\n    }\n    // Compressing a branch means rewriting it to push the air (map-only\n    // items) out. During collaboration, these naturally accumulate\n    // because each remote change adds one. The `upto` argument is used\n    // to ensure that only the items below a given level are compressed,\n    // because `rebased` relies on a clean, untouched set of items in\n    // order to associate old items with rebased steps.\n    compress(upto = this.items.length) {\n        let remap = this.remapping(0, upto), mapFrom = remap.maps.length;\n        let items = [], events = 0;\n        this.items.forEach((item, i) => {\n            if (i >= upto) {\n                items.push(item);\n                if (item.selection)\n                    events++;\n            }\n            else if (item.step) {\n                let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n                if (step) {\n                    let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n                    if (selection)\n                        events++;\n                    let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;\n                    if (merged = items.length && items[last].merge(newItem))\n                        items[last] = merged;\n                    else\n                        items.push(newItem);\n                }\n            }\n            else if (item.map) {\n                mapFrom--;\n            }\n        }, this.items.length, 0);\n        return new Branch(RopeSequence.from(items.reverse()), events);\n    }\n}\nBranch.empty = new Branch(RopeSequence.empty, 0);\nfunction cutOffEvents(items, n) {\n    let cutPoint;\n    items.forEach((item, i) => {\n        if (item.selection && (n-- == 0)) {\n            cutPoint = i;\n            return false;\n        }\n    });\n    return items.slice(cutPoint);\n}\nclass Item {\n    constructor(\n    // The (forward) step map for this item.\n    map, \n    // The inverted step\n    step, \n    // If this is non-null, this item is the start of a group, and\n    // this selection is the starting selection for the group (the one\n    // that was active before the first step was applied)\n    selection, \n    // If this item is the inverse of a previous mapping on the stack,\n    // this points at the inverse's offset\n    mirrorOffset) {\n        this.map = map;\n        this.step = step;\n        this.selection = selection;\n        this.mirrorOffset = mirrorOffset;\n    }\n    merge(other) {\n        if (this.step && other.step && !other.selection) {\n            let step = other.step.merge(this.step);\n            if (step)\n                return new Item(step.getMap().invert(), step, this.selection);\n        }\n    }\n}\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nclass HistoryState {\n    constructor(done, undone, prevRanges, prevTime, prevComposition) {\n        this.done = done;\n        this.undone = undone;\n        this.prevRanges = prevRanges;\n        this.prevTime = prevTime;\n        this.prevComposition = prevComposition;\n    }\n}\nconst DEPTH_OVERFLOW = 20;\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n    let historyTr = tr.getMeta(historyKey), rebased;\n    if (historyTr)\n        return historyTr.historyState;\n    if (tr.getMeta(closeHistoryKey))\n        history = new HistoryState(history.done, history.undone, null, 0, -1);\n    let appended = tr.getMeta(\"appendedTransaction\");\n    if (tr.steps.length == 0) {\n        return history;\n    }\n    else if (appended && appended.getMeta(historyKey)) {\n        if (appended.getMeta(historyKey).redo)\n            return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps), history.prevTime, history.prevComposition);\n        else\n            return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime, history.prevComposition);\n    }\n    else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n        // Group transforms that occur in quick succession into one event.\n        let composition = tr.getMeta(\"composition\");\n        let newGroup = history.prevTime == 0 ||\n            (!appended && history.prevComposition != composition &&\n                (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges)));\n        let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps);\n        return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history.prevComposition : composition);\n    }\n    else if (rebased = tr.getMeta(\"rebased\")) {\n        // Used by the collab module to tell the history that some of its\n        // content has been rebased.\n        return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n    else {\n        return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n}\nfunction isAdjacentTo(transform, prevRanges) {\n    if (!prevRanges)\n        return false;\n    if (!transform.docChanged)\n        return true;\n    let adjacent = false;\n    transform.mapping.maps[0].forEach((start, end) => {\n        for (let i = 0; i < prevRanges.length; i += 2)\n            if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n                adjacent = true;\n    });\n    return adjacent;\n}\nfunction rangesFor(maps) {\n    let result = [];\n    for (let i = maps.length - 1; i >= 0 && result.length == 0; i--)\n        maps[i].forEach((_from, _to, from, to) => result.push(from, to));\n    return result;\n}\nfunction mapRanges(ranges, mapping) {\n    if (!ranges)\n        return null;\n    let result = [];\n    for (let i = 0; i < ranges.length; i += 2) {\n        let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);\n        if (from <= to)\n            result.push(from, to);\n    }\n    return result;\n}\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, redo) {\n    let preserveItems = mustPreserveItems(state);\n    let histOptions = historyKey.get(state).spec.config;\n    let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n    if (!pop)\n        return null;\n    let selection = pop.selection.resolve(pop.transform.doc);\n    let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n    let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1);\n    return pop.transform.setSelection(selection).setMeta(historyKey, { redo, historyState: newHist });\n}\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null;\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n    let plugins = state.plugins;\n    if (cachedPreserveItemsPlugins != plugins) {\n        cachedPreserveItems = false;\n        cachedPreserveItemsPlugins = plugins;\n        for (let i = 0; i < plugins.length; i++)\n            if (plugins[i].spec.historyPreserveItems) {\n                cachedPreserveItems = true;\n                break;\n            }\n    }\n    return cachedPreserveItems;\n}\n/**\nSet a flag on the given transaction that will prevent further steps\nfrom being appended to an existing history event (so that they\nrequire a separate undo command to undo).\n*/\nfunction closeHistory(tr) {\n    return tr.setMeta(closeHistoryKey, true);\n}\nconst historyKey = new PluginKey(\"history\");\nconst closeHistoryKey = new PluginKey(\"closeHistory\");\n/**\nReturns a plugin that enables the undo history for an editor. The\nplugin will track undo and redo stacks, which can be used with the\n[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.\n\nYou can set an `\"addToHistory\"` [metadata\nproperty](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction\nto prevent it from being rolled back by undo.\n*/\nfunction history(config = {}) {\n    config = { depth: config.depth || 100,\n        newGroupDelay: config.newGroupDelay || 500 };\n    return new Plugin({\n        key: historyKey,\n        state: {\n            init() {\n                return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);\n            },\n            apply(tr, hist, state) {\n                return applyTransaction(hist, state, tr, config);\n            }\n        },\n        config,\n        props: {\n            handleDOMEvents: {\n                beforeinput(view, e) {\n                    let inputType = e.inputType;\n                    let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n                    if (!command)\n                        return false;\n                    e.preventDefault();\n                    return command(view.state, view.dispatch);\n                }\n            }\n        }\n    });\n}\nfunction buildCommand(redo, scroll) {\n    return (state, dispatch) => {\n        let hist = historyKey.getState(state);\n        if (!hist || (redo ? hist.undone : hist.done).eventCount == 0)\n            return false;\n        if (dispatch) {\n            let tr = histTransaction(hist, state, redo);\n            if (tr)\n                dispatch(scroll ? tr.scrollIntoView() : tr);\n        }\n        return true;\n    };\n}\n/**\nA command function that undoes the last change, if any.\n*/\nconst undo = buildCommand(false, true);\n/**\nA command function that redoes the last undone change, if any.\n*/\nconst redo = buildCommand(true, true);\n/**\nA command function that undoes the last change. Don't scroll the\nselection into view.\n*/\nconst undoNoScroll = buildCommand(false, false);\n/**\nA command function that redoes the last undone change. Don't\nscroll the selection into view.\n*/\nconst redoNoScroll = buildCommand(true, false);\n/**\nThe amount of undoable events available in a given state.\n*/\nfunction undoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.done.eventCount : 0;\n}\n/**\nThe amount of redoable events available in a given editor state.\n*/\nfunction redoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.undone.eventCount : 0;\n}\n\nexport { closeHistory, history, redo, redoDepth, redoNoScroll, undo, undoDepth, undoNoScroll };\n", "import type { Meta, MilkdownPlugin } from '@milkdown/ctx'\n\nexport function withMeta<T extends MilkdownPlugin>(plugin: T, meta: Partial<Meta> & Pick<Meta, 'displayName'>): T {\n  Object.assign(plugin, {\n    meta: {\n      package: '@milkdown/components',\n      ...meta,\n    },\n  })\n\n  return plugin\n}\n", "import { $ctx } from '@milkdown/utils'\nimport type { Extension } from '@codemirror/state'\nimport type { LanguageDescription } from '@codemirror/language'\nimport { html } from 'atomico'\nimport { withMeta } from '../__internal__/meta'\n\nexport interface CodeBlockConfig {\n  extensions: Extension[]\n  languages: LanguageDescription[]\n  expandIcon: () => ReturnType<typeof html> | string | HTMLElement\n  searchIcon: () => ReturnType<typeof html> | string | HTMLElement\n  clearSearchIcon: () => ReturnType<typeof html> | string | HTMLElement\n  searchPlaceholder: string\n  noResultText: string\n  renderLanguage: (language: string, selected: boolean) => ReturnType<typeof html>\n}\n\nexport const defaultConfig: CodeBlockConfig = {\n  extensions: [],\n  languages: [],\n  expandIcon: () => 'â¬‡',\n  searchIcon: () => 'ðŸ”',\n  clearSearchIcon: () => 'âŒ«',\n  searchPlaceholder: 'Search language',\n  noResultText: 'No result',\n  renderLanguage: language => html`${language}`,\n}\n\nexport const codeBlockConfig = $ctx(defaultConfig, 'codeBlockConfigCtx')\n\nwithMeta(codeBlockConfig, {\n  displayName: 'Config<code-block>',\n  group: 'CodeBlock',\n})\n", "export function defIfNotExists(tagName: string, element: CustomElementConstructor) {\n  const current = customElements.get(tagName)\n  if (current == null) {\n    customElements.define(tagName, element)\n    return\n  }\n\n  if (current === element)\n    return\n\n  console.warn(`Custom element ${tagName} has been defined before.`)\n}\n", "import type { EditorView, NodeView } from '@milkdown/prose/view'\nimport { EditorView as CodeMirror, type KeyBinding, type ViewUpdate, keymap as cmKeymap } from '@codemirror/view'\nimport type { Node } from '@milkdown/prose/model'\nimport { redo, undo } from '@milkdown/prose/history'\nimport { Compartment, EditorState } from '@codemirror/state'\nimport type { Line, SelectionRange } from '@codemirror/state'\nimport { exitCode } from '@milkdown/prose/commands'\nimport { TextSelection } from '@milkdown/prose/state'\n\nimport type { CodeBlockConfig } from '../config'\nimport type { CodeComponentProps } from './component'\nimport type { LanguageLoader } from './loader'\n\nexport class CodeMirrorBlock implements NodeView {\n  dom: HTMLElement & CodeComponentProps\n  cm: CodeMirror\n\n  private updating = false\n  private languageName: string = ''\n\n  private readonly languageConf: Compartment\n  private readonly readOnlyConf: Compartment\n\n  constructor(\n    public node: Node,\n    public view: EditorView,\n    public getPos: () => number | undefined,\n    public loader: LanguageLoader,\n    public config: CodeBlockConfig,\n  ) {\n    this.languageConf = new Compartment()\n    this.readOnlyConf = new Compartment()\n\n    this.cm = new CodeMirror({\n      doc: this.node.textContent,\n      root: this.view.root,\n      extensions: [\n        this.readOnlyConf.of(EditorState.readOnly.of(!this.view.editable)),\n        cmKeymap.of(this.codeMirrorKeymap()),\n        this.languageConf.of([]),\n        ...config.extensions,\n        CodeMirror.updateListener.of(this.forwardUpdate),\n      ],\n    })\n\n    this.dom = this.createDom()\n\n    this.updateLanguage()\n  }\n\n  private forwardUpdate = (update: ViewUpdate) => {\n    if (this.updating || !this.cm.hasFocus)\n      return\n    let offset = (this.getPos() ?? 0) + 1\n    const { main } = update.state.selection\n    const selFrom = offset + main.from\n    const selTo = offset + main.to\n    const pmSel = this.view.state.selection\n    if (update.docChanged || pmSel.from !== selFrom || pmSel.to !== selTo) {\n      const tr = this.view.state.tr\n      update.changes.iterChanges((fromA, toA, fromB, toB, text) => {\n        if (text.length)\n          tr.replaceWith(offset + fromA, offset + toA, this.view.state.schema.text(text.toString()))\n        else tr.delete(offset + fromA, offset + toA)\n        offset += (toB - fromB) - (toA - fromA)\n      })\n      tr.setSelection(TextSelection.create(tr.doc, selFrom, selTo))\n      this.view.dispatch(tr)\n    }\n  }\n\n  private createDom() {\n    const dom = document.createElement('milkdown-code-block') as HTMLElement & CodeComponentProps\n    dom.codemirror = this.cm\n    dom.getAllLanguages = this.getAllLanguages\n    dom.setLanguage = this.setLanguage\n    dom.isEditorReadonly = () => !this.view.editable\n    const {\n      languages,\n      extensions,\n      ...viewConfig\n    } = this.config\n    dom.config = viewConfig\n    return dom\n  }\n\n  private updateLanguage() {\n    const languageName = this.node.attrs.language\n\n    if (languageName === this.languageName)\n      return\n\n    this.dom.language = languageName\n    const language = this.loader.load(languageName ?? '')\n\n    language.then((lang) => {\n      if (lang) {\n        this.cm.dispatch({\n          effects: this.languageConf.reconfigure(lang),\n        })\n        this.languageName = languageName\n      }\n    })\n  }\n\n  private codeMirrorKeymap = (): KeyBinding[] => {\n    const view = this.view\n    return [\n      { key: 'ArrowUp', run: () => this.maybeEscape('line', -1) },\n      { key: 'ArrowLeft', run: () => this.maybeEscape('char', -1) },\n      { key: 'ArrowDown', run: () => this.maybeEscape('line', 1) },\n      { key: 'ArrowRight', run: () => this.maybeEscape('char', 1) },\n      {\n        key: 'Mod-Enter',\n        run: () => {\n          if (!exitCode(view.state, view.dispatch))\n            return false\n\n          view.focus()\n          return true\n        },\n      },\n      { key: 'Mod-z', run: () => undo(view.state, view.dispatch) },\n      { key: 'Shift-Mod-z', run: () => redo(view.state, view.dispatch) },\n      { key: 'Mod-y', run: () => redo(view.state, view.dispatch) },\n      {\n        key: 'Backspace',\n        run: () => {\n          const ranges = this.cm.state.selection.ranges\n\n          if (ranges.length > 1)\n            return false\n\n          const selection = ranges[0]\n\n          if (selection && (!selection.empty || selection.anchor > 0))\n            return false\n\n          if (this.cm.state.doc.lines >= 2)\n            return false\n\n          const state = this.view.state\n          const pos = this.getPos() ?? 0\n          const tr = state.tr.replaceWith(pos, pos + this.node.nodeSize, state.schema.nodes.paragraph!.createChecked({}, this.node.content))\n\n          tr.setSelection(TextSelection.near(tr.doc.resolve(pos)))\n\n          this.view.dispatch(tr)\n          this.view.focus()\n          return true\n        },\n      },\n    ]\n  }\n\n  private maybeEscape = (unit: 'line' | 'char', dir: -1 | 1): boolean => {\n    const { state } = this.cm\n    let main: SelectionRange | Line = state.selection.main\n    if (!main.empty)\n      return false\n    if (unit === 'line')\n      main = state.doc.lineAt(main.head)\n    if (dir < 0 ? main.from > 0 : main.to < state.doc.length)\n      return false\n\n    const targetPos = (this.getPos() ?? 0) + (dir < 0 ? 0 : this.node.nodeSize)\n    const selection = TextSelection.near(this.view.state.doc.resolve(targetPos), dir)\n    const tr = this.view.state.tr.setSelection(selection).scrollIntoView()\n    this.view.dispatch(tr)\n    this.view.focus()\n    return true\n  }\n\n  setSelection(anchor: number, head: number) {\n    if (!this.cm.dom.isConnected)\n      return\n\n    this.cm.focus()\n    this.updating = true\n    this.cm.dispatch({ selection: { anchor, head } })\n    this.updating = false\n  }\n\n  update(node: Node) {\n    if (node.type !== this.node.type)\n      return false\n\n    if (this.updating)\n      return true\n\n    this.node = node\n    this.updateLanguage()\n    if (this.view.editable === this.cm.state.readOnly) {\n      this.cm.dispatch({\n        effects: this.readOnlyConf.reconfigure(EditorState.readOnly.of(!this.view.editable)),\n      })\n    }\n\n    const change = computeChange(this.cm.state.doc.toString(), node.textContent)\n    if (change) {\n      this.updating = true\n      this.cm.dispatch({\n        changes: { from: change.from, to: change.to, insert: change.text },\n      })\n      this.updating = false\n    }\n    return true\n  }\n\n  selectNode() {\n    this.dom.selected = true\n    this.cm.focus()\n  }\n\n  deselectNode() {\n    this.dom.selected = false\n  }\n\n  stopEvent() {\n    return true\n  }\n\n  destroy() {\n    this.cm.destroy()\n  }\n\n  setLanguage = (language: string) => {\n    this.view.dispatch(\n      this.view.state.tr.setNodeAttribute(this.getPos() ?? 0, 'language', language),\n    )\n  }\n\n  getAllLanguages = () => {\n    return this.loader.getAll()\n  }\n}\n\nfunction computeChange(\n  oldVal: string,\n  newVal: string,\n): { from: number, to: number, text: string } | null {\n  if (oldVal === newVal)\n    return null\n\n  let start = 0\n  let oldEnd = oldVal.length\n  let newEnd = newVal.length\n\n  while (start < oldEnd && oldVal.charCodeAt(start) === newVal.charCodeAt(start))\n    ++start\n\n  while (\n    oldEnd > start\n    && newEnd > start\n    && oldVal.charCodeAt(oldEnd - 1) === newVal.charCodeAt(newEnd - 1)\n  ) {\n    oldEnd--\n    newEnd--\n  }\n\n  return { from: start, to: oldEnd, text: newVal.slice(start, newEnd) }\n}\n", "import type { LanguageDescription, LanguageSupport } from '@codemirror/language'\n\nexport interface LanguageInfo {\n  name: string\n  alias: readonly string[]\n}\n\nexport class LanguageLoader {\n  private readonly map: Record<string, LanguageDescription>\n\n  constructor(private languages: LanguageDescription[]) {\n    this.map = {}\n\n    languages.forEach((language) => {\n      language.alias.forEach((alias) => {\n        this.map[alias] = language\n      })\n    })\n  }\n\n  getAll(): LanguageInfo[] {\n    return this.languages.map((language): LanguageInfo => {\n      return {\n        name: language.name,\n        alias: language.alias,\n      }\n    })\n  }\n\n  load(languageName: string): Promise<LanguageSupport | undefined> {\n    const languageMap = this.map\n    const language = languageMap[languageName.toLowerCase()]\n\n    if (!language)\n      return Promise.resolve(undefined)\n\n    if (language.support)\n      return Promise.resolve(language.support)\n\n    return language.load()\n  }\n}\n", "import type { EditorView as CodeMirror } from '@codemirror/view'\nimport type { Component } from 'atomico'\nimport { c, h, html, useEffect, useHost, useLayoutEffect, useMemo, useRef, useState } from 'atomico'\nimport { computePosition } from '@floating-ui/dom'\nimport clsx from 'clsx'\nimport type { CodeBlockConfig } from '../config'\nimport type { LanguageInfo } from './loader'\n\nexport interface CodeComponentProps {\n  selected: boolean\n  codemirror: CodeMirror\n  language: string\n  getAllLanguages: () => Array<LanguageInfo>\n  setLanguage: (language: string) => void\n  isEditorReadonly: () => boolean\n  config: Omit<CodeBlockConfig, 'languages' | 'extensions'>\n}\n\nexport const codeComponent: Component<CodeComponentProps> = ({\n  selected = false,\n  codemirror,\n  getAllLanguages,\n  setLanguage,\n  language,\n  config,\n  isEditorReadonly,\n}) => {\n  const host = useHost()\n  const triggerRef = useRef<HTMLButtonElement>()\n  const pickerRef = useRef<HTMLDivElement>()\n  const [filter, setFilter] = useState('')\n  const [showPicker, setShowPicker] = useState(false)\n\n  const root = useMemo(() => host.current.getRootNode() as HTMLElement, [host])\n\n  useEffect(() => {\n    const lang = getAllLanguages?.()?.find(languageInfo =>\n      languageInfo.alias.some(alias =>\n        alias.toLowerCase() === language?.toLowerCase()))\n\n    if (lang && lang.name !== language)\n      setLanguage?.(lang.name)\n  }, [language])\n\n  useEffect(() => {\n    setShowPicker(false)\n  }, [language])\n\n  useEffect(() => {\n    const clickHandler = (e: MouseEvent) => {\n      const target = e.target as HTMLElement\n\n      if (triggerRef.current && triggerRef.current.contains(target))\n        return\n\n      const picker = pickerRef.current\n      if (!picker)\n        return\n\n      if (picker.dataset.expanded !== 'true')\n        return\n\n      if (!picker.contains(target))\n        setShowPicker(false)\n    }\n\n    root.addEventListener('click', clickHandler)\n\n    return () => {\n      root.removeEventListener('click', clickHandler)\n    }\n  }, [])\n\n  useLayoutEffect(() => {\n    setFilter('')\n    const picker = triggerRef.current\n    const languageList = pickerRef.current\n    if (!picker || !languageList)\n      return\n\n    computePosition(picker, languageList, {\n      placement: 'bottom-start',\n    }).then(({ x, y }) => {\n      Object.assign(languageList.style, {\n        left: `${x}px`,\n        top: `${y}px`,\n      })\n    })\n  }, [showPicker])\n\n  const languages = useMemo(() => {\n    if (!showPicker)\n      return []\n\n    const all = getAllLanguages?.() ?? []\n\n    const selected = all.find(languageInfo => languageInfo.name.toLowerCase() === language?.toLowerCase())\n\n    const filtered = all.filter((languageInfo) => {\n      return (languageInfo.name.toLowerCase().includes(filter.toLowerCase())\n        || languageInfo.alias.some(alias => alias.toLowerCase().includes(filter.toLowerCase()))) && languageInfo !== selected\n    })\n\n    if (filtered.length === 0)\n      return []\n\n    if (!selected)\n      return filtered\n\n    return [selected, ...filtered]\n  }, [filter, showPicker, language])\n\n  const changeFilter = (e: InputEvent) => {\n    const target = e.target as HTMLInputElement\n    setFilter(target.value)\n  }\n\n  const onTogglePicker = (e: Event) => {\n    e.preventDefault()\n    e.stopPropagation()\n    if (isEditorReadonly?.())\n      return\n\n    setShowPicker((show) => {\n      return !show\n    })\n  }\n\n  const onClear = (e: MouseEvent) => {\n    e.preventDefault()\n    setFilter('')\n  }\n\n  const onSearchKeydown = (e: KeyboardEvent) => {\n    if (e.key === 'Escape')\n      setFilter('')\n  }\n\n  const onListKeydown = (e: KeyboardEvent) => {\n    if (e.key === 'Enter') {\n      const active = document.activeElement\n      if (active instanceof HTMLElement && active.dataset.language)\n        setLanguage?.(active.dataset.language)\n    }\n  }\n\n  const renderedLanguageList = useMemo(() => {\n    if (!languages?.length)\n      return html`<li class=\"language-list-item no-result\">${config?.noResultText}</li>`\n\n    return languages.map(languageInfo =>\n      html`<li\n        role=\"listitem\"\n        tabindex=\"0\"\n        class=\"language-list-item\"\n        aria-selected=${languageInfo.name.toLowerCase() === language?.toLowerCase()}\n        data-language=${languageInfo.name}\n        onclick=${() => setLanguage?.(languageInfo.name)}\n      >\n        ${config?.renderLanguage?.(languageInfo.name, languageInfo.name.toLowerCase() === language?.toLowerCase())}\n      </li>`,\n    )\n  }, [languages])\n\n  return html`<host class=${clsx(selected && 'selected')}>\n    <div class=\"tools\">\n      <button\n        ref=${triggerRef}\n        class=\"language-button\"\n        onpointerdown=${onTogglePicker}\n        data-expanded=${showPicker}\n      >\n        ${language || 'Text'}\n        <div class=\"expand-icon\">\n          ${config?.expandIcon?.()}\n        </div>\n      </button>\n      <div ref=${pickerRef} data-expanded=${showPicker} class=${clsx('language-picker', showPicker && 'show')}>\n        <div class=\"list-wrapper\">\n          <div class=\"search-box\">\n            <div class=\"search-icon\">\n              ${config?.searchIcon?.()}\n            </div>\n            <input\n              class=\"search-input\"\n              placeholder=${config?.searchPlaceholder}\n              value=${filter}\n              oninput=${changeFilter}\n              onkeydown=${onSearchKeydown}\n            />\n            <div class=${clsx('clear-icon', filter.length === 0 && 'hidden')} onmousedown=${onClear}>\n              ${config?.clearSearchIcon?.()}\n            </div>\n          </div>\n          <ul class=\"language-list\" role=\"listbox\" onkeydown=${onListKeydown}>\n            ${renderedLanguageList}\n          </ul>\n        </div>\n      </div>\n    </div>\n    <div class=\"codemirror-host\">${h(codemirror?.dom, {})}</div>\n  </host>`\n}\n\ncodeComponent.props = {\n  selected: Boolean,\n  codemirror: Object,\n  language: String,\n  getAllLanguages: Function,\n  setLanguage: Function,\n  isEditorReadonly: Function,\n  config: Object,\n}\n\nexport const CodeElement = c(codeComponent)\n", "import { $view } from '@milkdown/utils'\nimport { codeBlockSchema } from '@milkdown/preset-commonmark'\nimport type { NodeViewConstructor } from '@milkdown/prose/view'\nimport { codeBlockConfig } from '../config'\nimport { withMeta } from '../../__internal__/meta'\nimport { defIfNotExists } from '../../__internal__/helper'\nimport { CodeMirrorBlock } from './node-view'\nimport { LanguageLoader } from './loader'\nimport { CodeElement } from './component'\n\ndefIfNotExists('milkdown-code-block', CodeElement)\nexport const codeBlockView = $view(codeBlockSchema.node, (ctx): NodeViewConstructor => {\n  const config = ctx.get(codeBlockConfig.key)\n  const languageLoader = new LanguageLoader(config.languages)\n  return (node, view, getPos) => new CodeMirrorBlock(\n    node,\n    view,\n    getPos,\n    languageLoader,\n    config,\n  )\n})\n\nwithMeta(codeBlockView, {\n  displayName: 'NodeView<code-block>',\n  group: 'CodeBlock',\n})\n", "import type { MilkdownPlugin } from '@milkdown/ctx'\nimport { codeBlockView } from './view'\nimport { codeBlockConfig } from './config'\n\nexport * from './config'\nexport * from './view'\n\nexport const codeBlockComponent: MilkdownPlugin[] = [\n  codeBlockView,\n  codeBlockConfig,\n]\n"],
  "mappings": "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",
  "names": ["RopeSequence", "from", "Leaf", "Append", "appendInner", "map", "from", "redo", "redo", "h", "view", "CodeMirror", "cmKeymap", "_a", "selected"]
}

import l, { createContext as w, useContext as g, useCallback as h, useState as E, useRef as N, useEffect as p, useMemo as k } from "react";
import { CoreNodeView as D, CorePluginView as W, CoreWidgetView as R } from "@prosemirror-adapter/core";
import { nanoid as m } from "nanoid";
import { createPortal as v, flushSync as b } from "react-dom";
import { Decoration as O } from "prosemirror-view";
const V = w({
  contentRef: () => {
  },
  view: null,
  getPos: () => 0,
  setAttrs: () => {
  },
  node: null,
  selected: !1,
  decorations: [],
  innerDecorations: null
}), I = () => g(V), P = w(
  (n) => {
    throw new Error("out of scope");
  }
), J = () => g(P);
class A extends D {
  constructor() {
    super(...arguments), this.key = m(), this.context = {
      contentRef: (t) => {
        t && this.contentDOM && t.firstChild !== this.contentDOM && t.appendChild(this.contentDOM);
      },
      view: this.view,
      getPos: this.getPos,
      setAttrs: this.setAttrs,
      node: this.node,
      selected: this.selected,
      decorations: this.decorations,
      innerDecorations: this.innerDecorations
    }, this.updateContext = () => {
      Object.assign(this.context, {
        node: this.node,
        selected: this.selected,
        decorations: this.decorations,
        innerDecorations: this.innerDecorations
      });
    }, this.render = () => {
      const t = this.component;
      return v(
        /* @__PURE__ */ l.createElement(V.Provider, { value: this.context }, /* @__PURE__ */ l.createElement(t, null)),
        this.dom,
        this.key
      );
    };
  }
}
const x = w({
  view: null
}), K = () => g(x), C = w(
  (n) => {
    throw new Error("out of scope");
  }
), L = () => g(C), F = (n, t) => h(
  (e) => (d, r, s, i, o) => {
    const c = new A({
      node: d,
      view: r,
      getPos: s,
      decorations: i,
      innerDecorations: o,
      options: {
        ...e,
        onUpdate() {
          var a;
          (a = e.onUpdate) == null || a.call(e), n(c);
        },
        selectNode() {
          var a;
          (a = e.selectNode) == null || a.call(e), n(c);
        },
        deselectNode() {
          var a;
          (a = e.deselectNode) == null || a.call(e), n(c);
        },
        destroy() {
          var a;
          (a = e.destroy) == null || a.call(e), t(c);
        }
      }
    });
    return n(c, !1), c;
  },
  [t, n]
);
class U extends W {
  constructor() {
    super(...arguments), this.key = m(), this.context = {
      view: this.view,
      prevState: this.prevState
    }, this.updateContext = () => {
      Object.assign(this.context, {
        view: this.view,
        prevState: this.prevState
      });
    }, this.render = () => {
      const t = this.component;
      return v(
        /* @__PURE__ */ l.createElement(x.Provider, { value: this.context }, /* @__PURE__ */ l.createElement(t, null)),
        this.root,
        this.key
      );
    };
  }
}
const j = (n, t) => h((e) => (d) => {
  const r = new U({
    view: d,
    options: {
      ...e,
      update: (s, i) => {
        var o;
        (o = e.update) == null || o.call(e, s, i), n(r);
      },
      destroy: () => {
        var s;
        (s = e.destroy) == null || s.call(e), t(r);
      }
    }
  });
  return n(r, !1), r;
}, [t, n]), M = () => {
  const [n, t] = E({}), u = N(!1);
  p(() => (requestAnimationFrame(() => {
    u.current = !0;
  }), () => {
    u.current = !1;
  }), []);
  const e = h((s) => {
    u.current ? b(s) : s();
  }, []), d = h(
    (s, i = !0) => {
      e(() => {
        i && s.updateContext(), t((o) => ({
          ...o,
          [s.key]: s.render()
        }));
      });
    },
    [e]
  ), r = h(
    (s) => {
      e(() => {
        t((i) => {
          const o = { ...i };
          return delete o[s.key], o;
        });
      });
    },
    [e]
  );
  return {
    portals: n,
    renderReactRenderer: d,
    removeReactRenderer: r
  };
}, f = w({
  view: null,
  getPos: () => {
  }
}), Q = () => g(f), y = w(
  (n) => {
    throw new Error("out of scope");
  }
), T = () => g(y);
class _ extends R {
  constructor() {
    super(...arguments), this.key = m(), this.context = {
      view: this.view,
      getPos: this.getPos,
      spec: this.spec
    }, this.updateContext = () => {
      Object.assign(this.context, {
        view: this.view,
        getPos: this.getPos,
        spec: this.spec
      });
    }, this.render = () => {
      const t = this.component;
      return v(
        /* @__PURE__ */ l.createElement(f.Provider, { value: this.context }, /* @__PURE__ */ l.createElement(t, null)),
        this.dom,
        this.key
      );
    };
  }
}
const S = (n, t) => h((e) => (d, r = {}) => {
  const s = new _({
    pos: d,
    options: e
  }), i = {
    ...r,
    destroy: (o) => {
      var c;
      (c = r.destroy) == null || c.call(r, o), t(s);
    }
  };
  return s.spec = i, O.widget(d, (o, c) => (s.bind(o, c), n(s), s.dom), i);
}, [t, n]), X = ({ children: n }) => {
  const { renderReactRenderer: t, removeReactRenderer: u, portals: e } = M(), d = F(t, u), r = j(t, u), s = S(t, u), i = k(() => Object.values(e), [e]);
  return /* @__PURE__ */ l.createElement(P.Provider, { value: d }, /* @__PURE__ */ l.createElement(C.Provider, { value: r }, /* @__PURE__ */ l.createElement(y.Provider, { value: s }, n, i)));
};
export {
  X as ProsemirrorAdapterProvider,
  A as ReactNodeView,
  U as ReactPluginView,
  _ as ReactWidgetView,
  P as createNodeViewContext,
  C as createPluginViewContext,
  y as createWidgetViewContext,
  V as nodeViewContext,
  x as pluginViewContext,
  I as useNodeViewContext,
  J as useNodeViewFactory,
  K as usePluginViewContext,
  L as usePluginViewFactory,
  Q as useWidgetViewContext,
  T as useWidgetViewFactory,
  f as widgetViewContext
};
//# sourceMappingURL=index.es.js.map

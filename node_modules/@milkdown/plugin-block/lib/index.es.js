var q = (o, t, e) => {
  if (!t.has(o))
    throw TypeError("Cannot " + e);
};
var i = (o, t, e) => (q(o, t, "read from private field"), e ? e.call(o) : t.get(o)), a = (o, t, e) => {
  if (t.has(o))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(o) : t.set(o, e);
}, n = (o, t, e, r) => (q(o, t, "write to private field"), r ? r.call(o, e) : t.set(o, e), e);
var Z = (o, t, e) => (q(o, t, "access private method"), e);
import { $ctx as V, $prose as lt } from "@milkdown/utils";
import { findParent as at, browser as j } from "@milkdown/prose";
import { NodeSelection as tt, PluginKey as ct, Plugin as ht } from "@milkdown/prose/state";
import { editorViewCtx as J } from "@milkdown/core";
import dt from "lodash.throttle";
import { DOMSerializer as ut } from "@milkdown/prose/model";
import { flip as ft, offset as pt, computePosition as gt } from "@floating-ui/dom";
function W(o, t) {
  return Object.assign(o, {
    meta: {
      package: "@milkdown/plugin-block",
      ...t
    }
  }), o;
}
const mt = (o) => !at((e) => e.type.name === "table")(o), _ = V({ filterNodes: mt }, "blockConfig");
W(_, {
  displayName: "Ctx<blockConfig>"
});
function bt(o, t, e) {
  var S;
  if (!o.dom.parentElement)
    return null;
  const s = (S = o.posAtCoords({
    left: t.x,
    top: t.y
  })) == null ? void 0 : S.inside;
  if (s == null || s < 0)
    return null;
  let l = o.state.doc.resolve(s), c = o.state.doc.nodeAt(s), d = o.nodeDOM(s);
  const h = (z) => {
    const Y = l.depth >= 1 && l.index(l.depth) === 0;
    if (!(z || Y))
      return;
    const T = l.before(l.depth);
    c = o.state.doc.nodeAt(T), d = o.nodeDOM(T), l = o.state.doc.resolve(T), e(l, c) || h(!0);
  }, u = e(l, c);
  return h(!u), !d || !c ? null : { node: c, $pos: l, el: d };
}
let et = null;
function kt() {
  return et || (et = document.implementation.createHTMLDocument("title"));
}
const Ct = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
function yt(o, t) {
  const e = [];
  let { openStart: r, openEnd: s, content: l } = t;
  for (; r > 1 && s > 1 && l.childCount === 1 && l.firstChild.childCount === 1; ) {
    r -= 1, s -= 1;
    const p = l.firstChild;
    e.push(
      p.type.name,
      p.attrs !== p.type.defaultAttrs ? p.attrs : null
    ), l = p.content;
  }
  const c = o.someProp("clipboardSerializer") || ut.fromSchema(o.state.schema), d = kt(), h = d.createElement("div");
  h.appendChild(c.serializeFragment(l, { document: d }));
  let u = h.firstChild, S, z = 0;
  for (; u && u.nodeType === 1 && (S = Ct[u.nodeName.toLowerCase()]); ) {
    for (let p = S.length - 1; p >= 0; p--) {
      const T = d.createElement(S[p]);
      for (; h.firstChild; )
        T.appendChild(h.firstChild);
      h.appendChild(T), z++;
    }
    u = h.firstChild;
  }
  u && u.nodeType === 1 && u.setAttribute(
    "data-pm-slice",
    `${r} ${s}${z ? ` -${z}` : ""} ${JSON.stringify(e)}`
  );
  const Y = o.someProp("clipboardTextSerializer", (p) => p(t, o)) || t.content.textBetween(0, t.content.size, `

`);
  return { dom: h, text: Y };
}
const it = j.ie && j.ie_version < 15 || j.ios && j.webkit_version < 604, st = 20;
var D, H, k, g, M, m, I, ot, C, A, y, v, F, P, B, N, K, x;
class vt {
  constructor() {
    /// @internal
    a(this, I);
    /// @internal
    a(this, C);
    /// @internal
    a(this, D, void 0);
    a(this, H, void 0);
    a(this, k, void 0);
    a(this, g, void 0);
    a(this, M, void 0);
    a(this, m, void 0);
    /// @internal
    a(this, y, void 0);
    a(this, v, void 0);
    a(this, F, void 0);
    a(this, P, void 0);
    a(this, B, void 0);
    a(this, N, void 0);
    a(this, K, void 0);
    a(this, x, void 0);
    n(this, H, () => {
      if (!i(this, g))
        return null;
      const t = i(this, g), e = i(this, C, A);
      if (e && tt.isSelectable(t.node)) {
        const r = tt.create(e.state.doc, t.$pos.pos);
        return e.dispatch(e.state.tr.setSelection(r)), e.focus(), n(this, k, r), r;
      }
      return null;
    }), n(this, k, null), n(this, g, null), n(this, M, void 0), n(this, m, !1), n(this, v, () => {
      var t;
      (t = i(this, y)) == null || t.call(this, { type: "hide" }), n(this, g, null);
    }), n(this, F, (t) => {
      var e;
      n(this, g, t), (e = i(this, y)) == null || e.call(this, { type: "show", active: t });
    }), this.bind = (t, e) => {
      n(this, D, t), n(this, y, e);
    }, this.addEvent = (t) => {
      t.addEventListener("mousedown", i(this, P)), t.addEventListener("mouseup", i(this, B)), t.addEventListener("dragstart", i(this, N));
    }, this.removeEvent = (t) => {
      t.removeEventListener("mousedown", i(this, P)), t.removeEventListener("mouseup", i(this, B)), t.removeEventListener("dragstart", i(this, N));
    }, this.unBind = () => {
      n(this, y, void 0);
    }, n(this, P, () => {
      var t;
      n(this, M, (t = i(this, g)) == null ? void 0 : t.el.getBoundingClientRect()), i(this, H).call(this);
    }), n(this, B, () => {
      if (!i(this, m)) {
        requestAnimationFrame(() => {
          var t;
          i(this, M) && ((t = i(this, C, A)) == null || t.focus());
        });
        return;
      }
      n(this, m, !1), n(this, k, null);
    }), n(this, N, (t) => {
      var s;
      n(this, m, !0);
      const e = i(this, C, A);
      if (!e)
        return;
      e.dom.dataset.dragging = "true";
      const r = i(this, k);
      if (t.dataTransfer && r) {
        const l = r.content();
        t.dataTransfer.effectAllowed = "copyMove";
        const { dom: c, text: d } = yt(e, l);
        t.dataTransfer.clearData(), t.dataTransfer.setData(it ? "Text" : "text/html", c.innerHTML), it || t.dataTransfer.setData("text/plain", d);
        const h = (s = i(this, g)) == null ? void 0 : s.el;
        h && t.dataTransfer.setDragImage(h, 0, 0), e.dragging = {
          slice: l,
          move: !0
        };
      }
    }), this.keydownCallback = (t) => (i(this, v).call(this), n(this, m, !1), t.dom.dataset.dragging = "false", !1), n(this, K, dt((t, e) => {
      if (!t.editable)
        return;
      const r = t.dom.getBoundingClientRect(), s = r.left + r.width / 2;
      if (!(t.root.elementFromPoint(s, e.clientY) instanceof Element)) {
        i(this, v).call(this);
        return;
      }
      const c = i(this, I, ot);
      if (!c)
        return;
      const d = bt(t, { x: s, y: e.clientY }, c);
      if (!d) {
        i(this, v).call(this);
        return;
      }
      i(this, F).call(this, d);
    }, 200)), this.mousemoveCallback = (t, e) => (t.composing || !t.editable || i(this, K).call(this, t, e), !1), this.dragoverCallback = (t, e) => {
      var r;
      if (i(this, m)) {
        const s = (r = i(this, C, A)) == null ? void 0 : r.dom.parentElement;
        if (!s)
          return !1;
        const l = s.scrollHeight > s.clientHeight, c = s.getBoundingClientRect();
        if (l) {
          if (s.scrollTop > 0 && Math.abs(e.y - c.y) < st) {
            const u = s.scrollTop > 10 ? s.scrollTop - 10 : 0;
            return s.scrollTop = u, !1;
          }
          const d = Math.round(t.dom.getBoundingClientRect().height);
          if (Math.round(s.scrollTop + c.height) < d && Math.abs(e.y - (c.height + c.y)) < st) {
            const u = s.scrollTop + 10;
            return s.scrollTop = u, !1;
          }
        }
      }
      return !1;
    }, this.dragenterCallback = (t) => {
      t.dragging && (n(this, m, !0), t.dom.dataset.dragging = "true");
    }, this.dragleaveCallback = (t, e) => {
      const r = e.clientX, s = e.clientY;
      (r < 0 || s < 0 || r > window.innerWidth || s > window.innerHeight) && (n(this, g, null), i(this, x).call(this, t));
    }, this.dropCallback = (t) => (i(this, x).call(this, t), !1), this.dragendCallback = (t) => {
      i(this, x).call(this, t);
    }, n(this, x, (t) => {
      n(this, m, !1), t.dom.dataset.dragging = "false";
    });
  }
}
D = new WeakMap(), H = new WeakMap(), k = new WeakMap(), g = new WeakMap(), M = new WeakMap(), m = new WeakMap(), I = new WeakSet(), ot = function() {
  var t;
  return (t = i(this, D)) == null ? void 0 : t.get(_.key).filterNodes;
}, C = new WeakSet(), A = function() {
  var t;
  return (t = i(this, D)) == null ? void 0 : t.get(J);
}, y = new WeakMap(), v = new WeakMap(), F = new WeakMap(), P = new WeakMap(), B = new WeakMap(), N = new WeakMap(), K = new WeakMap(), x = new WeakMap();
const X = V(new vt(), "blockService");
W(_, {
  displayName: "Ctx<blockService>"
});
const G = V({}, "blockSpec");
W(_, {
  displayName: "Ctx<blockSpec>"
});
const Q = lt((o) => {
  const t = new ct("MILKDOWN_BLOCK"), e = o.get(X.key), r = o.get(G.key);
  return new ht({
    key: t,
    ...r,
    props: {
      ...r.props,
      handleDOMEvents: {
        drop: (s) => e.dropCallback(s),
        pointermove: (s, l) => e.mousemoveCallback(s, l),
        keydown: (s) => e.keydownCallback(s),
        dragover: (s, l) => e.dragoverCallback(s, l),
        dragleave: (s, l) => e.dragleaveCallback(s, l),
        dragenter: (s) => e.dragenterCallback(s),
        dragend: (s) => e.dragendCallback(s)
      }
    }
  });
});
W(Q, {
  displayName: "Prose<block>"
});
var f, b, w, E, O, L, $, R, U, nt;
class Bt {
  constructor(t) {
    /// @internal
    a(this, U);
    /// @internal
    a(this, f, void 0);
    /// @internal
    a(this, b, void 0);
    /// @internal
    a(this, w, void 0);
    a(this, E, void 0);
    a(this, O, void 0);
    /// @internal
    a(this, L, void 0);
    /// @internal
    a(this, $, void 0);
    /// @internal
    a(this, R, void 0);
    n(this, E, null), n(this, O, !1), this.update = () => {
      requestAnimationFrame(() => {
        if (!i(this, O))
          try {
            Z(this, U, nt).call(this), n(this, O, !0);
          } catch {
          }
      });
    }, this.destroy = () => {
      var e, r;
      (e = i(this, w)) == null || e.unBind(), (r = i(this, w)) == null || r.removeEvent(i(this, f)), i(this, f).remove();
    }, this.show = (e) => {
      const r = e.el, s = i(this, b).get(J).dom, l = {
        ctx: i(this, b),
        active: e,
        editorDom: s,
        blockDom: i(this, f)
      }, c = {
        contextElement: r,
        getBoundingClientRect: () => i(this, $) ? i(this, $).call(this, l) : r.getBoundingClientRect()
      }, d = [ft()];
      if (i(this, L)) {
        const h = i(this, L).call(this, l), u = pt(h);
        d.push(u);
      }
      gt(c, i(this, f), {
        placement: i(this, R) ? i(this, R).call(this, l) : "left",
        middleware: d
      }).then(({ x: h, y: u }) => {
        Object.assign(i(this, f).style, {
          left: `${h}px`,
          top: `${u}px`
        }), i(this, f).dataset.show = "true";
      });
    }, this.hide = () => {
      i(this, f).dataset.show = "false", setTimeout(() => {
        Object.assign(i(this, f).style, {
          left: "-999px",
          top: "-999px"
        });
      }, 200);
    }, n(this, b, t.ctx), n(this, f, t.content), n(this, L, t.getOffset), n(this, $, t.getPosition), n(this, R, t.getPlacement), this.hide();
  }
  /// The context of current active node.
  get active() {
    return i(this, E);
  }
}
f = new WeakMap(), b = new WeakMap(), w = new WeakMap(), E = new WeakMap(), O = new WeakMap(), L = new WeakMap(), $ = new WeakMap(), R = new WeakMap(), U = new WeakSet(), nt = function() {
  var r;
  (r = i(this, b).get(J).dom.parentElement) == null || r.appendChild(i(this, f));
  const e = i(this, b).get(X.key);
  e.bind(i(this, b), (s) => {
    s.type === "hide" ? (this.hide(), n(this, E, null)) : s.type === "show" && (this.show(s.active), n(this, E, s.active));
  }), n(this, w, e), i(this, w).addEvent(i(this, f)), i(this, f).draggable = !0;
};
const rt = [G, _, X, Q];
rt.key = G.key;
rt.pluginKey = Q.key;
export {
  Bt as BlockProvider,
  vt as BlockService,
  rt as block,
  _ as blockConfig,
  Q as blockPlugin,
  X as blockService,
  G as blockSpec,
  mt as defaultNodeFilter
};
//# sourceMappingURL=index.es.js.map
